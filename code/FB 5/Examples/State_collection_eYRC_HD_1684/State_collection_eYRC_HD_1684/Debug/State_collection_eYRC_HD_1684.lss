
State_collection_eYRC_HD_1684.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000004a  00800200  00003940  000039d4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00003940  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000031c  0080024a  0080024a  00003a1e  2**0
                  ALLOC
  3 .stab         00003a38  00000000  00000000  00003a20  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000b91  00000000  00000000  00007458  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000000e8  00000000  00000000  00007ff0  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00002cbe  00000000  00000000  000080d8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000055f  00000000  00000000  0000ad96  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001074  00000000  00000000  0000b2f5  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000082c  00000000  00000000  0000c36c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000815  00000000  00000000  0000cb98  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000025c3  00000000  00000000  0000d3ad  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000048  00000000  00000000  0000f970  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 b3 00 	jmp	0x166	; 0x166 <__ctors_end>
       4:	0c 94 9f 15 	jmp	0x2b3e	; 0x2b3e <__vector_1>
       8:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
       c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      10:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      14:	0c 94 f8 0a 	jmp	0x15f0	; 0x15f0 <__vector_5>
      18:	0c 94 92 0a 	jmp	0x1524	; 0x1524 <__vector_6>
      1c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      20:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      24:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      28:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      2c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      30:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      34:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      38:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      3c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      40:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      44:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      48:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      4c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      50:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      54:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      58:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      5c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      60:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      64:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      68:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      6c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      70:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      74:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      78:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      7c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      80:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      84:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      88:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      8c:	0c 94 c6 14 	jmp	0x298c	; 0x298c <__vector_35>
      90:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      94:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      98:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      9c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      a0:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      a4:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      a8:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      ac:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      b0:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      b4:	0c 94 58 02 	jmp	0x4b0	; 0x4b0 <__vector_45>
      b8:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      bc:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      c0:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      c4:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      c8:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      cc:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      d0:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      d4:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      d8:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      dc:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      e0:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      e4:	07 63       	ori	r16, 0x37	; 55
      e6:	42 36       	cpi	r20, 0x62	; 98
      e8:	b7 9b       	sbis	0x16, 7	; 22
      ea:	d8 a7       	lds	r29, 0x78
      ec:	1a 39       	cpi	r17, 0x9A	; 154
      ee:	68 56       	subi	r22, 0x68	; 104
      f0:	18 ae       	sts	0xb8, r17
      f2:	ba ab       	sts	0x5a, r27
      f4:	55 8c       	ldd	r5, Z+29	; 0x1d
      f6:	1d 3c       	cpi	r17, 0xCD	; 205
      f8:	b7 cc       	rjmp	.-1682   	; 0xfffffa68 <__eeprom_end+0xff7efa68>
      fa:	57 63       	ori	r21, 0x37	; 55
      fc:	bd 6d       	ori	r27, 0xDD	; 221
      fe:	ed fd       	.word	0xfded	; ????
     100:	75 3e       	cpi	r23, 0xE5	; 229
     102:	f6 17       	cp	r31, r22
     104:	72 31       	cpi	r23, 0x12	; 18
     106:	bf 00       	.word	0x00bf	; ????
     108:	00 00       	nop
     10a:	80 3f       	cpi	r24, 0xF0	; 240
     10c:	08 00       	.word	0x0008	; ????
     10e:	00 00       	nop
     110:	be 92       	st	-X, r11
     112:	24 49       	sbci	r18, 0x94	; 148
     114:	12 3e       	cpi	r17, 0xE2	; 226
     116:	ab aa       	sts	0x9b, r26
     118:	aa 2a       	or	r10, r26
     11a:	be cd       	rjmp	.-1156   	; 0xfffffc98 <__eeprom_end+0xff7efc98>
     11c:	cc cc       	rjmp	.-1640   	; 0xfffffab6 <__eeprom_end+0xff7efab6>
     11e:	4c 3e       	cpi	r20, 0xEC	; 236
     120:	00 00       	nop
     122:	00 80       	ld	r0, Z
     124:	be ab       	sts	0x5e, r27
     126:	aa aa       	sts	0x9a, r26
     128:	aa 3e       	cpi	r26, 0xEA	; 234
     12a:	00 00       	nop
     12c:	00 00       	nop
     12e:	bf 00       	.word	0x00bf	; ????
     130:	00 00       	nop
     132:	80 3f       	cpi	r24, 0xF0	; 240
     134:	00 00       	nop
     136:	00 00       	nop
     138:	00 08       	sbc	r0, r0
     13a:	41 78       	andi	r20, 0x81	; 129
     13c:	d3 bb       	out	0x13, r29	; 19
     13e:	43 87       	std	Z+11, r20	; 0x0b
     140:	d1 13       	cpse	r29, r17
     142:	3d 19       	sub	r19, r13
     144:	0e 3c       	cpi	r16, 0xCE	; 206
     146:	c3 bd       	out	0x23, r28	; 35
     148:	42 82       	std	Z+2, r4	; 0x02
     14a:	ad 2b       	or	r26, r29
     14c:	3e 68       	ori	r19, 0x8E	; 142
     14e:	ec 82       	std	Y+4, r14	; 0x04
     150:	76 be       	out	0x36, r7	; 54
     152:	d9 8f       	std	Y+25, r29	; 0x19
     154:	e1 a9       	sts	0x41, r30
     156:	3e 4c       	sbci	r19, 0xCE	; 206
     158:	80 ef       	ldi	r24, 0xF0	; 240
     15a:	ff be       	out	0x3f, r15	; 63
     15c:	01 c4       	rjmp	.+2050   	; 0x960 <navigate+0xb6>
     15e:	ff 7f       	andi	r31, 0xFF	; 255
     160:	3f 00       	.word	0x003f	; ????
     162:	00 00       	nop
	...

00000166 <__ctors_end>:
     166:	11 24       	eor	r1, r1
     168:	1f be       	out	0x3f, r1	; 63
     16a:	cf ef       	ldi	r28, 0xFF	; 255
     16c:	d1 e2       	ldi	r29, 0x21	; 33
     16e:	de bf       	out	0x3e, r29	; 62
     170:	cd bf       	out	0x3d, r28	; 61
     172:	00 e0       	ldi	r16, 0x00	; 0
     174:	0c bf       	out	0x3c, r16	; 60

00000176 <__do_copy_data>:
     176:	12 e0       	ldi	r17, 0x02	; 2
     178:	a0 e0       	ldi	r26, 0x00	; 0
     17a:	b2 e0       	ldi	r27, 0x02	; 2
     17c:	e0 e4       	ldi	r30, 0x40	; 64
     17e:	f9 e3       	ldi	r31, 0x39	; 57
     180:	00 e0       	ldi	r16, 0x00	; 0
     182:	0b bf       	out	0x3b, r16	; 59
     184:	02 c0       	rjmp	.+4      	; 0x18a <__do_copy_data+0x14>
     186:	07 90       	elpm	r0, Z+
     188:	0d 92       	st	X+, r0
     18a:	aa 34       	cpi	r26, 0x4A	; 74
     18c:	b1 07       	cpc	r27, r17
     18e:	d9 f7       	brne	.-10     	; 0x186 <__do_copy_data+0x10>

00000190 <__do_clear_bss>:
     190:	15 e0       	ldi	r17, 0x05	; 5
     192:	aa e4       	ldi	r26, 0x4A	; 74
     194:	b2 e0       	ldi	r27, 0x02	; 2
     196:	01 c0       	rjmp	.+2      	; 0x19a <.do_clear_bss_start>

00000198 <.do_clear_bss_loop>:
     198:	1d 92       	st	X+, r1

0000019a <.do_clear_bss_start>:
     19a:	a6 36       	cpi	r26, 0x66	; 102
     19c:	b1 07       	cpc	r27, r17
     19e:	e1 f7       	brne	.-8      	; 0x198 <.do_clear_bss_loop>
     1a0:	0e 94 0e 17 	call	0x2e1c	; 0x2e1c <main>
     1a4:	0c 94 9e 1c 	jmp	0x393c	; 0x393c <_exit>

000001a8 <__bad_interrupt>:
     1a8:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000001ac <def>:
*/

void def(void)
{
	int i=0,j=0;
	for(i=0;i<=maximum_number_of_nodes;i++)	//i: will iterate from 0 to the maximum nodes (maximum_number_of_nodes is the constant for the maximum number of nodes in the arena )
     1ac:	20 e0       	ldi	r18, 0x00	; 0
     1ae:	30 e0       	ldi	r19, 0x00	; 0
* Logic:			All the nodes of the arena are accessed and given null value (more specifically null character)
* Example Call:		def();
*
*/

void def(void)
     1b0:	40 e0       	ldi	r20, 0x00	; 0
     1b2:	50 e0       	ldi	r21, 0x00	; 0
     1b4:	0a c0       	rjmp	.+20     	; 0x1ca <def+0x1e>
{
	int i=0,j=0;
	for(i=0;i<=maximum_number_of_nodes;i++)	//i: will iterate from 0 to the maximum nodes (maximum_number_of_nodes is the constant for the maximum number of nodes in the arena )
	for(j=0;j<=maximum_number_of_nodes;j++)	//j: will iterate from 0 to the maximum nodes (maximum_number_of_nodes is the constant for the maximum number of nodes in the arena )
	graph[i][j]='\0';
     1b6:	11 92       	st	Z+, r1

void def(void)
{
	int i=0,j=0;
	for(i=0;i<=maximum_number_of_nodes;i++)	//i: will iterate from 0 to the maximum nodes (maximum_number_of_nodes is the constant for the maximum number of nodes in the arena )
	for(j=0;j<=maximum_number_of_nodes;j++)	//j: will iterate from 0 to the maximum nodes (maximum_number_of_nodes is the constant for the maximum number of nodes in the arena )
     1b8:	01 96       	adiw	r24, 0x01	; 1
     1ba:	8a 31       	cpi	r24, 0x1A	; 26
     1bc:	91 05       	cpc	r25, r1
     1be:	d9 f7       	brne	.-10     	; 0x1b6 <def+0xa>
*/

void def(void)
{
	int i=0,j=0;
	for(i=0;i<=maximum_number_of_nodes;i++)	//i: will iterate from 0 to the maximum nodes (maximum_number_of_nodes is the constant for the maximum number of nodes in the arena )
     1c0:	2f 5f       	subi	r18, 0xFF	; 255
     1c2:	3f 4f       	sbci	r19, 0xFF	; 255
     1c4:	2a 31       	cpi	r18, 0x1A	; 26
     1c6:	31 05       	cpc	r19, r1
     1c8:	89 f0       	breq	.+34     	; 0x1ec <def+0x40>
* Logic:			All the nodes of the arena are accessed and given null value (more specifically null character)
* Example Call:		def();
*
*/

void def(void)
     1ca:	f9 01       	movw	r30, r18
     1cc:	ee 0f       	add	r30, r30
     1ce:	ff 1f       	adc	r31, r31
     1d0:	e2 0f       	add	r30, r18
     1d2:	f3 1f       	adc	r31, r19
     1d4:	ee 0f       	add	r30, r30
     1d6:	ff 1f       	adc	r31, r31
     1d8:	ee 0f       	add	r30, r30
     1da:	ff 1f       	adc	r31, r31
     1dc:	ee 0f       	add	r30, r30
     1de:	ff 1f       	adc	r31, r31
     1e0:	e2 0f       	add	r30, r18
     1e2:	f3 1f       	adc	r31, r19
     1e4:	e4 54       	subi	r30, 0x44	; 68
     1e6:	fd 4f       	sbci	r31, 0xFD	; 253
     1e8:	ca 01       	movw	r24, r20
     1ea:	e5 cf       	rjmp	.-54     	; 0x1b6 <def+0xa>
     1ec:	08 95       	ret

000001ee <sppeed>:
*
*/

void sppeed(unsigned int l,unsigned int r) 
{
	cli();
     1ee:	f8 94       	cli
	OCR5A=l;		// OCR5A = for left motor
     1f0:	90 93 29 01 	sts	0x0129, r25
     1f4:	80 93 28 01 	sts	0x0128, r24
	OCR5B=r;		// OCR5B = for right motor
     1f8:	70 93 2b 01 	sts	0x012B, r23
     1fc:	60 93 2a 01 	sts	0x012A, r22
	sei();
     200:	78 94       	sei
}
     202:	08 95       	ret

00000204 <enqueue>:
* Example Call:			enqueue(10);
*
*/

void enqueue(int node_added)
{
     204:	0f 93       	push	r16
     206:	1f 93       	push	r17
     208:	cf 93       	push	r28
     20a:	df 93       	push	r29
     20c:	8c 01       	movw	r16, r24
	struct queue *newnode;
	if(root==NULL)
     20e:	c0 91 4c 02 	lds	r28, 0x024C
     212:	d0 91 4d 02 	lds	r29, 0x024D
     216:	20 97       	sbiw	r28, 0x00	; 0
     218:	a9 f4       	brne	.+42     	; 0x244 <enqueue+0x40>
	{
		root=(struct queue*)malloc(sizeof(struct queue));
     21a:	86 e0       	ldi	r24, 0x06	; 6
     21c:	90 e0       	ldi	r25, 0x00	; 0
     21e:	0e 94 6f 1b 	call	0x36de	; 0x36de <malloc>
     222:	e8 2f       	mov	r30, r24
     224:	f9 2f       	mov	r31, r25
     226:	f0 93 4d 02 	sts	0x024D, r31
     22a:	e0 93 4c 02 	sts	0x024C, r30
		root->num=node_added;
     22e:	15 83       	std	Z+5, r17	; 0x05
     230:	04 83       	std	Z+4, r16	; 0x04
		root->next=NULL;
     232:	11 82       	std	Z+1, r1	; 0x01
     234:	10 82       	st	Z, r1
		root->prev=NULL;
     236:	13 82       	std	Z+3, r1	; 0x03
     238:	12 82       	std	Z+2, r1	; 0x02
		end=root;
     23a:	f0 93 4b 02 	sts	0x024B, r31
     23e:	e0 93 4a 02 	sts	0x024A, r30
     242:	19 c0       	rjmp	.+50     	; 0x276 <enqueue+0x72>
	}
	else
	{
		newnode=(struct queue*)malloc(sizeof(struct queue));
     244:	86 e0       	ldi	r24, 0x06	; 6
     246:	90 e0       	ldi	r25, 0x00	; 0
     248:	0e 94 6f 1b 	call	0x36de	; 0x36de <malloc>
     24c:	e8 2f       	mov	r30, r24
     24e:	f9 2f       	mov	r31, r25
		newnode->num=node_added;
     250:	15 83       	std	Z+5, r17	; 0x05
     252:	04 83       	std	Z+4, r16	; 0x04
		root->next=newnode;
     254:	f9 83       	std	Y+1, r31	; 0x01
     256:	e8 83       	st	Y, r30
		newnode->prev=root;
     258:	a0 91 4c 02 	lds	r26, 0x024C
     25c:	b0 91 4d 02 	lds	r27, 0x024D
     260:	b3 83       	std	Z+3, r27	; 0x03
     262:	a2 83       	std	Z+2, r26	; 0x02
		root=root->next;
     264:	8d 91       	ld	r24, X+
     266:	9c 91       	ld	r25, X
     268:	11 97       	sbiw	r26, 0x01	; 1
     26a:	90 93 4d 02 	sts	0x024D, r25
     26e:	80 93 4c 02 	sts	0x024C, r24
		newnode->next=NULL;
     272:	11 82       	std	Z+1, r1	; 0x01
     274:	10 82       	st	Z, r1
	}
	que_length++;			//que_length -> length of the queue
     276:	80 91 57 02 	lds	r24, 0x0257
     27a:	90 91 58 02 	lds	r25, 0x0258
     27e:	01 96       	adiw	r24, 0x01	; 1
     280:	90 93 58 02 	sts	0x0258, r25
     284:	80 93 57 02 	sts	0x0257, r24
}
     288:	df 91       	pop	r29
     28a:	cf 91       	pop	r28
     28c:	1f 91       	pop	r17
     28e:	0f 91       	pop	r16
     290:	08 95       	ret

00000292 <_adc_pinconfig>:
* Example Call:		_adc_pinconfig()
*
*/
void _adc_pinconfig (void)
{
	DDRF = DDRF & 0x01;  //set PORTF direction as input
     292:	80 b3       	in	r24, 0x10	; 16
     294:	81 70       	andi	r24, 0x01	; 1
     296:	80 bb       	out	0x10, r24	; 16
	PORTF = 0x00; //set PORTF pins floating
     298:	11 ba       	out	0x11, r1	; 17
	DDRK = DDRK & 0xC0;  //set PORTK direction as input
     29a:	e7 e0       	ldi	r30, 0x07	; 7
     29c:	f1 e0       	ldi	r31, 0x01	; 1
     29e:	80 81       	ld	r24, Z
     2a0:	80 7c       	andi	r24, 0xC0	; 192
     2a2:	80 83       	st	Z, r24
	PORTK = 0x00; //set PORTK pins floating
     2a4:	10 92 08 01 	sts	0x0108, r1
}
     2a8:	08 95       	ret

000002aa <_adc_init>:
* Example Call:		_adc_init()
*
*/
void _adc_init(void)
{
	ADCSRA = 0x00;
     2aa:	ea e7       	ldi	r30, 0x7A	; 122
     2ac:	f0 e0       	ldi	r31, 0x00	; 0
     2ae:	10 82       	st	Z, r1
	ADCSRB = 0x00;		//MUX5 = 0
     2b0:	10 92 7b 00 	sts	0x007B, r1
	ADMUX = 0x20;		//Vref=5V external --- ADLAR=1(result is left adjusted) --- MUX4:0 = 0000
     2b4:	80 e2       	ldi	r24, 0x20	; 32
     2b6:	80 93 7c 00 	sts	0x007C, r24
	ACSR = 0x80;        //Analog comparator disable to reduce power consumption
     2ba:	80 e8       	ldi	r24, 0x80	; 128
     2bc:	80 bf       	out	0x30, r24	; 48
	ADCSRA = 0x86;		//ADEN=1(ADC enable)  --- ADPS2:0 = 1 1 0
     2be:	86 e8       	ldi	r24, 0x86	; 134
     2c0:	80 83       	st	Z, r24
}
     2c2:	08 95       	ret

000002c4 <_conv_adc>:
*
*/
unsigned char _conv_adc(unsigned char ch)
{
	unsigned char a;     // digital value which stores the digital value of ADCH register
	if(ch>7)
     2c4:	88 30       	cpi	r24, 0x08	; 8
     2c6:	18 f0       	brcs	.+6      	; 0x2ce <_conv_adc+0xa>
	{
		ADCSRB = 0x08;
     2c8:	98 e0       	ldi	r25, 0x08	; 8
     2ca:	90 93 7b 00 	sts	0x007B, r25
	}
	ch = ch & 0x07;			  //Store only 3 LSB bits
     2ce:	87 70       	andi	r24, 0x07	; 7
	ADMUX= 0x20 | ch;		 //Select the ADC channel with left adjust select
     2d0:	80 62       	ori	r24, 0x20	; 32
     2d2:	80 93 7c 00 	sts	0x007C, r24
	ADCSRA = ADCSRA | 0x40;	 //Set start conversion bit
     2d6:	ea e7       	ldi	r30, 0x7A	; 122
     2d8:	f0 e0       	ldi	r31, 0x00	; 0
     2da:	80 81       	ld	r24, Z
     2dc:	80 64       	ori	r24, 0x40	; 64
     2de:	80 83       	st	Z, r24
	while((ADCSRA&0x10)==0); //Wait for ADC conversion to complete
     2e0:	80 81       	ld	r24, Z
     2e2:	84 ff       	sbrs	r24, 4
     2e4:	fd cf       	rjmp	.-6      	; 0x2e0 <_conv_adc+0x1c>
	a=ADCH;
     2e6:	80 91 79 00 	lds	r24, 0x0079
	ADCSRA = ADCSRA|0x10;   //clear ADIF (ADC Interrupt Flag) by writing 1 to it
     2ea:	ea e7       	ldi	r30, 0x7A	; 122
     2ec:	f0 e0       	ldi	r31, 0x00	; 0
     2ee:	90 81       	ld	r25, Z
     2f0:	90 61       	ori	r25, 0x10	; 16
     2f2:	90 83       	st	Z, r25
	ADCSRB = 0x00;
     2f4:	10 92 7b 00 	sts	0x007B, r1
	return a;
}
     2f8:	08 95       	ret

000002fa <converttomm_41sk>:
* Output:           Distance in mm
* Example Call:		converttomm_41sk(_conv_adc(9));
*
*/
unsigned int converttomm_41sk(unsigned int a)//conversion of sharp sensor values.
{
     2fa:	0f 93       	push	r16
     2fc:	1f 93       	push	r17
	double b;
	b=a;
     2fe:	bc 01       	movw	r22, r24
     300:	80 e0       	ldi	r24, 0x00	; 0
     302:	90 e0       	ldi	r25, 0x00	; 0
     304:	0e 94 9c 18 	call	0x3138	; 0x3138 <__floatunsisf>
	b = b*0.001240875;
     308:	46 2f       	mov	r20, r22
     30a:	57 2f       	mov	r21, r23
     30c:	68 2f       	mov	r22, r24
     30e:	79 2f       	mov	r23, r25
     310:	cb 01       	movw	r24, r22
     312:	ba 01       	movw	r22, r20
     314:	2b ed       	ldi	r18, 0xDB	; 219
     316:	34 ea       	ldi	r19, 0xA4	; 164
     318:	42 ea       	ldi	r20, 0xA2	; 162
     31a:	5a e3       	ldi	r21, 0x3A	; 58
     31c:	0e 94 8e 19 	call	0x331c	; 0x331c <__mulsf3>
	b = b+0.005;
     320:	46 2f       	mov	r20, r22
     322:	57 2f       	mov	r21, r23
     324:	68 2f       	mov	r22, r24
     326:	79 2f       	mov	r23, r25
     328:	cb 01       	movw	r24, r22
     32a:	ba 01       	movw	r22, r20
     32c:	2a e0       	ldi	r18, 0x0A	; 10
     32e:	37 ed       	ldi	r19, 0xD7	; 215
     330:	43 ea       	ldi	r20, 0xA3	; 163
     332:	5b e3       	ldi	r21, 0x3B	; 59
     334:	0e 94 88 17 	call	0x2f10	; 0x2f10 <__addsf3>
     338:	b6 2f       	mov	r27, r22
     33a:	a7 2f       	mov	r26, r23
     33c:	38 2f       	mov	r19, r24
     33e:	29 2f       	mov	r18, r25
	b = 10/b;
     340:	60 e0       	ldi	r22, 0x00	; 0
     342:	70 e0       	ldi	r23, 0x00	; 0
     344:	80 e2       	ldi	r24, 0x20	; 32
     346:	91 e4       	ldi	r25, 0x41	; 65
     348:	42 2f       	mov	r20, r18
     34a:	0b 2f       	mov	r16, r27
     34c:	1a 2f       	mov	r17, r26
     34e:	23 2f       	mov	r18, r19
     350:	34 2f       	mov	r19, r20
     352:	a9 01       	movw	r20, r18
     354:	98 01       	movw	r18, r16
     356:	0e 94 03 18 	call	0x3006	; 0x3006 <__divsf3>
	b = b-24.2;
     35a:	46 2f       	mov	r20, r22
     35c:	57 2f       	mov	r21, r23
     35e:	68 2f       	mov	r22, r24
     360:	79 2f       	mov	r23, r25
     362:	cb 01       	movw	r24, r22
     364:	ba 01       	movw	r22, r20
     366:	2a e9       	ldi	r18, 0x9A	; 154
     368:	39 e9       	ldi	r19, 0x99	; 153
     36a:	41 ec       	ldi	r20, 0xC1	; 193
     36c:	51 e4       	ldi	r21, 0x41	; 65
     36e:	0e 94 87 17 	call	0x2f0e	; 0x2f0e <__subsf3>
	b = (int)b;
     372:	0e 94 6b 18 	call	0x30d6	; 0x30d6 <__fixsfsi>
     376:	88 27       	eor	r24, r24
     378:	77 fd       	sbrc	r23, 7
     37a:	80 95       	com	r24
     37c:	98 2f       	mov	r25, r24
     37e:	0e 94 9e 18 	call	0x313c	; 0x313c <__floatsisf>
	return b;
     382:	0e 94 70 18 	call	0x30e0	; 0x30e0 <__fixunssfsi>
}
     386:	86 2f       	mov	r24, r22
     388:	97 2f       	mov	r25, r23
     38a:	1f 91       	pop	r17
     38c:	0f 91       	pop	r16
     38e:	08 95       	ret

00000390 <_timer4_init>:
* Example Call:		NONE
*
*/
void _timer4_init(void)
{
	TCCR4B = 0x00; //stop
     390:	e1 ea       	ldi	r30, 0xA1	; 161
     392:	f0 e0       	ldi	r31, 0x00	; 0
     394:	10 82       	st	Z, r1
	OCR4AH = 0x00; //Output Compare Register (OCR)- Not used
     396:	10 92 a9 00 	sts	0x00A9, r1
	OCR4AL = 0x00; //Output compare Register (OCR)- Not used
     39a:	10 92 a8 00 	sts	0x00A8, r1
	OCR4BH = 0x00; //Output compare Register (OCR)- Not used
     39e:	10 92 ab 00 	sts	0x00AB, r1
	OCR4BL = 0x00; //Output compare Register (OCR)- Not used
     3a2:	10 92 aa 00 	sts	0x00AA, r1
	OCR4CH = 0x00; //Output compare Register (OCR)- Not used
     3a6:	10 92 ad 00 	sts	0x00AD, r1
	OCR4CL = 0x00; //Output compare Register (OCR)- Not used
     3aa:	10 92 ac 00 	sts	0x00AC, r1
	ICR4   = 0x7080; //Input Capture Register (ICR)  
     3ae:	80 e8       	ldi	r24, 0x80	; 128
     3b0:	90 e7       	ldi	r25, 0x70	; 112
     3b2:	90 93 a7 00 	sts	0x00A7, r25
     3b6:	80 93 a6 00 	sts	0x00A6, r24
	TCCR4C = 0x00;
     3ba:	10 92 a2 00 	sts	0x00A2, r1
	TCCR4A = 0b00000010;// Normal port operation........WGM41:40=1 0
     3be:	82 e0       	ldi	r24, 0x02	; 2
     3c0:	80 93 a0 00 	sts	0x00A0, r24
	TCCR4B = 0b00011100; //start Timer.......WGM43:42=1 1........CS42:40=1 0 0(clkI/O/256 (From prescaler)) 
     3c4:	8c e1       	ldi	r24, 0x1C	; 28
     3c6:	80 83       	st	Z, r24
}
     3c8:	08 95       	ret

000003ca <send>:

void send ( int n)
{
	int z = 0;
	int c = n;
	a[0] = 0;
     3ca:	10 92 58 05 	sts	0x0558, r1
	a[1] = 0;
     3ce:	10 92 59 05 	sts	0x0559, r1
	a[2] = 0;
     3d2:	10 92 5a 05 	sts	0x055A, r1
	while (c)
     3d6:	00 97       	sbiw	r24, 0x00	; 0
     3d8:	61 f0       	breq	.+24     	; 0x3f2 <send+0x28>
     3da:	e8 e5       	ldi	r30, 0x58	; 88
     3dc:	f5 e0       	ldi	r31, 0x05	; 5
	{ // loop till there's nothing left
		a[z++] = (char)(c % 10); // assign the last digit
     3de:	2a e0       	ldi	r18, 0x0A	; 10
     3e0:	30 e0       	ldi	r19, 0x00	; 0
     3e2:	b9 01       	movw	r22, r18
     3e4:	0e 94 5c 1b 	call	0x36b8	; 0x36b8 <__divmodhi4>
     3e8:	81 93       	st	Z+, r24
		c /= 10; // "right shift" the number
     3ea:	86 2f       	mov	r24, r22
     3ec:	97 2f       	mov	r25, r23
	int z = 0;
	int c = n;
	a[0] = 0;
	a[1] = 0;
	a[2] = 0;
	while (c)
     3ee:	00 97       	sbiw	r24, 0x00	; 0
     3f0:	c1 f7       	brne	.-16     	; 0x3e2 <send+0x18>
	{ // loop till there's nothing left
		a[z++] = (char)(c % 10); // assign the last digit
		c /= 10; // "right shift" the number
	}
	
	UDR0 = a[2] + 48;   //sending the first digit
     3f2:	80 91 5a 05 	lds	r24, 0x055A
     3f6:	80 5d       	subi	r24, 0xD0	; 208
     3f8:	80 93 c6 00 	sts	0x00C6, r24
	while(!(UCSR0A & (1<<UDRE0)))   
     3fc:	e0 ec       	ldi	r30, 0xC0	; 192
     3fe:	f0 e0       	ldi	r31, 0x00	; 0
     400:	80 81       	ld	r24, Z
     402:	85 ff       	sbrs	r24, 5
     404:	fd cf       	rjmp	.-6      	; 0x400 <send+0x36>
	{
		//waiting for transmission to complete
	}
	UDR0 = a[1] + 48; //sending the second digit
     406:	80 91 59 05 	lds	r24, 0x0559
     40a:	80 5d       	subi	r24, 0xD0	; 208
     40c:	80 93 c6 00 	sts	0x00C6, r24
	while(!(UCSR0A & (1<<UDRE0)))
     410:	e0 ec       	ldi	r30, 0xC0	; 192
     412:	f0 e0       	ldi	r31, 0x00	; 0
     414:	80 81       	ld	r24, Z
     416:	85 ff       	sbrs	r24, 5
     418:	fd cf       	rjmp	.-6      	; 0x414 <send+0x4a>
	{
		//waiting for transmission to complete
	}
	UDR0 = a[0] + 48; //sending the third digit
     41a:	80 91 58 05 	lds	r24, 0x0558
     41e:	80 5d       	subi	r24, 0xD0	; 208
     420:	80 93 c6 00 	sts	0x00C6, r24
	while(!(UCSR0A & (1<<UDRE0)))
     424:	e0 ec       	ldi	r30, 0xC0	; 192
     426:	f0 e0       	ldi	r31, 0x00	; 0
     428:	80 81       	ld	r24, Z
     42a:	85 ff       	sbrs	r24, 5
     42c:	fd cf       	rjmp	.-6      	; 0x428 <send+0x5e>
	{
		//waiting for transmission to complete
	}
	UDR0 = 32;      //to give space between two integer
     42e:	80 e2       	ldi	r24, 0x20	; 32
     430:	80 93 c6 00 	sts	0x00C6, r24
	while(!(UCSR0A & (1<<UDRE0)))
     434:	e0 ec       	ldi	r30, 0xC0	; 192
     436:	f0 e0       	ldi	r31, 0x00	; 0
     438:	80 81       	ld	r24, Z
     43a:	85 ff       	sbrs	r24, 5
     43c:	fd cf       	rjmp	.-6      	; 0x438 <send+0x6e>
	{
		//waiting for transmission to complete
	}
}
     43e:	08 95       	ret

00000440 <getdigital>:
*
*/

void getdigital(void)
{
	 lwl= _conv_adc(3);  	//Getting data of Left WL Sensor
     440:	83 e0       	ldi	r24, 0x03	; 3
     442:	0e 94 62 01 	call	0x2c4	; 0x2c4 <_conv_adc>
     446:	80 93 6c 02 	sts	0x026C, r24
	 cwl = _conv_adc(2);	//Getting data of Center WL Sensor
     44a:	82 e0       	ldi	r24, 0x02	; 2
     44c:	0e 94 62 01 	call	0x2c4	; 0x2c4 <_conv_adc>
     450:	80 93 6b 02 	sts	0x026B, r24
	 rwl = _conv_adc(1);	//Getting data of Right WL Sensor
     454:	81 e0       	ldi	r24, 0x01	; 1
     456:	0e 94 62 01 	call	0x2c4	; 0x2c4 <_conv_adc>
     45a:	80 93 6a 02 	sts	0x026A, r24
	 sp1 = _conv_adc(9);     //Getting data of sharp sensor1.
     45e:	89 e0       	ldi	r24, 0x09	; 9
     460:	0e 94 62 01 	call	0x2c4	; 0x2c4 <_conv_adc>
     464:	80 93 b6 02 	sts	0x02B6, r24
	 sp2 = _conv_adc(10);    //Getting data of sharp sensor2.
     468:	8a e0       	ldi	r24, 0x0A	; 10
     46a:	0e 94 62 01 	call	0x2c4	; 0x2c4 <_conv_adc>
     46e:	80 93 bb 02 	sts	0x02BB, r24
	 sp3 = _conv_adc(11);    //Getting data of sharp sensor3.
     472:	8b e0       	ldi	r24, 0x0B	; 11
     474:	0e 94 62 01 	call	0x2c4	; 0x2c4 <_conv_adc>
     478:	80 93 32 05 	sts	0x0532, r24
	 sp4 = _conv_adc(12);    //Getting data of sharp sensor4.
     47c:	8c e0       	ldi	r24, 0x0C	; 12
     47e:	0e 94 62 01 	call	0x2c4	; 0x2c4 <_conv_adc>
     482:	80 93 5d 05 	sts	0x055D, r24
	 IR1 = _conv_adc(4);     //Getting value of IR proximity sensor1.
     486:	84 e0       	ldi	r24, 0x04	; 4
     488:	0e 94 62 01 	call	0x2c4	; 0x2c4 <_conv_adc>
     48c:	80 93 2d 05 	sts	0x052D, r24
	 IR2 = _conv_adc(5);     //Getting value of IR proximity sensor2.
     490:	85 e0       	ldi	r24, 0x05	; 5
     492:	0e 94 62 01 	call	0x2c4	; 0x2c4 <_conv_adc>
     496:	80 93 aa 02 	sts	0x02AA, r24
	 IR3 = _conv_adc(6);     //Getting value of IR proximity sensor3.
     49a:	86 e0       	ldi	r24, 0x06	; 6
     49c:	0e 94 62 01 	call	0x2c4	; 0x2c4 <_conv_adc>
     4a0:	80 93 af 02 	sts	0x02AF, r24
	 IR4 = _conv_adc(7);     //Getting value of IR proximity sensor4.
     4a4:	87 e0       	ldi	r24, 0x07	; 7
     4a6:	0e 94 62 01 	call	0x2c4	; 0x2c4 <_conv_adc>
     4aa:	80 93 69 02 	sts	0x0269, r24
	 
	
}
     4ae:	08 95       	ret

000004b0 <__vector_45>:
* Logic:			               Timer 4 is configured as such that it gets overflow in  every 0.5 seconds so 
                                   that the sensor readings & wheel velocity are updated and sent continuously.
* Example Call:		               NONE
*/
ISR(TIMER4_OVF_vect)
{
     4b0:	1f 92       	push	r1
     4b2:	0f 92       	push	r0
     4b4:	0f b6       	in	r0, 0x3f	; 63
     4b6:	0f 92       	push	r0
     4b8:	0b b6       	in	r0, 0x3b	; 59
     4ba:	0f 92       	push	r0
     4bc:	11 24       	eor	r1, r1
     4be:	2f 93       	push	r18
     4c0:	3f 93       	push	r19
     4c2:	4f 93       	push	r20
     4c4:	5f 93       	push	r21
     4c6:	6f 93       	push	r22
     4c8:	7f 93       	push	r23
     4ca:	8f 93       	push	r24
     4cc:	9f 93       	push	r25
     4ce:	af 93       	push	r26
     4d0:	bf 93       	push	r27
     4d2:	ef 93       	push	r30
     4d4:	ff 93       	push	r31
	     cli();                 //Clears the global interrupt
     4d6:	f8 94       	cli
		getdigital();           //stores digital value of sensors in different variables.
     4d8:	0e 94 20 02 	call	0x440	; 0x440 <getdigital>
		//sensor_data_interpretation();
		send(count);
     4dc:	80 91 6d 02 	lds	r24, 0x026D
     4e0:	90 91 6e 02 	lds	r25, 0x026E
     4e4:	0e 94 e5 01 	call	0x3ca	; 0x3ca <send>
		send(lwl);                  //send the value of left white line sensor
     4e8:	80 91 6c 02 	lds	r24, 0x026C
     4ec:	90 e0       	ldi	r25, 0x00	; 0
     4ee:	0e 94 e5 01 	call	0x3ca	; 0x3ca <send>
		send(cwl);                  //send the value of center white line sensor
     4f2:	80 91 6b 02 	lds	r24, 0x026B
     4f6:	90 e0       	ldi	r25, 0x00	; 0
     4f8:	0e 94 e5 01 	call	0x3ca	; 0x3ca <send>
		send(rwl);                  //send the value of right white line sensor
     4fc:	80 91 6a 02 	lds	r24, 0x026A
     500:	90 e0       	ldi	r25, 0x00	; 0
     502:	0e 94 e5 01 	call	0x3ca	; 0x3ca <send>
		send(converttomm_41sk(sp1));//send the value of sharp sensor 1
     506:	80 91 b6 02 	lds	r24, 0x02B6
     50a:	90 e0       	ldi	r25, 0x00	; 0
     50c:	0e 94 7d 01 	call	0x2fa	; 0x2fa <converttomm_41sk>
     510:	0e 94 e5 01 	call	0x3ca	; 0x3ca <send>
		send(converttomm_41sk(sp2));//send the value of sharp sensor 2
     514:	80 91 bb 02 	lds	r24, 0x02BB
     518:	90 e0       	ldi	r25, 0x00	; 0
     51a:	0e 94 7d 01 	call	0x2fa	; 0x2fa <converttomm_41sk>
     51e:	0e 94 e5 01 	call	0x3ca	; 0x3ca <send>
		send(converttomm_41sk(sp3));//send the value of sharp sensor 3 
     522:	80 91 32 05 	lds	r24, 0x0532
     526:	90 e0       	ldi	r25, 0x00	; 0
     528:	0e 94 7d 01 	call	0x2fa	; 0x2fa <converttomm_41sk>
     52c:	0e 94 e5 01 	call	0x3ca	; 0x3ca <send>
		send(converttomm_41sk(sp4));//send the value of sharp sensor 4
     530:	80 91 5d 05 	lds	r24, 0x055D
     534:	90 e0       	ldi	r25, 0x00	; 0
     536:	0e 94 7d 01 	call	0x2fa	; 0x2fa <converttomm_41sk>
     53a:	0e 94 e5 01 	call	0x3ca	; 0x3ca <send>
		send(IR1);                  //send the value of proximity sensor1
     53e:	80 91 2d 05 	lds	r24, 0x052D
     542:	90 e0       	ldi	r25, 0x00	; 0
     544:	0e 94 e5 01 	call	0x3ca	; 0x3ca <send>
		send(IR2);                  //send the value of proximity sensor2
     548:	80 91 aa 02 	lds	r24, 0x02AA
     54c:	90 e0       	ldi	r25, 0x00	; 0
     54e:	0e 94 e5 01 	call	0x3ca	; 0x3ca <send>
        send(IR3);                  //send the value of proximity sensor3
     552:	80 91 af 02 	lds	r24, 0x02AF
     556:	90 e0       	ldi	r25, 0x00	; 0
     558:	0e 94 e5 01 	call	0x3ca	; 0x3ca <send>
		send(IR4);                  //send the value of proximity sensor4
     55c:	80 91 69 02 	lds	r24, 0x0269
     560:	90 e0       	ldi	r25, 0x00	; 0
     562:	0e 94 e5 01 	call	0x3ca	; 0x3ca <send>

		
		count++;                      //increase the value of count
     566:	80 91 6d 02 	lds	r24, 0x026D
     56a:	90 91 6e 02 	lds	r25, 0x026E
     56e:	01 96       	adiw	r24, 0x01	; 1
     570:	90 93 6e 02 	sts	0x026E, r25
     574:	80 93 6d 02 	sts	0x026D, r24
		sei();                        //enables the global interrupt      
     578:	78 94       	sei
}
     57a:	ff 91       	pop	r31
     57c:	ef 91       	pop	r30
     57e:	bf 91       	pop	r27
     580:	af 91       	pop	r26
     582:	9f 91       	pop	r25
     584:	8f 91       	pop	r24
     586:	7f 91       	pop	r23
     588:	6f 91       	pop	r22
     58a:	5f 91       	pop	r21
     58c:	4f 91       	pop	r20
     58e:	3f 91       	pop	r19
     590:	2f 91       	pop	r18
     592:	0f 90       	pop	r0
     594:	0b be       	out	0x3b, r0	; 59
     596:	0f 90       	pop	r0
     598:	0f be       	out	0x3f, r0	; 63
     59a:	0f 90       	pop	r0
     59c:	1f 90       	pop	r1
     59e:	18 95       	reti

000005a0 <_uart0_init>:
* Example Call:		               NONE
*/

void _uart0_init(void)
{
	UCSR0B = 0x00; //disable while setting baud rate
     5a0:	e1 ec       	ldi	r30, 0xC1	; 193
     5a2:	f0 e0       	ldi	r31, 0x00	; 0
     5a4:	10 82       	st	Z, r1
	UCSR0A = 0x00;
     5a6:	10 92 c0 00 	sts	0x00C0, r1
	UCSR0C = 0x06;//asynchronous usart..........character size:8-bit
     5aa:	86 e0       	ldi	r24, 0x06	; 6
     5ac:	80 93 c2 00 	sts	0x00C2, r24
	//baud rate setting;9600
	UBRR0L = 0x5F; //set baud rate lo
     5b0:	8f e5       	ldi	r24, 0x5F	; 95
     5b2:	80 93 c4 00 	sts	0x00C4, r24
	UBRR0H = 0x00; //set baud rate hi
     5b6:	10 92 c5 00 	sts	0x00C5, r1
	UCSR0B = 0x98;
     5ba:	88 e9       	ldi	r24, 0x98	; 152
     5bc:	80 83       	st	Z, r24
}
     5be:	08 95       	ret

000005c0 <_port_init>:
* Example Call:		               _port_init();
*/
void _port_init()
{

	_adc_pinconfig();
     5c0:	0e 94 49 01 	call	0x292	; 0x292 <_adc_pinconfig>
}	
     5c4:	08 95       	ret

000005c6 <_init_devices>:
	* Logic :            NONE
	* Example Call:		 velocity_leftwheel_cmpersec();
	*/
void _init_devices()
{
	cli();         //Clears the global interrupt
     5c6:	f8 94       	cli
	_port_init();  //Initializes all the ports
     5c8:	0e 94 e0 02 	call	0x5c0	; 0x5c0 <_port_init>
	_timer4_init();
     5cc:	0e 94 c8 01 	call	0x390	; 0x390 <_timer4_init>
	_adc_init();
     5d0:	0e 94 55 01 	call	0x2aa	; 0x2aa <_adc_init>
	_uart0_init(); //Initialize UART0 for wireless serial communication
     5d4:	0e 94 d0 02 	call	0x5a0	; 0x5a0 <_uart0_init>
	TIMSK4 = 0x01; //Timer/Counter 4 Overflow interrupt is enabled
     5d8:	81 e0       	ldi	r24, 0x01	; 1
     5da:	80 93 72 00 	sts	0x0072, r24
	sei();         // Enables the global interrupt
     5de:	78 94       	sei
}
     5e0:	08 95       	ret

000005e2 <lcd_set_4bit>:
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     5e2:	86 e6       	ldi	r24, 0x66	; 102
     5e4:	9e e0       	ldi	r25, 0x0E	; 14
     5e6:	01 97       	sbiw	r24, 0x01	; 1
     5e8:	f1 f7       	brne	.-4      	; 0x5e6 <lcd_set_4bit+0x4>
     5ea:	00 00       	nop
//Function to Reset LCD
void lcd_set_4bit()
{
	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
     5ec:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
     5ee:	41 98       	cbi	0x08, 1	; 8
	lcd_port = 0x30;				//Sending 3
     5f0:	80 e3       	ldi	r24, 0x30	; 48
     5f2:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,EN);				//Set Enable Pin
     5f4:	42 9a       	sbi	0x08, 2	; 8
     5f6:	ef ef       	ldi	r30, 0xFF	; 255
     5f8:	f7 e4       	ldi	r31, 0x47	; 71
     5fa:	31 97       	sbiw	r30, 0x01	; 1
     5fc:	f1 f7       	brne	.-4      	; 0x5fa <lcd_set_4bit+0x18>
     5fe:	00 c0       	rjmp	.+0      	; 0x600 <lcd_set_4bit+0x1e>
     600:	00 00       	nop
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
     602:	42 98       	cbi	0x08, 2	; 8
     604:	e6 e6       	ldi	r30, 0x66	; 102
     606:	fe e0       	ldi	r31, 0x0E	; 14
     608:	31 97       	sbiw	r30, 0x01	; 1
     60a:	f1 f7       	brne	.-4      	; 0x608 <lcd_set_4bit+0x26>
     60c:	00 00       	nop

	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
     60e:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
     610:	41 98       	cbi	0x08, 1	; 8
	lcd_port = 0x30;				//Sending 3
     612:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,EN);				//Set Enable Pin
     614:	42 9a       	sbi	0x08, 2	; 8
     616:	ef ef       	ldi	r30, 0xFF	; 255
     618:	f7 e4       	ldi	r31, 0x47	; 71
     61a:	31 97       	sbiw	r30, 0x01	; 1
     61c:	f1 f7       	brne	.-4      	; 0x61a <lcd_set_4bit+0x38>
     61e:	00 c0       	rjmp	.+0      	; 0x620 <lcd_set_4bit+0x3e>
     620:	00 00       	nop
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
     622:	42 98       	cbi	0x08, 2	; 8
     624:	e6 e6       	ldi	r30, 0x66	; 102
     626:	fe e0       	ldi	r31, 0x0E	; 14
     628:	31 97       	sbiw	r30, 0x01	; 1
     62a:	f1 f7       	brne	.-4      	; 0x628 <lcd_set_4bit+0x46>
     62c:	00 00       	nop

	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
     62e:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
     630:	41 98       	cbi	0x08, 1	; 8
	lcd_port = 0x30;				//Sending 3
     632:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,EN);				//Set Enable Pin
     634:	42 9a       	sbi	0x08, 2	; 8
     636:	8f ef       	ldi	r24, 0xFF	; 255
     638:	97 e4       	ldi	r25, 0x47	; 71
     63a:	01 97       	sbiw	r24, 0x01	; 1
     63c:	f1 f7       	brne	.-4      	; 0x63a <lcd_set_4bit+0x58>
     63e:	00 c0       	rjmp	.+0      	; 0x640 <lcd_set_4bit+0x5e>
     640:	00 00       	nop
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
     642:	42 98       	cbi	0x08, 2	; 8
     644:	e6 e6       	ldi	r30, 0x66	; 102
     646:	fe e0       	ldi	r31, 0x0E	; 14
     648:	31 97       	sbiw	r30, 0x01	; 1
     64a:	f1 f7       	brne	.-4      	; 0x648 <lcd_set_4bit+0x66>
     64c:	00 00       	nop

	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
     64e:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
     650:	41 98       	cbi	0x08, 1	; 8
	lcd_port = 0x20;				//Sending 2 to initialise LCD 4-bit mode
     652:	80 e2       	ldi	r24, 0x20	; 32
     654:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,EN);				//Set Enable Pin
     656:	42 9a       	sbi	0x08, 2	; 8
     658:	8f ef       	ldi	r24, 0xFF	; 255
     65a:	97 e4       	ldi	r25, 0x47	; 71
     65c:	01 97       	sbiw	r24, 0x01	; 1
     65e:	f1 f7       	brne	.-4      	; 0x65c <lcd_set_4bit+0x7a>
     660:	00 c0       	rjmp	.+0      	; 0x662 <lcd_set_4bit+0x80>
     662:	00 00       	nop
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
     664:	42 98       	cbi	0x08, 2	; 8

	
}
     666:	08 95       	ret

00000668 <lcd_wr_command>:
void lcd_wr_command(unsigned char cmd)
{
	unsigned char temp;
	temp = cmd;
	temp = temp & 0xF0;
	lcd_port &= 0x0F;
     668:	98 b1       	in	r25, 0x08	; 8
     66a:	9f 70       	andi	r25, 0x0F	; 15
     66c:	98 b9       	out	0x08, r25	; 8
	lcd_port |= temp;
     66e:	98 b1       	in	r25, 0x08	; 8
//Function to Write Command on LCD
void lcd_wr_command(unsigned char cmd)
{
	unsigned char temp;
	temp = cmd;
	temp = temp & 0xF0;
     670:	28 2f       	mov	r18, r24
     672:	20 7f       	andi	r18, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= temp;
     674:	92 2b       	or	r25, r18
     676:	98 b9       	out	0x08, r25	; 8
	cbit(lcd_port,RS);
     678:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);
     67a:	41 98       	cbi	0x08, 1	; 8
	sbit(lcd_port,EN);
     67c:	42 9a       	sbi	0x08, 2	; 8
     67e:	ef ef       	ldi	r30, 0xFF	; 255
     680:	f7 e4       	ldi	r31, 0x47	; 71
     682:	31 97       	sbiw	r30, 0x01	; 1
     684:	f1 f7       	brne	.-4      	; 0x682 <lcd_wr_command+0x1a>
     686:	00 c0       	rjmp	.+0      	; 0x688 <lcd_wr_command+0x20>
     688:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
     68a:	42 98       	cbi	0x08, 2	; 8
	
	cmd = cmd & 0x0F;
	cmd = cmd<<4;
	lcd_port &= 0x0F;
     68c:	98 b1       	in	r25, 0x08	; 8
     68e:	9f 70       	andi	r25, 0x0F	; 15
     690:	98 b9       	out	0x08, r25	; 8
	lcd_port |= cmd;
     692:	98 b1       	in	r25, 0x08	; 8
	sbit(lcd_port,EN);
	_delay_ms(5);
	cbit(lcd_port,EN);
	
	cmd = cmd & 0x0F;
	cmd = cmd<<4;
     694:	82 95       	swap	r24
     696:	80 7f       	andi	r24, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= cmd;
     698:	89 2b       	or	r24, r25
     69a:	88 b9       	out	0x08, r24	; 8
	cbit(lcd_port,RS);
     69c:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);
     69e:	41 98       	cbi	0x08, 1	; 8
	sbit(lcd_port,EN);
     6a0:	42 9a       	sbi	0x08, 2	; 8
     6a2:	8f ef       	ldi	r24, 0xFF	; 255
     6a4:	97 e4       	ldi	r25, 0x47	; 71
     6a6:	01 97       	sbiw	r24, 0x01	; 1
     6a8:	f1 f7       	brne	.-4      	; 0x6a6 <lcd_wr_command+0x3e>
     6aa:	00 c0       	rjmp	.+0      	; 0x6ac <lcd_wr_command+0x44>
     6ac:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
     6ae:	42 98       	cbi	0x08, 2	; 8
}
     6b0:	08 95       	ret

000006b2 <lcd_init>:
}

//Function to Initialize LCD
void lcd_init()
{
	lcd_set_4bit();
     6b2:	0e 94 f1 02 	call	0x5e2	; 0x5e2 <lcd_set_4bit>
     6b6:	86 e6       	ldi	r24, 0x66	; 102
     6b8:	9e e0       	ldi	r25, 0x0E	; 14
     6ba:	01 97       	sbiw	r24, 0x01	; 1
     6bc:	f1 f7       	brne	.-4      	; 0x6ba <lcd_init+0x8>
     6be:	00 00       	nop
	_delay_ms(1);

	lcd_wr_command(0x28);			//LCD 4-bit mode and 2 lines.
     6c0:	88 e2       	ldi	r24, 0x28	; 40
     6c2:	0e 94 34 03 	call	0x668	; 0x668 <lcd_wr_command>
	lcd_wr_command(0x01);
     6c6:	81 e0       	ldi	r24, 0x01	; 1
     6c8:	0e 94 34 03 	call	0x668	; 0x668 <lcd_wr_command>
	lcd_wr_command(0x06);
     6cc:	86 e0       	ldi	r24, 0x06	; 6
     6ce:	0e 94 34 03 	call	0x668	; 0x668 <lcd_wr_command>
	lcd_wr_command(0x0E);
     6d2:	8e e0       	ldi	r24, 0x0E	; 14
     6d4:	0e 94 34 03 	call	0x668	; 0x668 <lcd_wr_command>
	lcd_wr_command(0x80);
     6d8:	80 e8       	ldi	r24, 0x80	; 128
     6da:	0e 94 34 03 	call	0x668	; 0x668 <lcd_wr_command>
		
}
     6de:	08 95       	ret

000006e0 <lcd_wr_char>:
void lcd_wr_char(char letter)
{
	char temp;
	temp = letter;
	temp = (temp & 0xF0);
	lcd_port &= 0x0F;
     6e0:	98 b1       	in	r25, 0x08	; 8
     6e2:	9f 70       	andi	r25, 0x0F	; 15
     6e4:	98 b9       	out	0x08, r25	; 8
	lcd_port |= temp;
     6e6:	98 b1       	in	r25, 0x08	; 8
//Function to Write Data on LCD
void lcd_wr_char(char letter)
{
	char temp;
	temp = letter;
	temp = (temp & 0xF0);
     6e8:	28 2f       	mov	r18, r24
     6ea:	20 7f       	andi	r18, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= temp;
     6ec:	92 2b       	or	r25, r18
     6ee:	98 b9       	out	0x08, r25	; 8
	sbit(lcd_port,RS);
     6f0:	40 9a       	sbi	0x08, 0	; 8
	cbit(lcd_port,RW);
     6f2:	41 98       	cbi	0x08, 1	; 8
	sbit(lcd_port,EN);
     6f4:	42 9a       	sbi	0x08, 2	; 8
     6f6:	ef ef       	ldi	r30, 0xFF	; 255
     6f8:	f7 e4       	ldi	r31, 0x47	; 71
     6fa:	31 97       	sbiw	r30, 0x01	; 1
     6fc:	f1 f7       	brne	.-4      	; 0x6fa <lcd_wr_char+0x1a>
     6fe:	00 c0       	rjmp	.+0      	; 0x700 <lcd_wr_char+0x20>
     700:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
     702:	42 98       	cbi	0x08, 2	; 8

	letter = letter & 0x0F;
	letter = letter<<4;
	lcd_port &= 0x0F;
     704:	98 b1       	in	r25, 0x08	; 8
     706:	9f 70       	andi	r25, 0x0F	; 15
     708:	98 b9       	out	0x08, r25	; 8
	lcd_port |= letter;
     70a:	98 b1       	in	r25, 0x08	; 8
	sbit(lcd_port,EN);
	_delay_ms(5);
	cbit(lcd_port,EN);

	letter = letter & 0x0F;
	letter = letter<<4;
     70c:	82 95       	swap	r24
     70e:	80 7f       	andi	r24, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= letter;
     710:	89 2b       	or	r24, r25
     712:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,RS);
     714:	40 9a       	sbi	0x08, 0	; 8
	cbit(lcd_port,RW);
     716:	41 98       	cbi	0x08, 1	; 8
	sbit(lcd_port,EN);
     718:	42 9a       	sbi	0x08, 2	; 8
     71a:	8f ef       	ldi	r24, 0xFF	; 255
     71c:	97 e4       	ldi	r25, 0x47	; 71
     71e:	01 97       	sbiw	r24, 0x01	; 1
     720:	f1 f7       	brne	.-4      	; 0x71e <lcd_wr_char+0x3e>
     722:	00 c0       	rjmp	.+0      	; 0x724 <lcd_wr_char+0x44>
     724:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
     726:	42 98       	cbi	0x08, 2	; 8
}
     728:	08 95       	ret

0000072a <lcd_home>:


//Function to bring cursor at home position
void lcd_home()
{
	lcd_wr_command(0x80);
     72a:	80 e8       	ldi	r24, 0x80	; 128
     72c:	0e 94 34 03 	call	0x668	; 0x668 <lcd_wr_command>
}
     730:	08 95       	ret

00000732 <lcd_string>:


//Function to Print String on LCD
void lcd_string(char *str)
{
     732:	cf 93       	push	r28
     734:	df 93       	push	r29
     736:	ec 01       	movw	r28, r24
	while(*str != '\0')
     738:	88 81       	ld	r24, Y
     73a:	88 23       	and	r24, r24
     73c:	31 f0       	breq	.+12     	; 0x74a <lcd_string+0x18>
	lcd_wr_command(0x80);
}


//Function to Print String on LCD
void lcd_string(char *str)
     73e:	21 96       	adiw	r28, 0x01	; 1
{
	while(*str != '\0')
	{
		lcd_wr_char(*str);
     740:	0e 94 70 03 	call	0x6e0	; 0x6e0 <lcd_wr_char>


//Function to Print String on LCD
void lcd_string(char *str)
{
	while(*str != '\0')
     744:	89 91       	ld	r24, Y+
     746:	88 23       	and	r24, r24
     748:	d9 f7       	brne	.-10     	; 0x740 <lcd_string+0xe>
	{
		lcd_wr_char(*str);
		str++;
	}
}
     74a:	df 91       	pop	r29
     74c:	cf 91       	pop	r28
     74e:	08 95       	ret

00000750 <lcd_cursor>:

//Position the LCD cursor at "row", "column".

void lcd_cursor (char row, char column)
{
	switch (row) {
     750:	82 30       	cpi	r24, 0x02	; 2
     752:	79 f0       	breq	.+30     	; 0x772 <lcd_cursor+0x22>
     754:	83 30       	cpi	r24, 0x03	; 3
     756:	18 f4       	brcc	.+6      	; 0x75e <lcd_cursor+0xe>
     758:	81 30       	cpi	r24, 0x01	; 1
     75a:	c9 f4       	brne	.+50     	; 0x78e <lcd_cursor+0x3e>
     75c:	05 c0       	rjmp	.+10     	; 0x768 <lcd_cursor+0x18>
     75e:	83 30       	cpi	r24, 0x03	; 3
     760:	69 f0       	breq	.+26     	; 0x77c <lcd_cursor+0x2c>
     762:	84 30       	cpi	r24, 0x04	; 4
     764:	a1 f4       	brne	.+40     	; 0x78e <lcd_cursor+0x3e>
     766:	0f c0       	rjmp	.+30     	; 0x786 <lcd_cursor+0x36>
		case 1: lcd_wr_command (0x80 + column - 1); break;
     768:	86 2f       	mov	r24, r22
     76a:	81 58       	subi	r24, 0x81	; 129
     76c:	0e 94 34 03 	call	0x668	; 0x668 <lcd_wr_command>
     770:	08 95       	ret
		case 2: lcd_wr_command (0xc0 + column - 1); break;
     772:	86 2f       	mov	r24, r22
     774:	81 54       	subi	r24, 0x41	; 65
     776:	0e 94 34 03 	call	0x668	; 0x668 <lcd_wr_command>
     77a:	08 95       	ret
		case 3: lcd_wr_command (0x94 + column - 1); break;
     77c:	86 2f       	mov	r24, r22
     77e:	8d 56       	subi	r24, 0x6D	; 109
     780:	0e 94 34 03 	call	0x668	; 0x668 <lcd_wr_command>
     784:	08 95       	ret
		case 4: lcd_wr_command (0xd4 + column - 1); break;
     786:	86 2f       	mov	r24, r22
     788:	8d 52       	subi	r24, 0x2D	; 45
     78a:	0e 94 34 03 	call	0x668	; 0x668 <lcd_wr_command>
     78e:	08 95       	ret

00000790 <lcd_print>:
	}
}

//Function To Print Any input value upto the desired digit on LCD
void lcd_print (char row, char coloumn, unsigned int value, int digits)
{
     790:	0f 93       	push	r16
     792:	1f 93       	push	r17
     794:	cf 93       	push	r28
     796:	df 93       	push	r29
     798:	8a 01       	movw	r16, r20
     79a:	e9 01       	movw	r28, r18
	unsigned char flag=0;
	if(row==0||coloumn==0)
     79c:	88 23       	and	r24, r24
     79e:	11 f0       	breq	.+4      	; 0x7a4 <lcd_print+0x14>
     7a0:	66 23       	and	r22, r22
     7a2:	19 f4       	brne	.+6      	; 0x7aa <lcd_print+0x1a>
	{
		lcd_home();
     7a4:	0e 94 95 03 	call	0x72a	; 0x72a <lcd_home>
     7a8:	02 c0       	rjmp	.+4      	; 0x7ae <lcd_print+0x1e>
	}
	else
	{
		lcd_cursor(row,coloumn);
     7aa:	0e 94 a8 03 	call	0x750	; 0x750 <lcd_cursor>
	}
	if(digits==5 || flag==1)
     7ae:	c5 30       	cpi	r28, 0x05	; 5
     7b0:	d1 05       	cpc	r29, r1
     7b2:	71 f4       	brne	.+28     	; 0x7d0 <lcd_print+0x40>
	{
		million=value/10000+48;
     7b4:	c8 01       	movw	r24, r16
     7b6:	60 e1       	ldi	r22, 0x10	; 16
     7b8:	77 e2       	ldi	r23, 0x27	; 39
     7ba:	0e 94 48 1b 	call	0x3690	; 0x3690 <__udivmodhi4>
     7be:	cb 01       	movw	r24, r22
     7c0:	c0 96       	adiw	r24, 0x30	; 48
     7c2:	90 93 ae 02 	sts	0x02AE, r25
     7c6:	80 93 ad 02 	sts	0x02AD, r24
		lcd_wr_char(million);
     7ca:	0e 94 70 03 	call	0x6e0	; 0x6e0 <lcd_wr_char>
     7ce:	03 c0       	rjmp	.+6      	; 0x7d6 <lcd_print+0x46>
		flag=1;
	}
	if(digits==4 || flag==1)
     7d0:	c4 30       	cpi	r28, 0x04	; 4
     7d2:	d1 05       	cpc	r29, r1
     7d4:	b9 f4       	brne	.+46     	; 0x804 <lcd_print+0x74>
	{
		temp = value/1000;
     7d6:	c8 01       	movw	r24, r16
     7d8:	68 ee       	ldi	r22, 0xE8	; 232
     7da:	73 e0       	ldi	r23, 0x03	; 3
     7dc:	0e 94 48 1b 	call	0x3690	; 0x3690 <__udivmodhi4>
     7e0:	cb 01       	movw	r24, r22
     7e2:	70 93 b1 02 	sts	0x02B1, r23
     7e6:	60 93 b0 02 	sts	0x02B0, r22
		thousand = temp%10 + 48;
     7ea:	6a e0       	ldi	r22, 0x0A	; 10
     7ec:	70 e0       	ldi	r23, 0x00	; 0
     7ee:	0e 94 48 1b 	call	0x3690	; 0x3690 <__udivmodhi4>
     7f2:	c0 96       	adiw	r24, 0x30	; 48
     7f4:	90 93 61 05 	sts	0x0561, r25
     7f8:	80 93 60 05 	sts	0x0560, r24
		lcd_wr_char(thousand);
     7fc:	0e 94 70 03 	call	0x6e0	; 0x6e0 <lcd_wr_char>
		flag=1;
     800:	81 e0       	ldi	r24, 0x01	; 1
     802:	01 c0       	rjmp	.+2      	; 0x806 <lcd_print+0x76>
}

//Function To Print Any input value upto the desired digit on LCD
void lcd_print (char row, char coloumn, unsigned int value, int digits)
{
	unsigned char flag=0;
     804:	80 e0       	ldi	r24, 0x00	; 0
		temp = value/1000;
		thousand = temp%10 + 48;
		lcd_wr_char(thousand);
		flag=1;
	}
	if(digits==3 || flag==1)
     806:	c3 30       	cpi	r28, 0x03	; 3
     808:	d1 05       	cpc	r29, r1
     80a:	11 f0       	breq	.+4      	; 0x810 <lcd_print+0x80>
     80c:	81 30       	cpi	r24, 0x01	; 1
     80e:	b1 f4       	brne	.+44     	; 0x83c <lcd_print+0xac>
	{
		temp = value/100;
     810:	c8 01       	movw	r24, r16
     812:	64 e6       	ldi	r22, 0x64	; 100
     814:	70 e0       	ldi	r23, 0x00	; 0
     816:	0e 94 48 1b 	call	0x3690	; 0x3690 <__udivmodhi4>
     81a:	cb 01       	movw	r24, r22
     81c:	70 93 b1 02 	sts	0x02B1, r23
     820:	60 93 b0 02 	sts	0x02B0, r22
		hundred = temp%10 + 48;
     824:	6a e0       	ldi	r22, 0x0A	; 10
     826:	70 e0       	ldi	r23, 0x00	; 0
     828:	0e 94 48 1b 	call	0x3690	; 0x3690 <__udivmodhi4>
     82c:	c0 96       	adiw	r24, 0x30	; 48
     82e:	90 93 37 05 	sts	0x0537, r25
     832:	80 93 36 05 	sts	0x0536, r24
		lcd_wr_char(hundred);
     836:	0e 94 70 03 	call	0x6e0	; 0x6e0 <lcd_wr_char>
		flag=1;
     83a:	81 e0       	ldi	r24, 0x01	; 1
	}
	if(digits==2 || flag==1)
     83c:	c2 30       	cpi	r28, 0x02	; 2
     83e:	d1 05       	cpc	r29, r1
     840:	11 f0       	breq	.+4      	; 0x846 <lcd_print+0xb6>
     842:	81 30       	cpi	r24, 0x01	; 1
     844:	b1 f4       	brne	.+44     	; 0x872 <lcd_print+0xe2>
	{
		temp = value/10;
     846:	2a e0       	ldi	r18, 0x0A	; 10
     848:	30 e0       	ldi	r19, 0x00	; 0
     84a:	c8 01       	movw	r24, r16
     84c:	b9 01       	movw	r22, r18
     84e:	0e 94 48 1b 	call	0x3690	; 0x3690 <__udivmodhi4>
     852:	cb 01       	movw	r24, r22
     854:	70 93 b1 02 	sts	0x02B1, r23
     858:	60 93 b0 02 	sts	0x02B0, r22
		tens = temp%10 + 48;
     85c:	b9 01       	movw	r22, r18
     85e:	0e 94 48 1b 	call	0x3690	; 0x3690 <__udivmodhi4>
     862:	c0 96       	adiw	r24, 0x30	; 48
     864:	90 93 2f 05 	sts	0x052F, r25
     868:	80 93 2e 05 	sts	0x052E, r24
		lcd_wr_char(tens);
     86c:	0e 94 70 03 	call	0x6e0	; 0x6e0 <lcd_wr_char>
		flag=1;
     870:	81 e0       	ldi	r24, 0x01	; 1
	}
	if(digits==1 || flag==1)
     872:	c1 30       	cpi	r28, 0x01	; 1
     874:	d1 05       	cpc	r29, r1
     876:	11 f0       	breq	.+4      	; 0x87c <lcd_print+0xec>
     878:	81 30       	cpi	r24, 0x01	; 1
     87a:	61 f4       	brne	.+24     	; 0x894 <lcd_print+0x104>
	{
		unit = value%10 + 48;
     87c:	c8 01       	movw	r24, r16
     87e:	6a e0       	ldi	r22, 0x0A	; 10
     880:	70 e0       	ldi	r23, 0x00	; 0
     882:	0e 94 48 1b 	call	0x3690	; 0x3690 <__udivmodhi4>
     886:	c0 96       	adiw	r24, 0x30	; 48
     888:	90 93 5f 05 	sts	0x055F, r25
     88c:	80 93 5e 05 	sts	0x055E, r24
		lcd_wr_char(unit);
     890:	0e 94 70 03 	call	0x6e0	; 0x6e0 <lcd_wr_char>
	}
	if(digits>5)
     894:	c6 30       	cpi	r28, 0x06	; 6
     896:	d1 05       	cpc	r29, r1
     898:	1c f0       	brlt	.+6      	; 0x8a0 <lcd_print+0x110>
	{
		lcd_wr_char('E');
     89a:	85 e4       	ldi	r24, 0x45	; 69
     89c:	0e 94 70 03 	call	0x6e0	; 0x6e0 <lcd_wr_char>
	}
	
}
     8a0:	df 91       	pop	r29
     8a2:	cf 91       	pop	r28
     8a4:	1f 91       	pop	r17
     8a6:	0f 91       	pop	r16
     8a8:	08 95       	ret

000008aa <navigate>:
*
*/

void navigate(void) 
{
	cli();
     8aa:	f8 94       	cli
	if(navigation_in_degrees==0)
     8ac:	80 91 3d 02 	lds	r24, 0x023D
     8b0:	90 91 3e 02 	lds	r25, 0x023E
     8b4:	00 97       	sbiw	r24, 0x00	; 0
     8b6:	39 f4       	brne	.+14     	; 0x8c6 <navigate+0x1c>
	navigation_pointer="East ";
     8b8:	80 e0       	ldi	r24, 0x00	; 0
     8ba:	92 e0       	ldi	r25, 0x02	; 2
     8bc:	90 93 ac 02 	sts	0x02AC, r25
     8c0:	80 93 ab 02 	sts	0x02AB, r24
     8c4:	39 c0       	rjmp	.+114    	; 0x938 <navigate+0x8e>
	else if(abs(navigation_in_degrees)==270)
     8c6:	9c 01       	movw	r18, r24
     8c8:	99 23       	and	r25, r25
     8ca:	24 f4       	brge	.+8      	; 0x8d4 <navigate+0x2a>
     8cc:	22 27       	eor	r18, r18
     8ce:	33 27       	eor	r19, r19
     8d0:	28 1b       	sub	r18, r24
     8d2:	39 0b       	sbc	r19, r25
     8d4:	41 e0       	ldi	r20, 0x01	; 1
     8d6:	2e 30       	cpi	r18, 0x0E	; 14
     8d8:	34 07       	cpc	r19, r20
     8da:	89 f4       	brne	.+34     	; 0x8fe <navigate+0x54>
	{
		if(navigation_in_degrees>0)
     8dc:	18 16       	cp	r1, r24
     8de:	19 06       	cpc	r1, r25
     8e0:	3c f4       	brge	.+14     	; 0x8f0 <navigate+0x46>
		navigation_pointer="South";
     8e2:	86 e0       	ldi	r24, 0x06	; 6
     8e4:	92 e0       	ldi	r25, 0x02	; 2
     8e6:	90 93 ac 02 	sts	0x02AC, r25
     8ea:	80 93 ab 02 	sts	0x02AB, r24
     8ee:	24 c0       	rjmp	.+72     	; 0x938 <navigate+0x8e>
		else
		navigation_pointer="North";
     8f0:	8c e0       	ldi	r24, 0x0C	; 12
     8f2:	92 e0       	ldi	r25, 0x02	; 2
     8f4:	90 93 ac 02 	sts	0x02AC, r25
     8f8:	80 93 ab 02 	sts	0x02AB, r24
     8fc:	1d c0       	rjmp	.+58     	; 0x938 <navigate+0x8e>
	}
	else if(abs(navigation_in_degrees)==180)
     8fe:	24 3b       	cpi	r18, 0xB4	; 180
     900:	31 05       	cpc	r19, r1
     902:	39 f4       	brne	.+14     	; 0x912 <navigate+0x68>
	{
		navigation_pointer="West ";
     904:	82 e1       	ldi	r24, 0x12	; 18
     906:	92 e0       	ldi	r25, 0x02	; 2
     908:	90 93 ac 02 	sts	0x02AC, r25
     90c:	80 93 ab 02 	sts	0x02AB, r24
     910:	13 c0       	rjmp	.+38     	; 0x938 <navigate+0x8e>
	}
	else if(abs(navigation_in_degrees)==90)
     912:	2a 35       	cpi	r18, 0x5A	; 90
     914:	31 05       	cpc	r19, r1
     916:	81 f4       	brne	.+32     	; 0x938 <navigate+0x8e>
	{
		if(navigation_in_degrees>0)
     918:	18 16       	cp	r1, r24
     91a:	19 06       	cpc	r1, r25
     91c:	3c f4       	brge	.+14     	; 0x92c <navigate+0x82>
		navigation_pointer="North";
     91e:	8c e0       	ldi	r24, 0x0C	; 12
     920:	92 e0       	ldi	r25, 0x02	; 2
     922:	90 93 ac 02 	sts	0x02AC, r25
     926:	80 93 ab 02 	sts	0x02AB, r24
     92a:	06 c0       	rjmp	.+12     	; 0x938 <navigate+0x8e>
		else
		navigation_pointer="South";
     92c:	86 e0       	ldi	r24, 0x06	; 6
     92e:	92 e0       	ldi	r25, 0x02	; 2
     930:	90 93 ac 02 	sts	0x02AC, r25
     934:	80 93 ab 02 	sts	0x02AB, r24
	}
	lcd_cursor(2,12);
     938:	82 e0       	ldi	r24, 0x02	; 2
     93a:	6c e0       	ldi	r22, 0x0C	; 12
     93c:	0e 94 a8 03 	call	0x750	; 0x750 <lcd_cursor>
	lcd_string(navigation_pointer);
     940:	80 91 ab 02 	lds	r24, 0x02AB
     944:	90 91 ac 02 	lds	r25, 0x02AC
     948:	0e 94 99 03 	call	0x732	; 0x732 <lcd_string>
	lcd_cursor(2,1);
     94c:	82 e0       	ldi	r24, 0x02	; 2
     94e:	61 e0       	ldi	r22, 0x01	; 1
     950:	0e 94 a8 03 	call	0x750	; 0x750 <lcd_cursor>
	lcd_string("Node:-");
     954:	88 e1       	ldi	r24, 0x18	; 24
     956:	92 e0       	ldi	r25, 0x02	; 2
     958:	0e 94 99 03 	call	0x732	; 0x732 <lcd_string>
	lcd_print(2,7,node_number,2);
     95c:	40 91 5f 02 	lds	r20, 0x025F
     960:	50 91 60 02 	lds	r21, 0x0260
     964:	82 e0       	ldi	r24, 0x02	; 2
     966:	67 e0       	ldi	r22, 0x07	; 7
     968:	22 e0       	ldi	r18, 0x02	; 2
     96a:	30 e0       	ldi	r19, 0x00	; 0
     96c:	0e 94 c8 03 	call	0x790	; 0x790 <lcd_print>
	lcd_cursor(1,1);
     970:	81 e0       	ldi	r24, 0x01	; 1
     972:	61 e0       	ldi	r22, 0x01	; 1
     974:	0e 94 a8 03 	call	0x750	; 0x750 <lcd_cursor>
	lcd_string("A:");
     978:	8f e1       	ldi	r24, 0x1F	; 31
     97a:	92 e0       	ldi	r25, 0x02	; 2
     97c:	0e 94 99 03 	call	0x732	; 0x732 <lcd_string>
	lcd_print(1,3,deposition_zone_A,1);
     980:	40 91 3b 02 	lds	r20, 0x023B
     984:	50 91 3c 02 	lds	r21, 0x023C
     988:	81 e0       	ldi	r24, 0x01	; 1
     98a:	63 e0       	ldi	r22, 0x03	; 3
     98c:	21 e0       	ldi	r18, 0x01	; 1
     98e:	30 e0       	ldi	r19, 0x00	; 0
     990:	0e 94 c8 03 	call	0x790	; 0x790 <lcd_print>
	lcd_wr_char(' ');
     994:	80 e2       	ldi	r24, 0x20	; 32
     996:	0e 94 70 03 	call	0x6e0	; 0x6e0 <lcd_wr_char>
	lcd_string("B:");
     99a:	82 e2       	ldi	r24, 0x22	; 34
     99c:	92 e0       	ldi	r25, 0x02	; 2
     99e:	0e 94 99 03 	call	0x732	; 0x732 <lcd_string>
	lcd_print(1,7,deposition_zone_B,1);
     9a2:	40 91 39 02 	lds	r20, 0x0239
     9a6:	50 91 3a 02 	lds	r21, 0x023A
     9aa:	81 e0       	ldi	r24, 0x01	; 1
     9ac:	67 e0       	ldi	r22, 0x07	; 7
     9ae:	21 e0       	ldi	r18, 0x01	; 1
     9b0:	30 e0       	ldi	r19, 0x00	; 0
     9b2:	0e 94 c8 03 	call	0x790	; 0x790 <lcd_print>
	lcd_wr_char(' ');
     9b6:	80 e2       	ldi	r24, 0x20	; 32
     9b8:	0e 94 70 03 	call	0x6e0	; 0x6e0 <lcd_wr_char>
	lcd_string("C:");
     9bc:	85 e2       	ldi	r24, 0x25	; 37
     9be:	92 e0       	ldi	r25, 0x02	; 2
     9c0:	0e 94 99 03 	call	0x732	; 0x732 <lcd_string>
	lcd_print(1,11,deposition_zone_C,1);
     9c4:	40 91 37 02 	lds	r20, 0x0237
     9c8:	50 91 38 02 	lds	r21, 0x0238
     9cc:	81 e0       	ldi	r24, 0x01	; 1
     9ce:	6b e0       	ldi	r22, 0x0B	; 11
     9d0:	21 e0       	ldi	r18, 0x01	; 1
     9d2:	30 e0       	ldi	r19, 0x00	; 0
     9d4:	0e 94 c8 03 	call	0x790	; 0x790 <lcd_print>
	lcd_wr_char(' ');
     9d8:	80 e2       	ldi	r24, 0x20	; 32
     9da:	0e 94 70 03 	call	0x6e0	; 0x6e0 <lcd_wr_char>
	lcd_string("I:");
     9de:	88 e2       	ldi	r24, 0x28	; 40
     9e0:	92 e0       	ldi	r25, 0x02	; 2
     9e2:	0e 94 99 03 	call	0x732	; 0x732 <lcd_string>
	lcd_print(1,15,IP,1);
     9e6:	40 91 35 02 	lds	r20, 0x0235
     9ea:	50 91 36 02 	lds	r21, 0x0236
     9ee:	81 e0       	ldi	r24, 0x01	; 1
     9f0:	6f e0       	ldi	r22, 0x0F	; 15
     9f2:	21 e0       	ldi	r18, 0x01	; 1
     9f4:	30 e0       	ldi	r19, 0x00	; 0
     9f6:	0e 94 c8 03 	call	0x790	; 0x790 <lcd_print>
	lcd_wr_char(' ');
     9fa:	80 e2       	ldi	r24, 0x20	; 32
     9fc:	0e 94 70 03 	call	0x6e0	; 0x6e0 <lcd_wr_char>
	sei();
     a00:	78 94       	sei
}
     a02:	08 95       	ret

00000a04 <struct_config>:
*
*/

void struct_config(void)
{
	cli();                       // Clears the global interrupt
     a04:	f8 94       	cli
	def();						 // User defined function which gives null value to all the nodes of the arena
     a06:	0e 94 d6 00 	call	0x1ac	; 0x1ac <def>
	graph[0][1]='N';
     a0a:	2e e4       	ldi	r18, 0x4E	; 78
     a0c:	20 93 bd 02 	sts	0x02BD, r18
	graph[0][2]='S';
     a10:	33 e5       	ldi	r19, 0x53	; 83
     a12:	30 93 be 02 	sts	0x02BE, r19
	graph[0][6]='E';
     a16:	95 e4       	ldi	r25, 0x45	; 69
     a18:	90 93 c2 02 	sts	0x02C2, r25
	graph[0][10]='W';
     a1c:	87 e5       	ldi	r24, 0x57	; 87
     a1e:	80 93 c6 02 	sts	0x02C6, r24
	graph[1][0]='S';
     a22:	30 93 d5 02 	sts	0x02D5, r19
	graph[2][0]='N';
     a26:	20 93 ee 02 	sts	0x02EE, r18
	graph[2][3]='S';
     a2a:	30 93 f1 02 	sts	0x02F1, r19
	graph[2][4]='W';
     a2e:	80 93 f2 02 	sts	0x02F2, r24
	graph[3][2]='N';
     a32:	20 93 09 03 	sts	0x0309, r18
	graph[3][5]='W';
     a36:	80 93 0c 03 	sts	0x030C, r24
	graph[4][2]='E';
     a3a:	90 93 22 03 	sts	0x0322, r25
	graph[5][3]='E';
     a3e:	90 93 3c 03 	sts	0x033C, r25
	graph[6][0]='W';
     a42:	80 93 52 03 	sts	0x0352, r24
	graph[6][19]='N';
     a46:	20 93 65 03 	sts	0x0365, r18
	graph[6][18]='S';
     a4a:	30 93 64 03 	sts	0x0364, r19
	graph[7][19]='W';
     a4e:	80 93 7e 03 	sts	0x037E, r24
	graph[7][20]='E';
     a52:	90 93 7f 03 	sts	0x037F, r25
	graph[8][20]='N';
     a56:	20 93 98 03 	sts	0x0398, r18
	graph[9][18]='W';
     a5a:	80 93 af 03 	sts	0x03AF, r24
	graph[10][0]='E';
     a5e:	90 93 b6 03 	sts	0x03B6, r25
	graph[10][11]='N';
     a62:	20 93 c1 03 	sts	0x03C1, r18
	graph[10][13]='S';
     a66:	30 93 c3 03 	sts	0x03C3, r19
	graph[10][16]='W';
     a6a:	80 93 c6 03 	sts	0x03C6, r24
	graph[11][14]='E';
     a6e:	90 93 dd 03 	sts	0x03DD, r25
	graph[11][10]='S';
     a72:	30 93 d9 03 	sts	0x03D9, r19
	graph[11][12]='N';
     a76:	20 93 db 03 	sts	0x03DB, r18
	graph[12][15]='W';
     a7a:	80 93 f7 03 	sts	0x03F7, r24
	graph[12][11]='S';
     a7e:	30 93 f3 03 	sts	0x03F3, r19
	graph[13][10]='N';
     a82:	20 93 0b 04 	sts	0x040B, r18
	graph[13][17]='W';
     a86:	80 93 12 04 	sts	0x0412, r24
	graph[14][11]='W';
     a8a:	80 93 25 04 	sts	0x0425, r24
	graph[15][12]='E';
     a8e:	90 93 3f 04 	sts	0x043F, r25
	graph[16][10]='E';
     a92:	90 93 56 04 	sts	0x0456, r25
	graph[17][13]='E';
     a96:	90 93 72 04 	sts	0x0472, r25
	graph[19][7]='E';
     a9a:	90 93 9e 04 	sts	0x049E, r25
	graph[19][6]='S';
     a9e:	30 93 9d 04 	sts	0x049D, r19
	graph[18][6]='N';
     aa2:	20 93 84 04 	sts	0x0484, r18
	graph[18][9]='E';
     aa6:	90 93 87 04 	sts	0x0487, r25
	graph[20][8]='S';
     aaa:	30 93 b8 04 	sts	0x04B8, r19
	graph[20][7]='W';
     aae:	80 93 b7 04 	sts	0x04B7, r24
	graph[7][21]='N';
     ab2:	20 93 80 03 	sts	0x0380, r18
	graph[8][22]='E';
     ab6:	90 93 9a 03 	sts	0x039A, r25
	graph[9][23]='S';
     aba:	30 93 b4 03 	sts	0x03B4, r19
	graph[21][7]='S';
     abe:	30 93 d0 04 	sts	0x04D0, r19
	graph[22][8]='W';
     ac2:	80 93 ea 04 	sts	0x04EA, r24
	graph[23][9]='N';
     ac6:	20 93 04 05 	sts	0x0504, r18
	sei();					//Enables all the global interrupt
     aca:	78 94       	sei
}
     acc:	08 95       	ret

00000ace <path_logic>:
* Example Call:		path_logic(7,10);
*
*/

int path_logic(int curr_node, int req_node) 
{
     ace:	8f 92       	push	r8
     ad0:	9f 92       	push	r9
     ad2:	af 92       	push	r10
     ad4:	bf 92       	push	r11
     ad6:	cf 92       	push	r12
     ad8:	df 92       	push	r13
     ada:	ef 92       	push	r14
     adc:	ff 92       	push	r15
     ade:	0f 93       	push	r16
     ae0:	1f 93       	push	r17
     ae2:	cf 93       	push	r28
     ae4:	df 93       	push	r29
     ae6:	5c 01       	movw	r10, r24
     ae8:	4b 01       	movw	r8, r22
	if(curr_node==req_node && found==0)  //found is the variable to check the bot's traversal
     aea:	86 17       	cp	r24, r22
     aec:	97 07       	cpc	r25, r23
     aee:	69 f4       	brne	.+26     	; 0xb0a <path_logic+0x3c>
     af0:	80 91 5b 05 	lds	r24, 0x055B
     af4:	90 91 5c 05 	lds	r25, 0x055C
     af8:	00 97       	sbiw	r24, 0x00	; 0
     afa:	39 f4       	brne	.+14     	; 0xb0a <path_logic+0x3c>
	{
		found++;
     afc:	81 e0       	ldi	r24, 0x01	; 1
     afe:	90 e0       	ldi	r25, 0x00	; 0
     b00:	90 93 5c 05 	sts	0x055C, r25
     b04:	80 93 5b 05 	sts	0x055B, r24
		return(1);
     b08:	51 c0       	rjmp	.+162    	; 0xbac <path_logic+0xde>
					According to that it updates the path string(global variable)
* Example Call:		path_logic(7,10);
*
*/

int path_logic(int curr_node, int req_node) 
     b0a:	85 01       	movw	r16, r10
     b0c:	00 0f       	add	r16, r16
     b0e:	11 1f       	adc	r17, r17
     b10:	0a 0d       	add	r16, r10
     b12:	1b 1d       	adc	r17, r11
     b14:	00 0f       	add	r16, r16
     b16:	11 1f       	adc	r17, r17
     b18:	00 0f       	add	r16, r16
     b1a:	11 1f       	adc	r17, r17
     b1c:	00 0f       	add	r16, r16
     b1e:	11 1f       	adc	r17, r17
     b20:	0a 0d       	add	r16, r10
     b22:	1b 1d       	adc	r17, r11
     b24:	04 54       	subi	r16, 0x44	; 68
     b26:	1d 4f       	sbci	r17, 0xFD	; 253
     b28:	ee 24       	eor	r14, r14
     b2a:	ff 24       	eor	r15, r15
     b2c:	c0 e0       	ldi	r28, 0x00	; 0
     b2e:	d0 e0       	ldi	r29, 0x00	; 0
	//j: will iterate from 0 to the maximum nodes (maximum_number_of_nodes is the constant for the maximum number of nodes in the arena )
	for(j=0;j<maximum_number_of_nodes;j++)
	{
		if(graph[curr_node][j]!='\0' && previous_node!=j)
		{
			p[path_index]=graph[curr_node][j];  //path index -> index of the path string
     b30:	0f 2e       	mov	r0, r31
     b32:	f9 e8       	ldi	r31, 0x89	; 137
     b34:	cf 2e       	mov	r12, r31
     b36:	f2 e0       	ldi	r31, 0x02	; 2
     b38:	df 2e       	mov	r13, r31
     b3a:	f0 2d       	mov	r31, r0
	int j,r=0;							//r stores the value of return
	
	//j: will iterate from 0 to the maximum nodes (maximum_number_of_nodes is the constant for the maximum number of nodes in the arena )
	for(j=0;j<maximum_number_of_nodes;j++)
	{
		if(graph[curr_node][j]!='\0' && previous_node!=j)
     b3c:	f8 01       	movw	r30, r16
     b3e:	21 91       	ld	r18, Z+
     b40:	8f 01       	movw	r16, r30
     b42:	22 23       	and	r18, r18
     b44:	f1 f0       	breq	.+60     	; 0xb82 <path_logic+0xb4>
     b46:	80 91 30 05 	lds	r24, 0x0530
     b4a:	90 91 31 05 	lds	r25, 0x0531
     b4e:	8c 17       	cp	r24, r28
     b50:	9d 07       	cpc	r25, r29
     b52:	b9 f0       	breq	.+46     	; 0xb82 <path_logic+0xb4>
		{
			p[path_index]=graph[curr_node][j];  //path index -> index of the path string
     b54:	80 91 59 02 	lds	r24, 0x0259
     b58:	90 91 5a 02 	lds	r25, 0x025A
     b5c:	f6 01       	movw	r30, r12
     b5e:	e8 0f       	add	r30, r24
     b60:	f9 1f       	adc	r31, r25
     b62:	20 83       	st	Z, r18
			path_index=path_index+1;
     b64:	01 96       	adiw	r24, 0x01	; 1
     b66:	90 93 5a 02 	sts	0x025A, r25
     b6a:	80 93 59 02 	sts	0x0259, r24
			previous_node=curr_node;					//previous_node  -> previous node
     b6e:	b0 92 31 05 	sts	0x0531, r11
     b72:	a0 92 30 05 	sts	0x0530, r10
			r=r+path_logic(j,req_node);
     b76:	ce 01       	movw	r24, r28
     b78:	b4 01       	movw	r22, r8
     b7a:	0e 94 67 05 	call	0xace	; 0xace <path_logic>
     b7e:	e8 0e       	add	r14, r24
     b80:	f9 1e       	adc	r15, r25
		return(1);
	}
	int j,r=0;							//r stores the value of return
	
	//j: will iterate from 0 to the maximum nodes (maximum_number_of_nodes is the constant for the maximum number of nodes in the arena )
	for(j=0;j<maximum_number_of_nodes;j++)
     b82:	21 96       	adiw	r28, 0x01	; 1
     b84:	c9 31       	cpi	r28, 0x19	; 25
     b86:	d1 05       	cpc	r29, r1
     b88:	c9 f6       	brne	.-78     	; 0xb3c <path_logic+0x6e>
			path_index=path_index+1;
			previous_node=curr_node;					//previous_node  -> previous node
			r=r+path_logic(j,req_node);
		}
	}
	if(r>0)
     b8a:	1e 14       	cp	r1, r14
     b8c:	1f 04       	cpc	r1, r15
     b8e:	64 f0       	brlt	.+24     	; 0xba8 <path_logic+0xda>
	{
		return(1);
	}
	else
	{
		path_index--;
     b90:	80 91 59 02 	lds	r24, 0x0259
     b94:	90 91 5a 02 	lds	r25, 0x025A
     b98:	01 97       	sbiw	r24, 0x01	; 1
     b9a:	90 93 5a 02 	sts	0x025A, r25
     b9e:	80 93 59 02 	sts	0x0259, r24
		return(0);
     ba2:	80 e0       	ldi	r24, 0x00	; 0
     ba4:	90 e0       	ldi	r25, 0x00	; 0
     ba6:	02 c0       	rjmp	.+4      	; 0xbac <path_logic+0xde>
			r=r+path_logic(j,req_node);
		}
	}
	if(r>0)
	{
		return(1);
     ba8:	81 e0       	ldi	r24, 0x01	; 1
     baa:	90 e0       	ldi	r25, 0x00	; 0
	else
	{
		path_index--;
		return(0);
	}
}
     bac:	df 91       	pop	r29
     bae:	cf 91       	pop	r28
     bb0:	1f 91       	pop	r17
     bb2:	0f 91       	pop	r16
     bb4:	ff 90       	pop	r15
     bb6:	ef 90       	pop	r14
     bb8:	df 90       	pop	r13
     bba:	cf 90       	pop	r12
     bbc:	bf 90       	pop	r11
     bbe:	af 90       	pop	r10
     bc0:	9f 90       	pop	r9
     bc2:	8f 90       	pop	r8
     bc4:	08 95       	ret

00000bc6 <path_find>:
* Example Call:			path_find(10);
*
*/

void path_find(int req_node) 
{
     bc6:	0f 93       	push	r16
     bc8:	1f 93       	push	r17
     bca:	cf 93       	push	r28
     bcc:	df 93       	push	r29
     bce:	bc 01       	movw	r22, r24
	int i; 
	if(node_number==8 && req_node==23) // special case for the traversal of the bot from node 8 to node 23.
     bd0:	80 91 5f 02 	lds	r24, 0x025F
     bd4:	90 91 60 02 	lds	r25, 0x0260
     bd8:	88 30       	cpi	r24, 0x08	; 8
     bda:	91 05       	cpc	r25, r1
     bdc:	a1 f4       	brne	.+40     	; 0xc06 <path_find+0x40>
     bde:	67 31       	cpi	r22, 0x17	; 23
     be0:	71 05       	cpc	r23, r1
     be2:	89 f4       	brne	.+34     	; 0xc06 <path_find+0x40>
	{
		path[1]='S';
     be4:	83 e5       	ldi	r24, 0x53	; 83
     be6:	80 93 70 02 	sts	0x0270, r24
		path[2]='W';
     bea:	97 e5       	ldi	r25, 0x57	; 87
     bec:	90 93 71 02 	sts	0x0271, r25
		path[3]='S';
     bf0:	80 93 72 02 	sts	0x0272, r24
		path[4]='\0';
     bf4:	10 92 73 02 	sts	0x0273, r1
		path_index=1;
     bf8:	81 e0       	ldi	r24, 0x01	; 1
     bfa:	90 e0       	ldi	r25, 0x00	; 0
     bfc:	90 93 5a 02 	sts	0x025A, r25
     c00:	80 93 59 02 	sts	0x0259, r24
     c04:	d0 c0       	rjmp	.+416    	; 0xda6 <path_find+0x1e0>
	}
	
	else if(path[path_index]=='\0')
     c06:	e0 91 59 02 	lds	r30, 0x0259
     c0a:	f0 91 5a 02 	lds	r31, 0x025A
     c0e:	e1 59       	subi	r30, 0x91	; 145
     c10:	fd 4f       	sbci	r31, 0xFD	; 253
     c12:	80 81       	ld	r24, Z
     c14:	88 23       	and	r24, r24
     c16:	09 f0       	breq	.+2      	; 0xc1a <path_find+0x54>
     c18:	c3 c0       	rjmp	.+390    	; 0xda0 <path_find+0x1da>
	{
		cli();
     c1a:	f8 94       	cli
		destinationn_node=req_node;
     c1c:	70 93 5e 02 	sts	0x025E, r23
     c20:	60 93 5d 02 	sts	0x025D, r22
		previous_node=node_number;
     c24:	20 91 5f 02 	lds	r18, 0x025F
     c28:	30 91 60 02 	lds	r19, 0x0260
     c2c:	30 93 31 05 	sts	0x0531, r19
     c30:	20 93 30 05 	sts	0x0530, r18
     c34:	cf e6       	ldi	r28, 0x6F	; 111
     c36:	d2 e0       	ldi	r29, 0x02	; 2
						If the path string is fully occupied then it stores the node which the bot will traverse in the queue.
* Example Call:			path_find(10);
*
*/

void path_find(int req_node) 
     c38:	8e 01       	movw	r16, r28
     c3a:	ce 01       	movw	r24, r28
     c3c:	4a 96       	adiw	r24, 0x1a	; 26
     c3e:	fe 01       	movw	r30, r28
		destinationn_node=req_node;
		previous_node=node_number;
		
		//i: will iterate from 0 to the maximum nodes (maximum_number_of_nodes is the constant for the maximum number of nodes in the arena )
		for(i=0;i<maximum_number_of_nodes+1;i++)
		path[i]='\0';
     c40:	11 92       	st	Z+, r1
		cli();
		destinationn_node=req_node;
		previous_node=node_number;
		
		//i: will iterate from 0 to the maximum nodes (maximum_number_of_nodes is the constant for the maximum number of nodes in the arena )
		for(i=0;i<maximum_number_of_nodes+1;i++)
     c42:	e8 17       	cp	r30, r24
     c44:	f9 07       	cpc	r31, r25
     c46:	e1 f7       	brne	.-8      	; 0xc40 <path_find+0x7a>
		path[i]='\0';
		path_index=1;
     c48:	81 e0       	ldi	r24, 0x01	; 1
     c4a:	90 e0       	ldi	r25, 0x00	; 0
     c4c:	90 93 5a 02 	sts	0x025A, r25
     c50:	80 93 59 02 	sts	0x0259, r24
		found=0;
     c54:	10 92 5c 05 	sts	0x055C, r1
     c58:	10 92 5b 05 	sts	0x055B, r1
		path_logic(node_number,req_node);
     c5c:	c9 01       	movw	r24, r18
     c5e:	0e 94 67 05 	call	0xace	; 0xace <path_logic>
		path_index--;
     c62:	20 91 59 02 	lds	r18, 0x0259
     c66:	30 91 5a 02 	lds	r19, 0x025A
     c6a:	21 50       	subi	r18, 0x01	; 1
     c6c:	30 40       	sbci	r19, 0x00	; 0
						If the path string is fully occupied then it stores the node which the bot will traverse in the queue.
* Example Call:			path_find(10);
*
*/

void path_find(int req_node) 
     c6e:	05 5e       	subi	r16, 0xE5	; 229
     c70:	1f 4f       	sbci	r17, 0xFF	; 255
		path_index--;
		
		//i: will iterate from 0 to the maximum nodes (maximum_number_of_nodes is the constant for the maximum number of nodes in the arena )
		for(i=0;i<=maximum_number_of_nodes+1;i++)
		{
			path[i]='\0';
     c72:	19 92       	st	Y+, r1
		found=0;
		path_logic(node_number,req_node);
		path_index--;
		
		//i: will iterate from 0 to the maximum nodes (maximum_number_of_nodes is the constant for the maximum number of nodes in the arena )
		for(i=0;i<=maximum_number_of_nodes+1;i++)
     c74:	c0 17       	cp	r28, r16
     c76:	d1 07       	cpc	r29, r17
     c78:	e1 f7       	brne	.-8      	; 0xc72 <path_find+0xac>
		{
			path[i]='\0';
		}
		
		//i: will iterate from 1 to the length of the path index
		for(i=1;i<=path_index;i++)  
     c7a:	12 16       	cp	r1, r18
     c7c:	13 06       	cpc	r1, r19
     c7e:	64 f4       	brge	.+24     	; 0xc98 <path_find+0xd2>
     c80:	ea e8       	ldi	r30, 0x8A	; 138
     c82:	f2 e0       	ldi	r31, 0x02	; 2
     c84:	a0 e7       	ldi	r26, 0x70	; 112
     c86:	b2 e0       	ldi	r27, 0x02	; 2
     c88:	81 e0       	ldi	r24, 0x01	; 1
     c8a:	90 e0       	ldi	r25, 0x00	; 0
		{
			path[i]=p[i];
     c8c:	41 91       	ld	r20, Z+
     c8e:	4d 93       	st	X+, r20
		{
			path[i]='\0';
		}
		
		//i: will iterate from 1 to the length of the path index
		for(i=1;i<=path_index;i++)  
     c90:	01 96       	adiw	r24, 0x01	; 1
     c92:	28 17       	cp	r18, r24
     c94:	39 07       	cpc	r19, r25
     c96:	d4 f7       	brge	.-12     	; 0xc8c <path_find+0xc6>
		}
		path_index=1;
		i=1;
		
		
		while(path[path_index]!='\0')		//Filters the counter direction West and East   
     c98:	80 91 70 02 	lds	r24, 0x0270
     c9c:	88 23       	and	r24, r24
     c9e:	31 f4       	brne	.+12     	; 0xcac <path_find+0xe6>
		for(i=1;i<=path_index;i++)  
		{
			path[i]=p[i];
		}
		path_index=1;
		i=1;
     ca0:	21 e0       	ldi	r18, 0x01	; 1
     ca2:	30 e0       	ldi	r19, 0x00	; 0
						If the path string is fully occupied then it stores the node which the bot will traverse in the queue.
* Example Call:			path_find(10);
*
*/

void path_find(int req_node) 
     ca4:	f9 01       	movw	r30, r18
     ca6:	e1 59       	subi	r30, 0x91	; 145
     ca8:	fd 4f       	sbci	r31, 0xFD	; 253
     caa:	2d c0       	rjmp	.+90     	; 0xd06 <path_find+0x140>
		}
		path_index=1;
		i=1;
		
		
		while(path[path_index]!='\0')		//Filters the counter direction West and East   
     cac:	a0 e7       	ldi	r26, 0x70	; 112
     cae:	b2 e0       	ldi	r27, 0x02	; 2
     cb0:	ed 01       	movw	r28, r26
     cb2:	81 e0       	ldi	r24, 0x01	; 1
     cb4:	90 e0       	ldi	r25, 0x00	; 0
     cb6:	61 e0       	ldi	r22, 0x01	; 1
     cb8:	70 e0       	ldi	r23, 0x00	; 0
		for(i=1;i<=path_index;i++)  
		{
			path[i]=p[i];
		}
		path_index=1;
		i=1;
     cba:	21 e0       	ldi	r18, 0x01	; 1
     cbc:	30 e0       	ldi	r19, 0x00	; 0
		
		while(path[path_index]!='\0')		//Filters the counter direction West and East   
		{
			if((path[i]=='E' && path[i+1]=='W') || (path[i]=='W' && path[i+1]=='E'))
			path_index=path_index+2;
			path[i]=path[path_index];
     cbe:	4f e6       	ldi	r20, 0x6F	; 111
     cc0:	52 e0       	ldi	r21, 0x02	; 2
     cc2:	01 c0       	rjmp	.+2      	; 0xcc6 <path_find+0x100>
		}
		path_index=1;
		i=1;
		
		
		while(path[path_index]!='\0')		//Filters the counter direction West and East   
     cc4:	bc 01       	movw	r22, r24
		{
			if((path[i]=='E' && path[i+1]=='W') || (path[i]=='W' && path[i+1]=='E'))
     cc6:	ed 91       	ld	r30, X+
     cc8:	e5 34       	cpi	r30, 0x45	; 69
     cca:	21 f4       	brne	.+8      	; 0xcd4 <path_find+0x10e>
     ccc:	ec 91       	ld	r30, X
     cce:	e7 35       	cpi	r30, 0x57	; 87
     cd0:	41 f4       	brne	.+16     	; 0xce2 <path_find+0x11c>
     cd2:	05 c0       	rjmp	.+10     	; 0xcde <path_find+0x118>
     cd4:	e7 35       	cpi	r30, 0x57	; 87
     cd6:	29 f4       	brne	.+10     	; 0xce2 <path_find+0x11c>
     cd8:	ec 91       	ld	r30, X
     cda:	e5 34       	cpi	r30, 0x45	; 69
     cdc:	11 f4       	brne	.+4      	; 0xce2 <path_find+0x11c>
			path_index=path_index+2;
     cde:	cb 01       	movw	r24, r22
     ce0:	02 96       	adiw	r24, 0x02	; 2
			path[i]=path[path_index];
     ce2:	fa 01       	movw	r30, r20
     ce4:	e8 0f       	add	r30, r24
     ce6:	f9 1f       	adc	r31, r25
     ce8:	60 81       	ld	r22, Z
     cea:	69 93       	st	Y+, r22
			i++;
     cec:	2f 5f       	subi	r18, 0xFF	; 255
     cee:	3f 4f       	sbci	r19, 0xFF	; 255
			path_index++;
     cf0:	01 96       	adiw	r24, 0x01	; 1
		}
		path_index=1;
		i=1;
		
		
		while(path[path_index]!='\0')		//Filters the counter direction West and East   
     cf2:	fa 01       	movw	r30, r20
     cf4:	e8 0f       	add	r30, r24
     cf6:	f9 1f       	adc	r31, r25
     cf8:	60 81       	ld	r22, Z
     cfa:	66 23       	and	r22, r22
     cfc:	19 f7       	brne	.-58     	; 0xcc4 <path_find+0xfe>
			i++;
			path_index++;
		}
		
		//path_index: will iterate from i to the maximum number of nodes
		for(path_index=i;path_index<=maximum_number_of_nodes+1;path_index++)		//only produces that string which is required for traversal and other elements are given null value
     cfe:	2b 31       	cpi	r18, 0x1B	; 27
     d00:	31 05       	cpc	r19, r1
     d02:	84 f2       	brlt	.-96     	; 0xca4 <path_find+0xde>
     d04:	06 c0       	rjmp	.+12     	; 0xd12 <path_find+0x14c>
		path[path_index]='\0';
     d06:	11 92       	st	Z+, r1
			i++;
			path_index++;
		}
		
		//path_index: will iterate from i to the maximum number of nodes
		for(path_index=i;path_index<=maximum_number_of_nodes+1;path_index++)		//only produces that string which is required for traversal and other elements are given null value
     d08:	2f 5f       	subi	r18, 0xFF	; 255
     d0a:	3f 4f       	sbci	r19, 0xFF	; 255
     d0c:	2b 31       	cpi	r18, 0x1B	; 27
     d0e:	31 05       	cpc	r19, r1
     d10:	d4 f3       	brlt	.-12     	; 0xd06 <path_find+0x140>
		path[path_index]='\0';
		path_index=1;
		i=1;
		
		while(path[path_index]!='\0')		//Filters the counter direction South and North
     d12:	80 91 70 02 	lds	r24, 0x0270
     d16:	88 23       	and	r24, r24
     d18:	31 f4       	brne	.+12     	; 0xd26 <path_find+0x160>
		
		//path_index: will iterate from i to the maximum number of nodes
		for(path_index=i;path_index<=maximum_number_of_nodes+1;path_index++)		//only produces that string which is required for traversal and other elements are given null value
		path[path_index]='\0';
		path_index=1;
		i=1;
     d1a:	41 e0       	ldi	r20, 0x01	; 1
     d1c:	50 e0       	ldi	r21, 0x00	; 0
						If the path string is fully occupied then it stores the node which the bot will traverse in the queue.
* Example Call:			path_find(10);
*
*/

void path_find(int req_node) 
     d1e:	fa 01       	movw	r30, r20
     d20:	e1 59       	subi	r30, 0x91	; 145
     d22:	fd 4f       	sbci	r31, 0xFD	; 253
     d24:	2f c0       	rjmp	.+94     	; 0xd84 <path_find+0x1be>
		for(path_index=i;path_index<=maximum_number_of_nodes+1;path_index++)		//only produces that string which is required for traversal and other elements are given null value
		path[path_index]='\0';
		path_index=1;
		i=1;
		
		while(path[path_index]!='\0')		//Filters the counter direction South and North
     d26:	a0 e7       	ldi	r26, 0x70	; 112
     d28:	b2 e0       	ldi	r27, 0x02	; 2
     d2a:	ed 01       	movw	r28, r26
     d2c:	81 e0       	ldi	r24, 0x01	; 1
     d2e:	90 e0       	ldi	r25, 0x00	; 0
     d30:	21 e0       	ldi	r18, 0x01	; 1
     d32:	30 e0       	ldi	r19, 0x00	; 0
		
		//path_index: will iterate from i to the maximum number of nodes
		for(path_index=i;path_index<=maximum_number_of_nodes+1;path_index++)		//only produces that string which is required for traversal and other elements are given null value
		path[path_index]='\0';
		path_index=1;
		i=1;
     d34:	41 e0       	ldi	r20, 0x01	; 1
     d36:	50 e0       	ldi	r21, 0x00	; 0
		
		while(path[path_index]!='\0')		//Filters the counter direction South and North
		{
			if((path[i]=='S' && path[i+1]=='N') || (path[i]=='N' && path[i+1]=='S'))
			path_index=path_index+2;
			path[i]=path[path_index];
     d38:	6f e6       	ldi	r22, 0x6F	; 111
     d3a:	72 e0       	ldi	r23, 0x02	; 2
     d3c:	01 c0       	rjmp	.+2      	; 0xd40 <path_find+0x17a>
			i++;
			path_index++;
     d3e:	c9 01       	movw	r24, r18
		path_index=1;
		i=1;
		
		while(path[path_index]!='\0')		//Filters the counter direction South and North
		{
			if((path[i]=='S' && path[i+1]=='N') || (path[i]=='N' && path[i+1]=='S'))
     d40:	ed 91       	ld	r30, X+
     d42:	e3 35       	cpi	r30, 0x53	; 83
     d44:	21 f4       	brne	.+8      	; 0xd4e <path_find+0x188>
     d46:	ec 91       	ld	r30, X
     d48:	ee 34       	cpi	r30, 0x4E	; 78
     d4a:	41 f4       	brne	.+16     	; 0xd5c <path_find+0x196>
     d4c:	05 c0       	rjmp	.+10     	; 0xd58 <path_find+0x192>
     d4e:	ee 34       	cpi	r30, 0x4E	; 78
     d50:	29 f4       	brne	.+10     	; 0xd5c <path_find+0x196>
     d52:	ec 91       	ld	r30, X
     d54:	e3 35       	cpi	r30, 0x53	; 83
     d56:	11 f4       	brne	.+4      	; 0xd5c <path_find+0x196>
			path_index=path_index+2;
     d58:	c9 01       	movw	r24, r18
     d5a:	02 96       	adiw	r24, 0x02	; 2
			path[i]=path[path_index];
     d5c:	fb 01       	movw	r30, r22
     d5e:	e8 0f       	add	r30, r24
     d60:	f9 1f       	adc	r31, r25
     d62:	20 81       	ld	r18, Z
     d64:	29 93       	st	Y+, r18
			i++;
     d66:	4f 5f       	subi	r20, 0xFF	; 255
     d68:	5f 4f       	sbci	r21, 0xFF	; 255
			path_index++;
     d6a:	9c 01       	movw	r18, r24
     d6c:	2f 5f       	subi	r18, 0xFF	; 255
     d6e:	3f 4f       	sbci	r19, 0xFF	; 255
		for(path_index=i;path_index<=maximum_number_of_nodes+1;path_index++)		//only produces that string which is required for traversal and other elements are given null value
		path[path_index]='\0';
		path_index=1;
		i=1;
		
		while(path[path_index]!='\0')		//Filters the counter direction South and North
     d70:	fb 01       	movw	r30, r22
     d72:	e2 0f       	add	r30, r18
     d74:	f3 1f       	adc	r31, r19
     d76:	80 81       	ld	r24, Z
     d78:	88 23       	and	r24, r24
     d7a:	09 f7       	brne	.-62     	; 0xd3e <path_find+0x178>
			path[i]=path[path_index];
			i++;
			path_index++;
		}
		
		for(path_index=i;path_index<=maximum_number_of_nodes+1;path_index++)
     d7c:	4b 31       	cpi	r20, 0x1B	; 27
     d7e:	51 05       	cpc	r21, r1
     d80:	74 f2       	brlt	.-100    	; 0xd1e <path_find+0x158>
     d82:	06 c0       	rjmp	.+12     	; 0xd90 <path_find+0x1ca>
		path[path_index]='\0';
     d84:	11 92       	st	Z+, r1
			path[i]=path[path_index];
			i++;
			path_index++;
		}
		
		for(path_index=i;path_index<=maximum_number_of_nodes+1;path_index++)
     d86:	4f 5f       	subi	r20, 0xFF	; 255
     d88:	5f 4f       	sbci	r21, 0xFF	; 255
     d8a:	4b 31       	cpi	r20, 0x1B	; 27
     d8c:	51 05       	cpc	r21, r1
     d8e:	d4 f3       	brlt	.-12     	; 0xd84 <path_find+0x1be>
		path[path_index]='\0';
		
		path_index=1;
     d90:	81 e0       	ldi	r24, 0x01	; 1
     d92:	90 e0       	ldi	r25, 0x00	; 0
     d94:	90 93 5a 02 	sts	0x025A, r25
     d98:	80 93 59 02 	sts	0x0259, r24
		sei();
     d9c:	78 94       	sei
     d9e:	03 c0       	rjmp	.+6      	; 0xda6 <path_find+0x1e0>
	}
	else
	{
		enqueue(req_node);   //If the path string is fully occupied then it stores the node( which the bot will traverse) in the queue.
     da0:	cb 01       	movw	r24, r22
     da2:	0e 94 02 01 	call	0x204	; 0x204 <enqueue>
	}
}
     da6:	df 91       	pop	r29
     da8:	cf 91       	pop	r28
     daa:	1f 91       	pop	r17
     dac:	0f 91       	pop	r16
     dae:	08 95       	ret

00000db0 <enq_end>:
* Example Call:				enq_end(10);
*
*/

void enq_end(int node_added_start)
{
     db0:	0f 93       	push	r16
     db2:	1f 93       	push	r17
     db4:	cf 93       	push	r28
     db6:	df 93       	push	r29
     db8:	8c 01       	movw	r16, r24
	struct queue *newnode;
	if(end==NULL)
     dba:	c0 91 4a 02 	lds	r28, 0x024A
     dbe:	d0 91 4b 02 	lds	r29, 0x024B
     dc2:	20 97       	sbiw	r28, 0x00	; 0
     dc4:	a9 f4       	brne	.+42     	; 0xdf0 <enq_end+0x40>
	{
		end=(struct queue*)malloc(sizeof(struct queue));
     dc6:	86 e0       	ldi	r24, 0x06	; 6
     dc8:	90 e0       	ldi	r25, 0x00	; 0
     dca:	0e 94 6f 1b 	call	0x36de	; 0x36de <malloc>
     dce:	e8 2f       	mov	r30, r24
     dd0:	f9 2f       	mov	r31, r25
     dd2:	f0 93 4b 02 	sts	0x024B, r31
     dd6:	e0 93 4a 02 	sts	0x024A, r30
		end->num=node_added_start;
     dda:	15 83       	std	Z+5, r17	; 0x05
     ddc:	04 83       	std	Z+4, r16	; 0x04
		end->next=NULL;
     dde:	11 82       	std	Z+1, r1	; 0x01
     de0:	10 82       	st	Z, r1
		end->prev=NULL;
     de2:	13 82       	std	Z+3, r1	; 0x03
     de4:	12 82       	std	Z+2, r1	; 0x02
		root=end;
     de6:	f0 93 4d 02 	sts	0x024D, r31
     dea:	e0 93 4c 02 	sts	0x024C, r30
     dee:	14 c0       	rjmp	.+40     	; 0xe18 <enq_end+0x68>
	}
	else
	{
		newnode=(struct queue*)malloc(sizeof(struct queue));
     df0:	86 e0       	ldi	r24, 0x06	; 6
     df2:	90 e0       	ldi	r25, 0x00	; 0
     df4:	0e 94 6f 1b 	call	0x36de	; 0x36de <malloc>
     df8:	e8 2f       	mov	r30, r24
     dfa:	f9 2f       	mov	r31, r25
		newnode->num=node_added_start;
     dfc:	15 83       	std	Z+5, r17	; 0x05
     dfe:	04 83       	std	Z+4, r16	; 0x04
		end->prev=newnode;
     e00:	fb 83       	std	Y+3, r31	; 0x03
     e02:	ea 83       	std	Y+2, r30	; 0x02
		newnode->next=end;
     e04:	d1 83       	std	Z+1, r29	; 0x01
     e06:	c0 83       	st	Z, r28
		end=end->prev;
     e08:	8a 81       	ldd	r24, Y+2	; 0x02
     e0a:	9b 81       	ldd	r25, Y+3	; 0x03
     e0c:	90 93 4b 02 	sts	0x024B, r25
     e10:	80 93 4a 02 	sts	0x024A, r24
		newnode->prev=NULL;
     e14:	13 82       	std	Z+3, r1	; 0x03
     e16:	12 82       	std	Z+2, r1	; 0x02
	}
	que_length++;
     e18:	80 91 57 02 	lds	r24, 0x0257
     e1c:	90 91 58 02 	lds	r25, 0x0258
     e20:	01 96       	adiw	r24, 0x01	; 1
     e22:	90 93 58 02 	sts	0x0258, r25
     e26:	80 93 57 02 	sts	0x0257, r24
}
     e2a:	df 91       	pop	r29
     e2c:	cf 91       	pop	r28
     e2e:	1f 91       	pop	r17
     e30:	0f 91       	pop	r16
     e32:	08 95       	ret

00000e34 <dequeue>:
*
*/

void dequeue(void)
{
	if(que_length!=0)
     e34:	80 91 57 02 	lds	r24, 0x0257
     e38:	90 91 58 02 	lds	r25, 0x0258
     e3c:	00 97       	sbiw	r24, 0x00	; 0
     e3e:	b1 f0       	breq	.+44     	; 0xe6c <dequeue+0x38>
	{
		struct queue *newnode;
		newnode=end;
     e40:	80 91 4a 02 	lds	r24, 0x024A
     e44:	90 91 4b 02 	lds	r25, 0x024B
		end=end->next;
     e48:	fc 01       	movw	r30, r24
     e4a:	20 81       	ld	r18, Z
     e4c:	31 81       	ldd	r19, Z+1	; 0x01
     e4e:	30 93 4b 02 	sts	0x024B, r19
     e52:	20 93 4a 02 	sts	0x024A, r18
		free(newnode);
     e56:	0e 94 05 1c 	call	0x380a	; 0x380a <free>
		que_length--;
     e5a:	80 91 57 02 	lds	r24, 0x0257
     e5e:	90 91 58 02 	lds	r25, 0x0258
     e62:	01 97       	sbiw	r24, 0x01	; 1
     e64:	90 93 58 02 	sts	0x0258, r25
     e68:	80 93 57 02 	sts	0x0257, r24
     e6c:	08 95       	ret

00000e6e <buzzer>:
*
*/

void buzzer(int a)
{
	DDRC=0xFF;			  //Buzzer is connected to pin no 3 of port c
     e6e:	2f ef       	ldi	r18, 0xFF	; 255
     e70:	27 b9       	out	0x07, r18	; 7
	if(a==1)
     e72:	81 30       	cpi	r24, 0x01	; 1
     e74:	91 05       	cpc	r25, r1
     e76:	11 f4       	brne	.+4      	; 0xe7c <buzzer+0xe>
	PORTC=PORTC|0b00001000;
     e78:	43 9a       	sbi	0x08, 3	; 8
     e7a:	08 95       	ret
	else if(a==0)
     e7c:	00 97       	sbiw	r24, 0x00	; 0
     e7e:	09 f4       	brne	.+2      	; 0xe82 <buzzer+0x14>
	PORTC=PORTC & 0b11110111;
     e80:	43 98       	cbi	0x08, 3	; 8
     e82:	08 95       	ret

00000e84 <lcd_port_config>:
*
*/

void lcd_port_config (void)
{
	cli();
     e84:	f8 94       	cli
	DDRC = DDRC | 0xF7;		 //all the LCD pin's direction set as output
     e86:	87 b1       	in	r24, 0x07	; 7
     e88:	87 6f       	ori	r24, 0xF7	; 247
     e8a:	87 b9       	out	0x07, r24	; 7
	PORTC = PORTC & 0x80;	 // all the LCD pins are set to logic 0 except PORTC 7
     e8c:	88 b1       	in	r24, 0x08	; 8
     e8e:	80 78       	andi	r24, 0x80	; 128
     e90:	88 b9       	out	0x08, r24	; 8
	sei();
     e92:	78 94       	sei
}
     e94:	08 95       	ret

00000e96 <motion>:
*
*/

void motion(char movement)
{
	DDRA=DDRA | 0X0F; // Port A pin no 0,1,2,3 are for motion controlling
     e96:	91 b1       	in	r25, 0x01	; 1
     e98:	9f 60       	ori	r25, 0x0F	; 15
     e9a:	91 b9       	out	0x01, r25	; 1
	if(movement=='f')
     e9c:	86 36       	cpi	r24, 0x66	; 102
     e9e:	19 f4       	brne	.+6      	; 0xea6 <motion+0x10>
	PORTA=0b00000110;
     ea0:	86 e0       	ldi	r24, 0x06	; 6
     ea2:	82 b9       	out	0x02, r24	; 2
     ea4:	08 95       	ret
	else if(movement=='b')
     ea6:	82 36       	cpi	r24, 0x62	; 98
     ea8:	19 f4       	brne	.+6      	; 0xeb0 <motion+0x1a>
	PORTA=0b00001001;
     eaa:	89 e0       	ldi	r24, 0x09	; 9
     eac:	82 b9       	out	0x02, r24	; 2
     eae:	08 95       	ret
	else if(movement=='l')
     eb0:	8c 36       	cpi	r24, 0x6C	; 108
     eb2:	19 f4       	brne	.+6      	; 0xeba <motion+0x24>
	PORTA=0b00000101;
     eb4:	85 e0       	ldi	r24, 0x05	; 5
     eb6:	82 b9       	out	0x02, r24	; 2
     eb8:	08 95       	ret
	else if(movement=='r')
     eba:	82 37       	cpi	r24, 0x72	; 114
     ebc:	19 f4       	brne	.+6      	; 0xec4 <motion+0x2e>
	PORTA=0b00001010;
     ebe:	8a e0       	ldi	r24, 0x0A	; 10
     ec0:	82 b9       	out	0x02, r24	; 2
     ec2:	08 95       	ret
	else if('s')
	PORTA=0x00;
     ec4:	12 b8       	out	0x02, r1	; 2
     ec6:	08 95       	ret

00000ec8 <sppeed_config>:
*
*/

void sppeed_config(void)
{
	cli();
     ec8:	f8 94       	cli
	DDRA=DDRA|0x0F;
     eca:	81 b1       	in	r24, 0x01	; 1
     ecc:	8f 60       	ori	r24, 0x0F	; 15
     ece:	81 b9       	out	0x01, r24	; 1
	DDRL=DDRL | 0b00011000;			// declaring pin mo Pl3 and Pl4 as output
     ed0:	ea e0       	ldi	r30, 0x0A	; 10
     ed2:	f1 e0       	ldi	r31, 0x01	; 1
     ed4:	80 81       	ld	r24, Z
     ed6:	88 61       	ori	r24, 0x18	; 24
     ed8:	80 83       	st	Z, r24
	PORTL=PORTL|0b00011000;			// if Output Compare pins are disconnected than output Will be one at these pins
     eda:	eb e0       	ldi	r30, 0x0B	; 11
     edc:	f1 e0       	ldi	r31, 0x01	; 1
     ede:	80 81       	ld	r24, Z
     ee0:	88 61       	ori	r24, 0x18	; 24
     ee2:	80 83       	st	Z, r24
	TCNT5=0x00FF;					// initial value of counter
     ee4:	8f ef       	ldi	r24, 0xFF	; 255
     ee6:	90 e0       	ldi	r25, 0x00	; 0
     ee8:	90 93 25 01 	sts	0x0125, r25
     eec:	80 93 24 01 	sts	0x0124, r24
	TCCR5A=TCCR5A | 0b10101001;		// Timer counter control register
     ef0:	e0 e2       	ldi	r30, 0x20	; 32
     ef2:	f1 e0       	ldi	r31, 0x01	; 1
     ef4:	80 81       	ld	r24, Z
     ef6:	89 6a       	ori	r24, 0xA9	; 169
     ef8:	80 83       	st	Z, r24
	TCCR5B=TCCR5B | 0b00001011;
     efa:	e1 e2       	ldi	r30, 0x21	; 33
     efc:	f1 e0       	ldi	r31, 0x01	; 1
     efe:	80 81       	ld	r24, Z
     f00:	8b 60       	ori	r24, 0x0B	; 11
     f02:	80 83       	st	Z, r24
	sppeed(255,249);
     f04:	8f ef       	ldi	r24, 0xFF	; 255
     f06:	90 e0       	ldi	r25, 0x00	; 0
     f08:	69 ef       	ldi	r22, 0xF9	; 249
     f0a:	70 e0       	ldi	r23, 0x00	; 0
     f0c:	0e 94 f7 00 	call	0x1ee	; 0x1ee <sppeed>
	sei();
     f10:	78 94       	sei
}
     f12:	08 95       	ret

00000f14 <distance>:
* Example Call:				distance('f',11,'o');
*
*/

void distance(char a,float cm,char iop)
{
     f14:	cf 92       	push	r12
     f16:	df 92       	push	r13
     f18:	ef 92       	push	r14
     f1a:	ff 92       	push	r15
     f1c:	1f 93       	push	r17
     f1e:	cf 93       	push	r28
     f20:	df 93       	push	r29
     f22:	c8 2f       	mov	r28, r24
     f24:	6a 01       	movw	r12, r20
     f26:	7b 01       	movw	r14, r22
	sppeed(255,249);
     f28:	8f ef       	ldi	r24, 0xFF	; 255
     f2a:	90 e0       	ldi	r25, 0x00	; 0
     f2c:	69 ef       	ldi	r22, 0xF9	; 249
     f2e:	70 e0       	ldi	r23, 0x00	; 0
     f30:	0e 94 f7 00 	call	0x1ee	; 0x1ee <sppeed>
	float b=0;
	right_position_encode=0; //clearing encoder value
     f34:	10 92 61 02 	sts	0x0261, r1
     f38:	10 92 62 02 	sts	0x0262, r1
     f3c:	10 92 63 02 	sts	0x0263, r1
     f40:	10 92 64 02 	sts	0x0264, r1
	left_position_encode=0;
     f44:	10 92 65 02 	sts	0x0265, r1
     f48:	10 92 66 02 	sts	0x0266, r1
     f4c:	10 92 67 02 	sts	0x0267, r1
     f50:	10 92 68 02 	sts	0x0268, r1
*/

void distance(char a,float cm,char iop)
{
	sppeed(255,249);
	float b=0;
     f54:	60 e0       	ldi	r22, 0x00	; 0
     f56:	70 e0       	ldi	r23, 0x00	; 0
     f58:	80 e0       	ldi	r24, 0x00	; 0
     f5a:	90 e0       	ldi	r25, 0x00	; 0
		{
			PORTA=0b00000110;
		}
		else if(a=='b')
		{
			PORTA=0b00001001;
     f5c:	19 e0       	ldi	r17, 0x09	; 9
	left_position_encode=0;
	while((ceil(b))<(cm))
	{
		if(a=='f')
		{
			PORTA=0b00000110;
     f5e:	d6 e0       	ldi	r29, 0x06	; 6
{
	sppeed(255,249);
	float b=0;
	right_position_encode=0; //clearing encoder value
	left_position_encode=0;
	while((ceil(b))<(cm))
     f60:	17 c0       	rjmp	.+46     	; 0xf90 <distance+0x7c>
	{
		if(a=='f')
     f62:	c6 36       	cpi	r28, 0x66	; 102
     f64:	11 f4       	brne	.+4      	; 0xf6a <distance+0x56>
		{
			PORTA=0b00000110;
     f66:	d2 b9       	out	0x02, r29	; 2
     f68:	03 c0       	rjmp	.+6      	; 0xf70 <distance+0x5c>
		}
		else if(a=='b')
     f6a:	c2 36       	cpi	r28, 0x62	; 98
     f6c:	09 f4       	brne	.+2      	; 0xf70 <distance+0x5c>
		{
			PORTA=0b00001001;
     f6e:	12 b9       	out	0x02, r17	; 2

		}
		b=0.5413*right_position_encode; // feedback constant value
     f70:	60 91 61 02 	lds	r22, 0x0261
     f74:	70 91 62 02 	lds	r23, 0x0262
     f78:	80 91 63 02 	lds	r24, 0x0263
     f7c:	90 91 64 02 	lds	r25, 0x0264
     f80:	0e 94 9c 18 	call	0x3138	; 0x3138 <__floatunsisf>
     f84:	23 ea       	ldi	r18, 0xA3	; 163
     f86:	32 e9       	ldi	r19, 0x92	; 146
     f88:	4a e0       	ldi	r20, 0x0A	; 10
     f8a:	5f e3       	ldi	r21, 0x3F	; 63
     f8c:	0e 94 8e 19 	call	0x331c	; 0x331c <__mulsf3>
{
	sppeed(255,249);
	float b=0;
	right_position_encode=0; //clearing encoder value
	left_position_encode=0;
	while((ceil(b))<(cm))
     f90:	38 2f       	mov	r19, r24
     f92:	29 2f       	mov	r18, r25
     f94:	86 2f       	mov	r24, r22
     f96:	97 2f       	mov	r25, r23
     f98:	a3 2f       	mov	r26, r19
     f9a:	b2 2f       	mov	r27, r18
     f9c:	bc 01       	movw	r22, r24
     f9e:	cd 01       	movw	r24, r26
     fa0:	0e 94 ec 17 	call	0x2fd8	; 0x2fd8 <ceil>
     fa4:	a7 01       	movw	r20, r14
     fa6:	96 01       	movw	r18, r12
     fa8:	0e 94 ff 17 	call	0x2ffe	; 0x2ffe <__cmpsf2>
     fac:	88 23       	and	r24, r24
     fae:	cc f2       	brlt	.-78     	; 0xf62 <distance+0x4e>
			PORTA=0b00001001;

		}
		b=0.5413*right_position_encode; // feedback constant value
	}
	stop();
     fb0:	0e 94 10 08 	call	0x1020	; 0x1020 <stop>
}
     fb4:	df 91       	pop	r29
     fb6:	cf 91       	pop	r28
     fb8:	1f 91       	pop	r17
     fba:	ff 90       	pop	r15
     fbc:	ef 90       	pop	r14
     fbe:	df 90       	pop	r13
     fc0:	cf 90       	pop	r12
     fc2:	08 95       	ret

00000fc4 <motion_pin_config>:
*
*/

void motion_pin_config (void)
{
	DDRA = DDRA | 0x0F;
     fc4:	81 b1       	in	r24, 0x01	; 1
     fc6:	8f 60       	ori	r24, 0x0F	; 15
     fc8:	81 b9       	out	0x01, r24	; 1
	PORTA = PORTA & 0xF0;
     fca:	82 b1       	in	r24, 0x02	; 2
     fcc:	80 7f       	andi	r24, 0xF0	; 240
     fce:	82 b9       	out	0x02, r24	; 2
	DDRL = DDRL | 0x18;			//Setting PL3 and PL4 pins as output for PWM generation
     fd0:	ea e0       	ldi	r30, 0x0A	; 10
     fd2:	f1 e0       	ldi	r31, 0x01	; 1
     fd4:	80 81       	ld	r24, Z
     fd6:	88 61       	ori	r24, 0x18	; 24
     fd8:	80 83       	st	Z, r24
	PORTL = PORTL | 0x18;		//PL3 and PL4 pins are for velocity control using PWM.
     fda:	eb e0       	ldi	r30, 0x0B	; 11
     fdc:	f1 e0       	ldi	r31, 0x01	; 1
     fde:	80 81       	ld	r24, Z
     fe0:	88 61       	ori	r24, 0x18	; 24
     fe2:	80 83       	st	Z, r24
	OCR5A=0x00FF;
     fe4:	8f ef       	ldi	r24, 0xFF	; 255
     fe6:	90 e0       	ldi	r25, 0x00	; 0
     fe8:	90 93 29 01 	sts	0x0129, r25
     fec:	80 93 28 01 	sts	0x0128, r24
	OCR5B=0x00FF;
     ff0:	90 93 2b 01 	sts	0x012B, r25
     ff4:	80 93 2a 01 	sts	0x012A, r24
}
     ff8:	08 95       	ret

00000ffa <left_encoder_pin_config>:
*
*/

void left_encoder_pin_config (void)
{
	DDRE  = DDRE & 0xEF;  //Set the direction of the PORTE 4 pin as input
     ffa:	6c 98       	cbi	0x0d, 4	; 13
	PORTE = PORTE | 0x10; //Enable internal pull-up for PORTE 4 pin
     ffc:	74 9a       	sbi	0x0e, 4	; 14
}
     ffe:	08 95       	ret

00001000 <right_encoder_pin_config>:
*
*/

void right_encoder_pin_config (void)
{
	DDRE  = DDRE & 0xDF;		//Set the direction of the PORTE 4 pin as input
    1000:	6d 98       	cbi	0x0d, 5	; 13
	PORTE = PORTE | 0x20;		//Enable internal pull-up for PORTE 4 pin
    1002:	75 9a       	sbi	0x0e, 5	; 14
}
    1004:	08 95       	ret

00001006 <port_init>:
*
*/

void port_init()
{
	motion_pin_config(); //robot motion pins config
    1006:	0e 94 e2 07 	call	0xfc4	; 0xfc4 <motion_pin_config>
	left_encoder_pin_config(); //left encoder pin config
    100a:	0e 94 fd 07 	call	0xffa	; 0xffa <left_encoder_pin_config>
	right_encoder_pin_config(); //right encoder pin config
    100e:	0e 94 00 08 	call	0x1000	; 0x1000 <right_encoder_pin_config>
}
    1012:	08 95       	ret

00001014 <motion_set>:
void motion_set (unsigned char Direction)
{
	unsigned char PortARestore = 0;

	Direction &= 0x0F; 						// removing upper nibble for the protection
	PortARestore = PORTA; 					// reading the PORTA original status
    1014:	92 b1       	in	r25, 0x02	; 2
	PortARestore &= 0xF0; 					// making lower direction nibble to 0
    1016:	90 7f       	andi	r25, 0xF0	; 240

void motion_set (unsigned char Direction)
{
	unsigned char PortARestore = 0;

	Direction &= 0x0F; 						// removing upper nibble for the protection
    1018:	8f 70       	andi	r24, 0x0F	; 15
	PortARestore = PORTA; 					// reading the PORTA original status
	PortARestore &= 0xF0; 					// making lower direction nibble to 0
	PortARestore |= Direction;				// adding lower nibble for forward command and restoring the PORTA status
    101a:	98 2b       	or	r25, r24
	PORTA = PortARestore; 					// executing the command
    101c:	92 b9       	out	0x02, r25	; 2
}
    101e:	08 95       	ret

00001020 <stop>:
*
*/

void stop (void)
{
	motion_set(0x00);
    1020:	80 e0       	ldi	r24, 0x00	; 0
    1022:	0e 94 0a 08 	call	0x1014	; 0x1014 <motion_set>
	//_delay_ms(1000);
}
    1026:	08 95       	ret

00001028 <left>:
*
*/

void left (void) 
{
	motion_set(0x05);
    1028:	85 e0       	ldi	r24, 0x05	; 5
    102a:	0e 94 0a 08 	call	0x1014	; 0x1014 <motion_set>
}
    102e:	08 95       	ret

00001030 <right>:
*
*/

void right (void) 
{
	motion_set(0x0A);
    1030:	8a e0       	ldi	r24, 0x0A	; 10
    1032:	0e 94 0a 08 	call	0x1014	; 0x1014 <motion_set>
}
    1036:	08 95       	ret

00001038 <soft_left>:
*
*/

void soft_left (void) 
{
	motion_set(0x04);
    1038:	84 e0       	ldi	r24, 0x04	; 4
    103a:	0e 94 0a 08 	call	0x1014	; 0x1014 <motion_set>
}
    103e:	08 95       	ret

00001040 <soft_right>:
*
*/

void soft_right (void) 
{
	motion_set(0x02);
    1040:	82 e0       	ldi	r24, 0x02	; 2
    1042:	0e 94 0a 08 	call	0x1014	; 0x1014 <motion_set>
}
    1046:	08 95       	ret

00001048 <angle_rotate>:
* Example Call:				angle_rotate(90);
*
*/

void angle_rotate(unsigned int Degrees)
{
    1048:	0f 93       	push	r16
    104a:	1f 93       	push	r17
    104c:	cf 93       	push	r28
    104e:	df 93       	push	r29
    1050:	ec 01       	movw	r28, r24
	sppeed(255,249);  //sets the speed of motors
    1052:	8f ef       	ldi	r24, 0xFF	; 255
    1054:	90 e0       	ldi	r25, 0x00	; 0
    1056:	69 ef       	ldi	r22, 0xF9	; 249
    1058:	70 e0       	ldi	r23, 0x00	; 0
    105a:	0e 94 f7 00 	call	0x1ee	; 0x1ee <sppeed>
	float ReqdShaftCount = 0;
	unsigned long int ReqdShaftCountInt = 0;
	if(node_number==15 || node_number==16 || node_number==17)
    105e:	80 91 5f 02 	lds	r24, 0x025F
    1062:	90 91 60 02 	lds	r25, 0x0260
    1066:	0f 97       	sbiw	r24, 0x0f	; 15
    1068:	83 30       	cpi	r24, 0x03	; 3
    106a:	91 05       	cpc	r25, r1
    106c:	60 f4       	brcc	.+24     	; 0x1086 <angle_rotate+0x3e>
	ReqdShaftCount = (float) Degrees/ 4.60;
    106e:	be 01       	movw	r22, r28
    1070:	80 e0       	ldi	r24, 0x00	; 0
    1072:	90 e0       	ldi	r25, 0x00	; 0
    1074:	0e 94 9c 18 	call	0x3138	; 0x3138 <__floatunsisf>
    1078:	23 e3       	ldi	r18, 0x33	; 51
    107a:	33 e3       	ldi	r19, 0x33	; 51
    107c:	43 e9       	ldi	r20, 0x93	; 147
    107e:	50 e4       	ldi	r21, 0x40	; 64
    1080:	0e 94 03 18 	call	0x3006	; 0x3006 <__divsf3>
    1084:	0b c0       	rjmp	.+22     	; 0x109c <angle_rotate+0x54>
	else
	ReqdShaftCount = (float) Degrees/ 4.090; // division by resolution to get shaft count
    1086:	be 01       	movw	r22, r28
    1088:	80 e0       	ldi	r24, 0x00	; 0
    108a:	90 e0       	ldi	r25, 0x00	; 0
    108c:	0e 94 9c 18 	call	0x3138	; 0x3138 <__floatunsisf>
    1090:	28 e4       	ldi	r18, 0x48	; 72
    1092:	31 ee       	ldi	r19, 0xE1	; 225
    1094:	42 e8       	ldi	r20, 0x82	; 130
    1096:	50 e4       	ldi	r21, 0x40	; 64
    1098:	0e 94 03 18 	call	0x3006	; 0x3006 <__divsf3>
	ReqdShaftCountInt = (unsigned int) ReqdShaftCount;
    109c:	38 2f       	mov	r19, r24
    109e:	29 2f       	mov	r18, r25
    10a0:	86 2f       	mov	r24, r22
    10a2:	97 2f       	mov	r25, r23
    10a4:	a3 2f       	mov	r26, r19
    10a6:	b2 2f       	mov	r27, r18
    10a8:	bc 01       	movw	r22, r24
    10aa:	cd 01       	movw	r24, r26
    10ac:	0e 94 70 18 	call	0x30e0	; 0x30e0 <__fixunssfsi>
    10b0:	dc 01       	movw	r26, r24
    10b2:	cb 01       	movw	r24, r22
    10b4:	a0 e0       	ldi	r26, 0x00	; 0
    10b6:	b0 e0       	ldi	r27, 0x00	; 0
	right_position_encode = 0;
    10b8:	10 92 61 02 	sts	0x0261, r1
    10bc:	10 92 62 02 	sts	0x0262, r1
    10c0:	10 92 63 02 	sts	0x0263, r1
    10c4:	10 92 64 02 	sts	0x0264, r1
	left_position_encode = 0;
    10c8:	10 92 65 02 	sts	0x0265, r1
    10cc:	10 92 66 02 	sts	0x0266, r1
    10d0:	10 92 67 02 	sts	0x0267, r1
    10d4:	10 92 68 02 	sts	0x0268, r1
	while (1)
	{
		if((right_position_encode >= ReqdShaftCountInt) | (left_position_encode >= ReqdShaftCountInt))
    10d8:	f1 e0       	ldi	r31, 0x01	; 1
    10da:	c0 e0       	ldi	r28, 0x00	; 0
    10dc:	40 91 61 02 	lds	r20, 0x0261
    10e0:	50 91 62 02 	lds	r21, 0x0262
    10e4:	60 91 63 02 	lds	r22, 0x0263
    10e8:	70 91 64 02 	lds	r23, 0x0264
    10ec:	00 91 65 02 	lds	r16, 0x0265
    10f0:	10 91 66 02 	lds	r17, 0x0266
    10f4:	20 91 67 02 	lds	r18, 0x0267
    10f8:	30 91 68 02 	lds	r19, 0x0268
    10fc:	ef 2f       	mov	r30, r31
    10fe:	48 17       	cp	r20, r24
    1100:	59 07       	cpc	r21, r25
    1102:	6a 07       	cpc	r22, r26
    1104:	7b 07       	cpc	r23, r27
    1106:	08 f4       	brcc	.+2      	; 0x110a <angle_rotate+0xc2>
    1108:	ec 2f       	mov	r30, r28
    110a:	ee 23       	and	r30, r30
    110c:	49 f4       	brne	.+18     	; 0x1120 <angle_rotate+0xd8>
    110e:	4f 2f       	mov	r20, r31
    1110:	08 17       	cp	r16, r24
    1112:	19 07       	cpc	r17, r25
    1114:	2a 07       	cpc	r18, r26
    1116:	3b 07       	cpc	r19, r27
    1118:	08 f4       	brcc	.+2      	; 0x111c <angle_rotate+0xd4>
    111a:	4c 2f       	mov	r20, r28
    111c:	44 23       	and	r20, r20
    111e:	f1 f2       	breq	.-68     	; 0x10dc <angle_rotate+0x94>
		break;
	}
	stop(); //Stop robot
    1120:	0e 94 10 08 	call	0x1020	; 0x1020 <stop>
	navigate();   //navigate the bot after rotating
    1124:	0e 94 55 04 	call	0x8aa	; 0x8aa <navigate>
}
    1128:	df 91       	pop	r29
    112a:	cf 91       	pop	r28
    112c:	1f 91       	pop	r17
    112e:	0f 91       	pop	r16
    1130:	08 95       	ret

00001132 <left_degrees>:
* Example Call:				left_degrees(90);
*
*/

void left_degrees(unsigned int Degrees)
{
    1132:	ef 92       	push	r14
    1134:	ff 92       	push	r15
    1136:	0f 93       	push	r16
    1138:	1f 93       	push	r17
    113a:	cf 93       	push	r28
    113c:	df 93       	push	r29
    113e:	ec 01       	movw	r28, r24
	// 88 pulses for 360 degrees rotation 4.090 degrees per count
	navigation_in_degrees = navigation_in_degrees + Degrees;
    1140:	80 91 3d 02 	lds	r24, 0x023D
    1144:	90 91 3e 02 	lds	r25, 0x023E
    1148:	8c 0f       	add	r24, r28
    114a:	9d 1f       	adc	r25, r29
    114c:	90 93 3e 02 	sts	0x023E, r25
    1150:	80 93 3d 02 	sts	0x023D, r24
	left(); //Turn left
    1154:	0e 94 14 08 	call	0x1028	; 0x1028 <left>
	angle_rotate(Degrees);
    1158:	ce 01       	movw	r24, r28
    115a:	0e 94 24 08 	call	0x1048	; 0x1048 <angle_rotate>
	while(digital[2]<15 && digital[1]<15 && digital[3]<15)
    115e:	80 91 3c 05 	lds	r24, 0x053C
    1162:	90 91 3d 05 	lds	r25, 0x053D
    1166:	8f 30       	cpi	r24, 0x0F	; 15
    1168:	91 05       	cpc	r25, r1
    116a:	08 f0       	brcs	.+2      	; 0x116e <left_degrees+0x3c>
    116c:	40 c0       	rjmp	.+128    	; 0x11ee <left_degrees+0xbc>
    116e:	80 91 3a 05 	lds	r24, 0x053A
    1172:	90 91 3b 05 	lds	r25, 0x053B
    1176:	8f 30       	cpi	r24, 0x0F	; 15
    1178:	91 05       	cpc	r25, r1
    117a:	c8 f5       	brcc	.+114    	; 0x11ee <left_degrees+0xbc>
    117c:	80 91 3e 05 	lds	r24, 0x053E
    1180:	90 91 3f 05 	lds	r25, 0x053F
    1184:	8f 30       	cpi	r24, 0x0F	; 15
    1186:	91 05       	cpc	r25, r1
    1188:	90 f5       	brcc	.+100    	; 0x11ee <left_degrees+0xbc>
    118a:	cc e3       	ldi	r28, 0x3C	; 60
    118c:	d5 e0       	ldi	r29, 0x05	; 5
    118e:	0a e3       	ldi	r16, 0x3A	; 58
    1190:	15 e0       	ldi	r17, 0x05	; 5
    1192:	0f 2e       	mov	r0, r31
    1194:	fe e3       	ldi	r31, 0x3E	; 62
    1196:	ef 2e       	mov	r14, r31
    1198:	f5 e0       	ldi	r31, 0x05	; 5
    119a:	ff 2e       	mov	r15, r31
    119c:	f0 2d       	mov	r31, r0
	{
		sppeed(255,249);
    119e:	8f ef       	ldi	r24, 0xFF	; 255
    11a0:	90 e0       	ldi	r25, 0x00	; 0
    11a2:	69 ef       	ldi	r22, 0xF9	; 249
    11a4:	70 e0       	ldi	r23, 0x00	; 0
    11a6:	0e 94 f7 00 	call	0x1ee	; 0x1ee <sppeed>
		if(node_number==10 || node_number==0)
    11aa:	80 91 5f 02 	lds	r24, 0x025F
    11ae:	90 91 60 02 	lds	r25, 0x0260
    11b2:	8a 30       	cpi	r24, 0x0A	; 10
    11b4:	91 05       	cpc	r25, r1
    11b6:	11 f0       	breq	.+4      	; 0x11bc <left_degrees+0x8a>
    11b8:	00 97       	sbiw	r24, 0x00	; 0
    11ba:	31 f4       	brne	.+12     	; 0x11c8 <left_degrees+0x96>
		sppeed(180,174);
    11bc:	84 eb       	ldi	r24, 0xB4	; 180
    11be:	90 e0       	ldi	r25, 0x00	; 0
    11c0:	6e ea       	ldi	r22, 0xAE	; 174
    11c2:	70 e0       	ldi	r23, 0x00	; 0
    11c4:	0e 94 f7 00 	call	0x1ee	; 0x1ee <sppeed>
		left();
    11c8:	0e 94 14 08 	call	0x1028	; 0x1028 <left>
{
	// 88 pulses for 360 degrees rotation 4.090 degrees per count
	navigation_in_degrees = navigation_in_degrees + Degrees;
	left(); //Turn left
	angle_rotate(Degrees);
	while(digital[2]<15 && digital[1]<15 && digital[3]<15)
    11cc:	88 81       	ld	r24, Y
    11ce:	99 81       	ldd	r25, Y+1	; 0x01
    11d0:	8f 30       	cpi	r24, 0x0F	; 15
    11d2:	91 05       	cpc	r25, r1
    11d4:	60 f4       	brcc	.+24     	; 0x11ee <left_degrees+0xbc>
    11d6:	f8 01       	movw	r30, r16
    11d8:	80 81       	ld	r24, Z
    11da:	91 81       	ldd	r25, Z+1	; 0x01
    11dc:	8f 30       	cpi	r24, 0x0F	; 15
    11de:	91 05       	cpc	r25, r1
    11e0:	30 f4       	brcc	.+12     	; 0x11ee <left_degrees+0xbc>
    11e2:	f7 01       	movw	r30, r14
    11e4:	80 81       	ld	r24, Z
    11e6:	91 81       	ldd	r25, Z+1	; 0x01
    11e8:	8f 30       	cpi	r24, 0x0F	; 15
    11ea:	91 05       	cpc	r25, r1
    11ec:	c0 f2       	brcs	.-80     	; 0x119e <left_degrees+0x6c>
		sppeed(255,249);
		if(node_number==10 || node_number==0)
		sppeed(180,174);
		left();
	}
	stop();
    11ee:	0e 94 10 08 	call	0x1020	; 0x1020 <stop>
}
    11f2:	df 91       	pop	r29
    11f4:	cf 91       	pop	r28
    11f6:	1f 91       	pop	r17
    11f8:	0f 91       	pop	r16
    11fa:	ff 90       	pop	r15
    11fc:	ef 90       	pop	r14
    11fe:	08 95       	ret

00001200 <right_degrees>:
* Example Call:				right_degrees(90);
*
*/

void right_degrees(unsigned int Degrees)
{
    1200:	ef 92       	push	r14
    1202:	ff 92       	push	r15
    1204:	0f 93       	push	r16
    1206:	1f 93       	push	r17
    1208:	cf 93       	push	r28
    120a:	df 93       	push	r29
    120c:	ec 01       	movw	r28, r24
	// 88 pulses for 360 degrees rotation 4.090 degrees per count
	navigation_in_degrees=navigation_in_degrees-Degrees;
    120e:	80 91 3d 02 	lds	r24, 0x023D
    1212:	90 91 3e 02 	lds	r25, 0x023E
    1216:	8c 1b       	sub	r24, r28
    1218:	9d 0b       	sbc	r25, r29
    121a:	90 93 3e 02 	sts	0x023E, r25
    121e:	80 93 3d 02 	sts	0x023D, r24
	right(); //Turn right
    1222:	0e 94 18 08 	call	0x1030	; 0x1030 <right>
	angle_rotate(Degrees);
    1226:	ce 01       	movw	r24, r28
    1228:	0e 94 24 08 	call	0x1048	; 0x1048 <angle_rotate>
	while(digital[2]<15 && digital[3]<15 && digital[1]<15)
    122c:	80 91 3c 05 	lds	r24, 0x053C
    1230:	90 91 3d 05 	lds	r25, 0x053D
    1234:	8f 30       	cpi	r24, 0x0F	; 15
    1236:	91 05       	cpc	r25, r1
    1238:	08 f0       	brcs	.+2      	; 0x123c <right_degrees+0x3c>
    123a:	40 c0       	rjmp	.+128    	; 0x12bc <right_degrees+0xbc>
    123c:	80 91 3e 05 	lds	r24, 0x053E
    1240:	90 91 3f 05 	lds	r25, 0x053F
    1244:	8f 30       	cpi	r24, 0x0F	; 15
    1246:	91 05       	cpc	r25, r1
    1248:	c8 f5       	brcc	.+114    	; 0x12bc <right_degrees+0xbc>
    124a:	80 91 3a 05 	lds	r24, 0x053A
    124e:	90 91 3b 05 	lds	r25, 0x053B
    1252:	8f 30       	cpi	r24, 0x0F	; 15
    1254:	91 05       	cpc	r25, r1
    1256:	90 f5       	brcc	.+100    	; 0x12bc <right_degrees+0xbc>
    1258:	cc e3       	ldi	r28, 0x3C	; 60
    125a:	d5 e0       	ldi	r29, 0x05	; 5
    125c:	0e e3       	ldi	r16, 0x3E	; 62
    125e:	15 e0       	ldi	r17, 0x05	; 5
    1260:	0f 2e       	mov	r0, r31
    1262:	fa e3       	ldi	r31, 0x3A	; 58
    1264:	ef 2e       	mov	r14, r31
    1266:	f5 e0       	ldi	r31, 0x05	; 5
    1268:	ff 2e       	mov	r15, r31
    126a:	f0 2d       	mov	r31, r0
	{
		sppeed(255,249);
    126c:	8f ef       	ldi	r24, 0xFF	; 255
    126e:	90 e0       	ldi	r25, 0x00	; 0
    1270:	69 ef       	ldi	r22, 0xF9	; 249
    1272:	70 e0       	ldi	r23, 0x00	; 0
    1274:	0e 94 f7 00 	call	0x1ee	; 0x1ee <sppeed>
		if(node_number==10 || node_number==0)
    1278:	80 91 5f 02 	lds	r24, 0x025F
    127c:	90 91 60 02 	lds	r25, 0x0260
    1280:	8a 30       	cpi	r24, 0x0A	; 10
    1282:	91 05       	cpc	r25, r1
    1284:	11 f0       	breq	.+4      	; 0x128a <right_degrees+0x8a>
    1286:	00 97       	sbiw	r24, 0x00	; 0
    1288:	31 f4       	brne	.+12     	; 0x1296 <right_degrees+0x96>
		sppeed(180,174);
    128a:	84 eb       	ldi	r24, 0xB4	; 180
    128c:	90 e0       	ldi	r25, 0x00	; 0
    128e:	6e ea       	ldi	r22, 0xAE	; 174
    1290:	70 e0       	ldi	r23, 0x00	; 0
    1292:	0e 94 f7 00 	call	0x1ee	; 0x1ee <sppeed>
		right();
    1296:	0e 94 18 08 	call	0x1030	; 0x1030 <right>
{
	// 88 pulses for 360 degrees rotation 4.090 degrees per count
	navigation_in_degrees=navigation_in_degrees-Degrees;
	right(); //Turn right
	angle_rotate(Degrees);
	while(digital[2]<15 && digital[3]<15 && digital[1]<15)
    129a:	88 81       	ld	r24, Y
    129c:	99 81       	ldd	r25, Y+1	; 0x01
    129e:	8f 30       	cpi	r24, 0x0F	; 15
    12a0:	91 05       	cpc	r25, r1
    12a2:	60 f4       	brcc	.+24     	; 0x12bc <right_degrees+0xbc>
    12a4:	f8 01       	movw	r30, r16
    12a6:	80 81       	ld	r24, Z
    12a8:	91 81       	ldd	r25, Z+1	; 0x01
    12aa:	8f 30       	cpi	r24, 0x0F	; 15
    12ac:	91 05       	cpc	r25, r1
    12ae:	30 f4       	brcc	.+12     	; 0x12bc <right_degrees+0xbc>
    12b0:	f7 01       	movw	r30, r14
    12b2:	80 81       	ld	r24, Z
    12b4:	91 81       	ldd	r25, Z+1	; 0x01
    12b6:	8f 30       	cpi	r24, 0x0F	; 15
    12b8:	91 05       	cpc	r25, r1
    12ba:	c0 f2       	brcs	.-80     	; 0x126c <right_degrees+0x6c>
		sppeed(255,249);
		if(node_number==10 || node_number==0)
		sppeed(180,174);
		right();
	}
	stop();
    12bc:	0e 94 10 08 	call	0x1020	; 0x1020 <stop>
}
    12c0:	df 91       	pop	r29
    12c2:	cf 91       	pop	r28
    12c4:	1f 91       	pop	r17
    12c6:	0f 91       	pop	r16
    12c8:	ff 90       	pop	r15
    12ca:	ef 90       	pop	r14
    12cc:	08 95       	ret

000012ce <soft_left_degrees>:
* Example Call:				soft_left_degrees(90);
*
*/

void soft_left_degrees(unsigned int Degrees)
{
    12ce:	cf 93       	push	r28
    12d0:	df 93       	push	r29
    12d2:	ec 01       	movw	r28, r24
	navigation_in_degrees=navigation_in_degrees+Degrees;
    12d4:	80 91 3d 02 	lds	r24, 0x023D
    12d8:	90 91 3e 02 	lds	r25, 0x023E
    12dc:	8c 0f       	add	r24, r28
    12de:	9d 1f       	adc	r25, r29
    12e0:	90 93 3e 02 	sts	0x023E, r25
    12e4:	80 93 3d 02 	sts	0x023D, r24
	// 176 pulses for 360 degrees rotation 2.045 degrees per count
	soft_left(); //Turn soft left
    12e8:	0e 94 1c 08 	call	0x1038	; 0x1038 <soft_left>
	Degrees=Degrees*2;
	angle_rotate(Degrees);
    12ec:	ce 01       	movw	r24, r28
    12ee:	88 0f       	add	r24, r24
    12f0:	99 1f       	adc	r25, r25
    12f2:	0e 94 24 08 	call	0x1048	; 0x1048 <angle_rotate>
}
    12f6:	df 91       	pop	r29
    12f8:	cf 91       	pop	r28
    12fa:	08 95       	ret

000012fc <soft_right_degrees>:
* Example Call:				soft_right_degrees(90);
*
*/

void soft_right_degrees(unsigned int Degrees)
{
    12fc:	cf 93       	push	r28
    12fe:	df 93       	push	r29
    1300:	ec 01       	movw	r28, r24
	navigation_in_degrees=navigation_in_degrees-Degrees;
    1302:	80 91 3d 02 	lds	r24, 0x023D
    1306:	90 91 3e 02 	lds	r25, 0x023E
    130a:	8c 1b       	sub	r24, r28
    130c:	9d 0b       	sbc	r25, r29
    130e:	90 93 3e 02 	sts	0x023E, r25
    1312:	80 93 3d 02 	sts	0x023D, r24
	// 176 pulses for 360 degrees rotation 2.045 degrees per count
	soft_right();  //Turn soft right
    1316:	0e 94 20 08 	call	0x1040	; 0x1040 <soft_right>
	Degrees=Degrees*2;
	angle_rotate(Degrees);
    131a:	ce 01       	movw	r24, r28
    131c:	88 0f       	add	r24, r24
    131e:	99 1f       	adc	r25, r25
    1320:	0e 94 24 08 	call	0x1048	; 0x1048 <angle_rotate>
}
    1324:	df 91       	pop	r29
    1326:	cf 91       	pop	r28
    1328:	08 95       	ret

0000132a <INT_position>:
*
*/

void INT_position(void)
{
	cli(); //Clears the global interrupt
    132a:	f8 94       	cli
	port_init();  //Initializes all the ports
    132c:	0e 94 03 08 	call	0x1006	; 0x1006 <port_init>
	EICRB = EICRB | 0x08; // INT5 is set to trigger with falling edge
    1330:	ea e6       	ldi	r30, 0x6A	; 106
    1332:	f0 e0       	ldi	r31, 0x00	; 0
    1334:	80 81       	ld	r24, Z
    1336:	88 60       	ori	r24, 0x08	; 8
    1338:	80 83       	st	Z, r24
	EIMSK = EIMSK | 0x20; // Enable Interrupt INT5 for right position encoder
    133a:	ed 9a       	sbi	0x1d, 5	; 29
	EICRB = EICRB | 0x02; // INT4 is set to trigger with falling edge
    133c:	80 81       	ld	r24, Z
    133e:	82 60       	ori	r24, 0x02	; 2
    1340:	80 83       	st	Z, r24
	EIMSK = EIMSK | 0x10; // Enable Interrupt INT4 for left position encoder
    1342:	ec 9a       	sbi	0x1d, 4	; 29
	sei();   // Enables the global interrupt
    1344:	78 94       	sei
}
    1346:	08 95       	ret

00001348 <servo_config>:
*
*/

void servo_config(void)
{
	cli();
    1348:	f8 94       	cli
	TCNT1=0x0000;							// set starting value of counter
    134a:	10 92 85 00 	sts	0x0085, r1
    134e:	10 92 84 00 	sts	0x0084, r1
	ICR1=1150;								// set top value of counter
    1352:	8e e7       	ldi	r24, 0x7E	; 126
    1354:	94 e0       	ldi	r25, 0x04	; 4
    1356:	90 93 87 00 	sts	0x0087, r25
    135a:	80 93 86 00 	sts	0x0086, r24
	TCCR1A=0b10101010;						// counter configuring
    135e:	2a ea       	ldi	r18, 0xAA	; 170
    1360:	20 93 80 00 	sts	0x0080, r18
	TCCR1B=0b00011100;
    1364:	2c e1       	ldi	r18, 0x1C	; 28
    1366:	20 93 81 00 	sts	0x0081, r18
	DDRB=DDRB|0b11100000;					// set Output Compare pins as output pins
    136a:	24 b1       	in	r18, 0x04	; 4
    136c:	20 6e       	ori	r18, 0xE0	; 224
    136e:	24 b9       	out	0x04, r18	; 4
	PORTB=PORTB|0b1110000;
    1370:	25 b1       	in	r18, 0x05	; 5
    1372:	20 67       	ori	r18, 0x70	; 112
    1374:	25 b9       	out	0x05, r18	; 5
	OCR1A=1150;								// to free the servo
    1376:	90 93 89 00 	sts	0x0089, r25
    137a:	80 93 88 00 	sts	0x0088, r24
	OCR1B=1150;
    137e:	90 93 8b 00 	sts	0x008B, r25
    1382:	80 93 8a 00 	sts	0x008A, r24
	OCR1C=1150;
    1386:	90 93 8d 00 	sts	0x008D, r25
    138a:	80 93 8c 00 	sts	0x008C, r24
	sei();
    138e:	78 94       	sei
}
    1390:	08 95       	ret

00001392 <servo1_mov>:
* Example Call:					servo1_mov(10);
*
*/

void servo1_mov(int degree)
{
    1392:	cf 93       	push	r28
    1394:	df 93       	push	r29
    1396:	ec 01       	movw	r28, r24

	if(node_number==13)
    1398:	80 91 5f 02 	lds	r24, 0x025F
    139c:	90 91 60 02 	lds	r25, 0x0260
    13a0:	8d 30       	cpi	r24, 0x0D	; 13
    13a2:	91 05       	cpc	r25, r1
    13a4:	e1 f4       	brne	.+56     	; 0x13de <servo1_mov+0x4c>
	OCR1A=((degree/1.89)+25);
    13a6:	be 01       	movw	r22, r28
    13a8:	88 27       	eor	r24, r24
    13aa:	77 fd       	sbrc	r23, 7
    13ac:	80 95       	com	r24
    13ae:	98 2f       	mov	r25, r24
    13b0:	0e 94 9e 18 	call	0x313c	; 0x313c <__floatsisf>
    13b4:	25 e8       	ldi	r18, 0x85	; 133
    13b6:	3b ee       	ldi	r19, 0xEB	; 235
    13b8:	41 ef       	ldi	r20, 0xF1	; 241
    13ba:	5f e3       	ldi	r21, 0x3F	; 63
    13bc:	0e 94 03 18 	call	0x3006	; 0x3006 <__divsf3>
    13c0:	20 e0       	ldi	r18, 0x00	; 0
    13c2:	30 e0       	ldi	r19, 0x00	; 0
    13c4:	48 ec       	ldi	r20, 0xC8	; 200
    13c6:	51 e4       	ldi	r21, 0x41	; 65
    13c8:	0e 94 88 17 	call	0x2f10	; 0x2f10 <__addsf3>
    13cc:	0e 94 70 18 	call	0x30e0	; 0x30e0 <__fixunssfsi>
    13d0:	dc 01       	movw	r26, r24
    13d2:	cb 01       	movw	r24, r22
    13d4:	90 93 89 00 	sts	0x0089, r25
    13d8:	80 93 88 00 	sts	0x0088, r24
    13dc:	1d c0       	rjmp	.+58     	; 0x1418 <servo1_mov+0x86>
	else
	OCR1A=ceil(((degree/1.89)+25));
    13de:	be 01       	movw	r22, r28
    13e0:	88 27       	eor	r24, r24
    13e2:	77 fd       	sbrc	r23, 7
    13e4:	80 95       	com	r24
    13e6:	98 2f       	mov	r25, r24
    13e8:	0e 94 9e 18 	call	0x313c	; 0x313c <__floatsisf>
    13ec:	25 e8       	ldi	r18, 0x85	; 133
    13ee:	3b ee       	ldi	r19, 0xEB	; 235
    13f0:	41 ef       	ldi	r20, 0xF1	; 241
    13f2:	5f e3       	ldi	r21, 0x3F	; 63
    13f4:	0e 94 03 18 	call	0x3006	; 0x3006 <__divsf3>
    13f8:	20 e0       	ldi	r18, 0x00	; 0
    13fa:	30 e0       	ldi	r19, 0x00	; 0
    13fc:	48 ec       	ldi	r20, 0xC8	; 200
    13fe:	51 e4       	ldi	r21, 0x41	; 65
    1400:	0e 94 88 17 	call	0x2f10	; 0x2f10 <__addsf3>
    1404:	0e 94 ec 17 	call	0x2fd8	; 0x2fd8 <ceil>
    1408:	0e 94 70 18 	call	0x30e0	; 0x30e0 <__fixunssfsi>
    140c:	dc 01       	movw	r26, r24
    140e:	cb 01       	movw	r24, r22
    1410:	90 93 89 00 	sts	0x0089, r25
    1414:	80 93 88 00 	sts	0x0088, r24
	servo_angle_1=degree;
    1418:	d0 93 42 02 	sts	0x0242, r29
    141c:	c0 93 41 02 	sts	0x0241, r28
}
    1420:	df 91       	pop	r29
    1422:	cf 91       	pop	r28
    1424:	08 95       	ret

00001426 <servo2_mov>:
* Example Call:					servo2_mov(10);
*
*/

void servo2_mov(int degree)
{
    1426:	cf 93       	push	r28
    1428:	df 93       	push	r29
    142a:	ec 01       	movw	r28, r24
	OCR1B=ceil(((degree/1.89)+25));
    142c:	be 01       	movw	r22, r28
    142e:	88 27       	eor	r24, r24
    1430:	77 fd       	sbrc	r23, 7
    1432:	80 95       	com	r24
    1434:	98 2f       	mov	r25, r24
    1436:	0e 94 9e 18 	call	0x313c	; 0x313c <__floatsisf>
    143a:	25 e8       	ldi	r18, 0x85	; 133
    143c:	3b ee       	ldi	r19, 0xEB	; 235
    143e:	41 ef       	ldi	r20, 0xF1	; 241
    1440:	5f e3       	ldi	r21, 0x3F	; 63
    1442:	0e 94 03 18 	call	0x3006	; 0x3006 <__divsf3>
    1446:	20 e0       	ldi	r18, 0x00	; 0
    1448:	30 e0       	ldi	r19, 0x00	; 0
    144a:	48 ec       	ldi	r20, 0xC8	; 200
    144c:	51 e4       	ldi	r21, 0x41	; 65
    144e:	0e 94 88 17 	call	0x2f10	; 0x2f10 <__addsf3>
    1452:	0e 94 ec 17 	call	0x2fd8	; 0x2fd8 <ceil>
    1456:	0e 94 70 18 	call	0x30e0	; 0x30e0 <__fixunssfsi>
    145a:	dc 01       	movw	r26, r24
    145c:	cb 01       	movw	r24, r22
    145e:	90 93 8b 00 	sts	0x008B, r25
    1462:	80 93 8a 00 	sts	0x008A, r24
	servo_angle_2=degree;
    1466:	d0 93 40 02 	sts	0x0240, r29
    146a:	c0 93 3f 02 	sts	0x023F, r28
}
    146e:	df 91       	pop	r29
    1470:	cf 91       	pop	r28
    1472:	08 95       	ret

00001474 <servo1_free>:
*
*/

void servo1_free(void)
{
	OCR1A=1150;
    1474:	8e e7       	ldi	r24, 0x7E	; 126
    1476:	94 e0       	ldi	r25, 0x04	; 4
    1478:	90 93 89 00 	sts	0x0089, r25
    147c:	80 93 88 00 	sts	0x0088, r24
}
    1480:	08 95       	ret

00001482 <servo2_free>:
*
*/

void servo2_free(void)
{
	OCR1B=1150;
    1482:	8e e7       	ldi	r24, 0x7E	; 126
    1484:	94 e0       	ldi	r25, 0x04	; 4
    1486:	90 93 8b 00 	sts	0x008B, r25
    148a:	80 93 8a 00 	sts	0x008A, r24
}
    148e:	08 95       	ret

00001490 <pick_waste>:
*/


void pick_waste(void)
{
	servo2_mov(5);
    1490:	85 e0       	ldi	r24, 0x05	; 5
    1492:	90 e0       	ldi	r25, 0x00	; 0
    1494:	0e 94 13 0a 	call	0x1426	; 0x1426 <servo2_mov>
    1498:	8f ef       	ldi	r24, 0xFF	; 255
    149a:	9f ef       	ldi	r25, 0xFF	; 255
    149c:	ac e2       	ldi	r26, 0x2C	; 44
    149e:	81 50       	subi	r24, 0x01	; 1
    14a0:	90 40       	sbci	r25, 0x00	; 0
    14a2:	a0 40       	sbci	r26, 0x00	; 0
    14a4:	e1 f7       	brne	.-8      	; 0x149e <pick_waste+0xe>
    14a6:	00 c0       	rjmp	.+0      	; 0x14a8 <pick_waste+0x18>
    14a8:	00 00       	nop
	_delay_ms(1000);
}
    14aa:	08 95       	ret

000014ac <ADC_config>:
*/


void ADC_config(void)
{
	cli();
    14ac:	f8 94       	cli
	TCCR3A=0x00;
    14ae:	10 92 90 00 	sts	0x0090, r1
	TCCR3B=0x02; // with clock setting 8
    14b2:	82 e0       	ldi	r24, 0x02	; 2
    14b4:	80 93 91 00 	sts	0x0091, r24
	TCCR3C=0x00;
    14b8:	10 92 92 00 	sts	0x0092, r1
	TIMSK3=0x01; // to enable timer overflow interrupt
    14bc:	81 e0       	ldi	r24, 0x01	; 1
    14be:	80 93 71 00 	sts	0x0071, r24
	DDRF = 0x00; //set PORTF direction as input
    14c2:	10 ba       	out	0x10, r1	; 16
	PORTF = 0x00; //set PORTF pins floating
    14c4:	11 ba       	out	0x11, r1	; 17
	DDRK = 0x00; //set PORTK direction as input
    14c6:	10 92 07 01 	sts	0x0107, r1
	PORTK = 0x00; //set PORTK pins floating
    14ca:	10 92 08 01 	sts	0x0108, r1
	ADCSRA = 0x00;
    14ce:	ea e7       	ldi	r30, 0x7A	; 122
    14d0:	f0 e0       	ldi	r31, 0x00	; 0
    14d2:	10 82       	st	Z, r1
	ADCSRB = 0x00;		//MUX5 = 0
    14d4:	10 92 7b 00 	sts	0x007B, r1
	ADMUX = 0x20;		//Vref=5V external --- ADLAR=1 --- MUX4:0 = 0000
    14d8:	80 e2       	ldi	r24, 0x20	; 32
    14da:	80 93 7c 00 	sts	0x007C, r24
	ACSR = 0x80;
    14de:	80 e8       	ldi	r24, 0x80	; 128
    14e0:	80 bf       	out	0x30, r24	; 48
	ADCSRA = 0x86;		//ADEN=1 --- ADIE=1 --- ADPS2:0 = 1 1 0
    14e2:	86 e8       	ldi	r24, 0x86	; 134
    14e4:	80 83       	st	Z, r24
}
    14e6:	08 95       	ret

000014e8 <getdata>:
*/

int getdata(int Ch)
{
	int a;									//a -> digital value which stores the digital value of ADCH register
	if(Ch>7)
    14e8:	88 30       	cpi	r24, 0x08	; 8
    14ea:	91 05       	cpc	r25, r1
    14ec:	1c f0       	brlt	.+6      	; 0x14f4 <getdata+0xc>
	{
		ADCSRB = 0x08;
    14ee:	28 e0       	ldi	r18, 0x08	; 8
    14f0:	20 93 7b 00 	sts	0x007B, r18
	}
	Ch = Ch & 0x07;
    14f4:	87 70       	andi	r24, 0x07	; 7
    14f6:	90 70       	andi	r25, 0x00	; 0
	ADMUX= 0x20| Ch;
    14f8:	80 62       	ori	r24, 0x20	; 32
    14fa:	80 93 7c 00 	sts	0x007C, r24
	ADCSRA = ADCSRA | 0x40;		//Set start conversion bit
    14fe:	ea e7       	ldi	r30, 0x7A	; 122
    1500:	f0 e0       	ldi	r31, 0x00	; 0
    1502:	80 81       	ld	r24, Z
    1504:	80 64       	ori	r24, 0x40	; 64
    1506:	80 83       	st	Z, r24
	while((ADCSRA&0x10)==0);	//Wait for ADC conversion to complete
    1508:	80 81       	ld	r24, Z
    150a:	84 ff       	sbrs	r24, 4
    150c:	fd cf       	rjmp	.-6      	; 0x1508 <getdata+0x20>
	a=ADCH;
    150e:	80 91 79 00 	lds	r24, 0x0079
	ADCSRA = ADCSRA|0x10; //clear ADIF (ADC Interrupt Flag) by writing 1 to it
    1512:	ea e7       	ldi	r30, 0x7A	; 122
    1514:	f0 e0       	ldi	r31, 0x00	; 0
    1516:	90 81       	ld	r25, Z
    1518:	90 61       	ori	r25, 0x10	; 16
    151a:	90 83       	st	Z, r25
	ADCSRB = 0x00;
    151c:	10 92 7b 00 	sts	0x007B, r1
	return a;
}
    1520:	90 e0       	ldi	r25, 0x00	; 0
    1522:	08 95       	ret

00001524 <__vector_6>:
* Example Call:								NONE
*
*/

ISR(INT5_vect) 
{
    1524:	1f 92       	push	r1
    1526:	0f 92       	push	r0
    1528:	0f b6       	in	r0, 0x3f	; 63
    152a:	0f 92       	push	r0
    152c:	0b b6       	in	r0, 0x3b	; 59
    152e:	0f 92       	push	r0
    1530:	11 24       	eor	r1, r1
    1532:	0f 93       	push	r16
    1534:	1f 93       	push	r17
    1536:	2f 93       	push	r18
    1538:	3f 93       	push	r19
    153a:	4f 93       	push	r20
    153c:	5f 93       	push	r21
    153e:	6f 93       	push	r22
    1540:	7f 93       	push	r23
    1542:	8f 93       	push	r24
    1544:	9f 93       	push	r25
    1546:	af 93       	push	r26
    1548:	bf 93       	push	r27
    154a:	cf 93       	push	r28
    154c:	df 93       	push	r29
    154e:	ef 93       	push	r30
    1550:	ff 93       	push	r31
	int i=0;
	right_position_encode++;
    1552:	80 91 61 02 	lds	r24, 0x0261
    1556:	90 91 62 02 	lds	r25, 0x0262
    155a:	a0 91 63 02 	lds	r26, 0x0263
    155e:	b0 91 64 02 	lds	r27, 0x0264
    1562:	01 96       	adiw	r24, 0x01	; 1
    1564:	a1 1d       	adc	r26, r1
    1566:	b1 1d       	adc	r27, r1
    1568:	80 93 61 02 	sts	0x0261, r24
    156c:	90 93 62 02 	sts	0x0262, r25
    1570:	a0 93 63 02 	sts	0x0263, r26
    1574:	b0 93 64 02 	sts	0x0264, r27
	if(abs(navigation_in_degrees)==360)
    1578:	80 91 3d 02 	lds	r24, 0x023D
    157c:	90 91 3e 02 	lds	r25, 0x023E
    1580:	99 23       	and	r25, r25
    1582:	1c f4       	brge	.+6      	; 0x158a <__vector_6+0x66>
    1584:	90 95       	com	r25
    1586:	81 95       	neg	r24
    1588:	9f 4f       	sbci	r25, 0xFF	; 255
    158a:	21 e0       	ldi	r18, 0x01	; 1
    158c:	88 36       	cpi	r24, 0x68	; 104
    158e:	92 07       	cpc	r25, r18
    1590:	21 f4       	brne	.+8      	; 0x159a <__vector_6+0x76>
	navigation_in_degrees=0;
    1592:	10 92 3e 02 	sts	0x023E, r1
    1596:	10 92 3d 02 	sts	0x023D, r1
* Example Call:								NONE
*
*/

ISR(INT5_vect) 
{
    159a:	c0 e0       	ldi	r28, 0x00	; 0
    159c:	d0 e0       	ldi	r29, 0x00	; 0
	right_position_encode++;
	if(abs(navigation_in_degrees)==360)
	navigation_in_degrees=0;
	//i: will iterate from 0 to the channel length
	for(i=0;i<16;i++)
	digital[i]=getdata(i);
    159e:	08 e3       	ldi	r16, 0x38	; 56
    15a0:	15 e0       	ldi	r17, 0x05	; 5
    15a2:	ce 01       	movw	r24, r28
    15a4:	0e 94 74 0a 	call	0x14e8	; 0x14e8 <getdata>
    15a8:	28 2f       	mov	r18, r24
    15aa:	39 2f       	mov	r19, r25
    15ac:	fe 01       	movw	r30, r28
    15ae:	ee 0f       	add	r30, r30
    15b0:	ff 1f       	adc	r31, r31
    15b2:	e0 0f       	add	r30, r16
    15b4:	f1 1f       	adc	r31, r17
    15b6:	31 83       	std	Z+1, r19	; 0x01
    15b8:	20 83       	st	Z, r18
	int i=0;
	right_position_encode++;
	if(abs(navigation_in_degrees)==360)
	navigation_in_degrees=0;
	//i: will iterate from 0 to the channel length
	for(i=0;i<16;i++)
    15ba:	21 96       	adiw	r28, 0x01	; 1
    15bc:	c0 31       	cpi	r28, 0x10	; 16
    15be:	d1 05       	cpc	r29, r1
    15c0:	81 f7       	brne	.-32     	; 0x15a2 <__vector_6+0x7e>
	digital[i]=getdata(i);
}
    15c2:	ff 91       	pop	r31
    15c4:	ef 91       	pop	r30
    15c6:	df 91       	pop	r29
    15c8:	cf 91       	pop	r28
    15ca:	bf 91       	pop	r27
    15cc:	af 91       	pop	r26
    15ce:	9f 91       	pop	r25
    15d0:	8f 91       	pop	r24
    15d2:	7f 91       	pop	r23
    15d4:	6f 91       	pop	r22
    15d6:	5f 91       	pop	r21
    15d8:	4f 91       	pop	r20
    15da:	3f 91       	pop	r19
    15dc:	2f 91       	pop	r18
    15de:	1f 91       	pop	r17
    15e0:	0f 91       	pop	r16
    15e2:	0f 90       	pop	r0
    15e4:	0b be       	out	0x3b, r0	; 59
    15e6:	0f 90       	pop	r0
    15e8:	0f be       	out	0x3f, r0	; 63
    15ea:	0f 90       	pop	r0
    15ec:	1f 90       	pop	r1
    15ee:	18 95       	reti

000015f0 <__vector_5>:
* Example Call:								NONE
*
*/

ISR(INT4_vect)
{
    15f0:	1f 92       	push	r1
    15f2:	0f 92       	push	r0
    15f4:	0f b6       	in	r0, 0x3f	; 63
    15f6:	0f 92       	push	r0
    15f8:	0b b6       	in	r0, 0x3b	; 59
    15fa:	0f 92       	push	r0
    15fc:	11 24       	eor	r1, r1
    15fe:	0f 93       	push	r16
    1600:	1f 93       	push	r17
    1602:	2f 93       	push	r18
    1604:	3f 93       	push	r19
    1606:	4f 93       	push	r20
    1608:	5f 93       	push	r21
    160a:	6f 93       	push	r22
    160c:	7f 93       	push	r23
    160e:	8f 93       	push	r24
    1610:	9f 93       	push	r25
    1612:	af 93       	push	r26
    1614:	bf 93       	push	r27
    1616:	cf 93       	push	r28
    1618:	df 93       	push	r29
    161a:	ef 93       	push	r30
    161c:	ff 93       	push	r31
	int i=0;
	left_position_encode++;
    161e:	80 91 65 02 	lds	r24, 0x0265
    1622:	90 91 66 02 	lds	r25, 0x0266
    1626:	a0 91 67 02 	lds	r26, 0x0267
    162a:	b0 91 68 02 	lds	r27, 0x0268
    162e:	01 96       	adiw	r24, 0x01	; 1
    1630:	a1 1d       	adc	r26, r1
    1632:	b1 1d       	adc	r27, r1
    1634:	80 93 65 02 	sts	0x0265, r24
    1638:	90 93 66 02 	sts	0x0266, r25
    163c:	a0 93 67 02 	sts	0x0267, r26
    1640:	b0 93 68 02 	sts	0x0268, r27
	if(abs(navigation_in_degrees)==360)
    1644:	80 91 3d 02 	lds	r24, 0x023D
    1648:	90 91 3e 02 	lds	r25, 0x023E
    164c:	99 23       	and	r25, r25
    164e:	1c f4       	brge	.+6      	; 0x1656 <__vector_5+0x66>
    1650:	90 95       	com	r25
    1652:	81 95       	neg	r24
    1654:	9f 4f       	sbci	r25, 0xFF	; 255
    1656:	21 e0       	ldi	r18, 0x01	; 1
    1658:	88 36       	cpi	r24, 0x68	; 104
    165a:	92 07       	cpc	r25, r18
    165c:	21 f4       	brne	.+8      	; 0x1666 <__vector_5+0x76>
	navigation_in_degrees=0;
    165e:	10 92 3e 02 	sts	0x023E, r1
    1662:	10 92 3d 02 	sts	0x023D, r1
* Example Call:								NONE
*
*/

ISR(INT4_vect)
{
    1666:	c0 e0       	ldi	r28, 0x00	; 0
    1668:	d0 e0       	ldi	r29, 0x00	; 0
	left_position_encode++;
	if(abs(navigation_in_degrees)==360)
	navigation_in_degrees=0;
	//i: will iterate from 0 to the channel length
	for(i=0;i<16;i++)
	digital[i]=getdata(i);
    166a:	08 e3       	ldi	r16, 0x38	; 56
    166c:	15 e0       	ldi	r17, 0x05	; 5
    166e:	ce 01       	movw	r24, r28
    1670:	0e 94 74 0a 	call	0x14e8	; 0x14e8 <getdata>
    1674:	28 2f       	mov	r18, r24
    1676:	39 2f       	mov	r19, r25
    1678:	fe 01       	movw	r30, r28
    167a:	ee 0f       	add	r30, r30
    167c:	ff 1f       	adc	r31, r31
    167e:	e0 0f       	add	r30, r16
    1680:	f1 1f       	adc	r31, r17
    1682:	31 83       	std	Z+1, r19	; 0x01
    1684:	20 83       	st	Z, r18
	int i=0;
	left_position_encode++;
	if(abs(navigation_in_degrees)==360)
	navigation_in_degrees=0;
	//i: will iterate from 0 to the channel length
	for(i=0;i<16;i++)
    1686:	21 96       	adiw	r28, 0x01	; 1
    1688:	c0 31       	cpi	r28, 0x10	; 16
    168a:	d1 05       	cpc	r29, r1
    168c:	81 f7       	brne	.-32     	; 0x166e <__vector_5+0x7e>
	digital[i]=getdata(i);
}
    168e:	ff 91       	pop	r31
    1690:	ef 91       	pop	r30
    1692:	df 91       	pop	r29
    1694:	cf 91       	pop	r28
    1696:	bf 91       	pop	r27
    1698:	af 91       	pop	r26
    169a:	9f 91       	pop	r25
    169c:	8f 91       	pop	r24
    169e:	7f 91       	pop	r23
    16a0:	6f 91       	pop	r22
    16a2:	5f 91       	pop	r21
    16a4:	4f 91       	pop	r20
    16a6:	3f 91       	pop	r19
    16a8:	2f 91       	pop	r18
    16aa:	1f 91       	pop	r17
    16ac:	0f 91       	pop	r16
    16ae:	0f 90       	pop	r0
    16b0:	0b be       	out	0x3b, r0	; 59
    16b2:	0f 90       	pop	r0
    16b4:	0f be       	out	0x3f, r0	; 63
    16b6:	0f 90       	pop	r0
    16b8:	1f 90       	pop	r1
    16ba:	18 95       	reti

000016bc <sharp>:
* Example Call:				sharp(digital[11]);
*	
*/

int sharp(int adc_reading)
{
    16bc:	0f 93       	push	r16
    16be:	1f 93       	push	r17
	float distance;
	int distanceInt;
	distance = (int)(10.00*(2799.6*(1.00/(pow(adc_reading,1.1546)))));
    16c0:	9c 01       	movw	r18, r24
    16c2:	b9 01       	movw	r22, r18
    16c4:	88 27       	eor	r24, r24
    16c6:	77 fd       	sbrc	r23, 7
    16c8:	80 95       	com	r24
    16ca:	98 2f       	mov	r25, r24
    16cc:	0e 94 9e 18 	call	0x313c	; 0x313c <__floatsisf>
    16d0:	2f ee       	ldi	r18, 0xEF	; 239
    16d2:	39 ec       	ldi	r19, 0xC9	; 201
    16d4:	43 e9       	ldi	r20, 0x93	; 147
    16d6:	5f e3       	ldi	r21, 0x3F	; 63
    16d8:	0e 94 f1 19 	call	0x33e2	; 0x33e2 <pow>
    16dc:	b6 2f       	mov	r27, r22
    16de:	a7 2f       	mov	r26, r23
    16e0:	38 2f       	mov	r19, r24
    16e2:	29 2f       	mov	r18, r25
    16e4:	60 e0       	ldi	r22, 0x00	; 0
    16e6:	70 e0       	ldi	r23, 0x00	; 0
    16e8:	80 e8       	ldi	r24, 0x80	; 128
    16ea:	9f e3       	ldi	r25, 0x3F	; 63
    16ec:	42 2f       	mov	r20, r18
    16ee:	0b 2f       	mov	r16, r27
    16f0:	1a 2f       	mov	r17, r26
    16f2:	23 2f       	mov	r18, r19
    16f4:	34 2f       	mov	r19, r20
    16f6:	a9 01       	movw	r20, r18
    16f8:	98 01       	movw	r18, r16
    16fa:	0e 94 03 18 	call	0x3006	; 0x3006 <__divsf3>
    16fe:	2a e9       	ldi	r18, 0x9A	; 154
    1700:	39 ef       	ldi	r19, 0xF9	; 249
    1702:	4e e2       	ldi	r20, 0x2E	; 46
    1704:	55 e4       	ldi	r21, 0x45	; 69
    1706:	0e 94 8e 19 	call	0x331c	; 0x331c <__mulsf3>
    170a:	20 e0       	ldi	r18, 0x00	; 0
    170c:	30 e0       	ldi	r19, 0x00	; 0
    170e:	40 e2       	ldi	r20, 0x20	; 32
    1710:	51 e4       	ldi	r21, 0x41	; 65
    1712:	0e 94 8e 19 	call	0x331c	; 0x331c <__mulsf3>
    1716:	0e 94 6b 18 	call	0x30d6	; 0x30d6 <__fixsfsi>
    171a:	88 27       	eor	r24, r24
    171c:	77 fd       	sbrc	r23, 7
    171e:	80 95       	com	r24
    1720:	98 2f       	mov	r25, r24
    1722:	0e 94 9e 18 	call	0x313c	; 0x313c <__floatsisf>
	distanceInt = (int)distance;
    1726:	0e 94 6b 18 	call	0x30d6	; 0x30d6 <__fixsfsi>
	if(distanceInt>800)
	{
		distanceInt=800;
	}
	return distanceInt;
    172a:	86 2f       	mov	r24, r22
    172c:	97 2f       	mov	r25, r23
    172e:	33 e0       	ldi	r19, 0x03	; 3
    1730:	81 32       	cpi	r24, 0x21	; 33
    1732:	93 07       	cpc	r25, r19
    1734:	14 f0       	brlt	.+4      	; 0x173a <sharp+0x7e>
    1736:	80 e2       	ldi	r24, 0x20	; 32
    1738:	93 e0       	ldi	r25, 0x03	; 3
}
    173a:	1f 91       	pop	r17
    173c:	0f 91       	pop	r16
    173e:	08 95       	ret

00001740 <node_behave>:
* Example Call:				node_behave(); 
*
*/

void node_behave(void) 
{
    1740:	af 92       	push	r10
    1742:	bf 92       	push	r11
    1744:	cf 92       	push	r12
    1746:	df 92       	push	r13
    1748:	ef 92       	push	r14
    174a:	ff 92       	push	r15
    174c:	0f 93       	push	r16
    174e:	1f 93       	push	r17
    1750:	cf 93       	push	r28
    1752:	df 93       	push	r29
	int i;
    if(path[path_index]!='\0')
    1754:	e0 91 59 02 	lds	r30, 0x0259
    1758:	f0 91 5a 02 	lds	r31, 0x025A
    175c:	e1 59       	subi	r30, 0x91	; 145
    175e:	fd 4f       	sbci	r31, 0xFD	; 253
    1760:	80 81       	ld	r24, Z
    1762:	88 23       	and	r24, r24
    1764:	09 f4       	brne	.+2      	; 0x1768 <node_behave+0x28>
    1766:	eb c0       	rjmp	.+470    	; 0x193e <node_behave+0x1fe>
	{
		if((node_number==6 && *navigation_pointer=='E' && destinationn_node!=21) ||(node_number==16 && *navigation_pointer=='W') ||(node_number==15 && *navigation_pointer=='W') ||(node_number==17 && *navigation_pointer=='W') )
    1768:	80 91 5f 02 	lds	r24, 0x025F
    176c:	90 91 60 02 	lds	r25, 0x0260
    1770:	86 30       	cpi	r24, 0x06	; 6
    1772:	91 05       	cpc	r25, r1
    1774:	79 f4       	brne	.+30     	; 0x1794 <node_behave+0x54>
    1776:	e0 91 ab 02 	lds	r30, 0x02AB
    177a:	f0 91 ac 02 	lds	r31, 0x02AC
    177e:	20 81       	ld	r18, Z
    1780:	25 34       	cpi	r18, 0x45	; 69
    1782:	41 f4       	brne	.+16     	; 0x1794 <node_behave+0x54>
    1784:	20 91 5d 02 	lds	r18, 0x025D
    1788:	30 91 5e 02 	lds	r19, 0x025E
    178c:	25 31       	cpi	r18, 0x15	; 21
    178e:	31 05       	cpc	r19, r1
    1790:	09 f5       	brne	.+66     	; 0x17d4 <node_behave+0x94>
    1792:	16 c0       	rjmp	.+44     	; 0x17c0 <node_behave+0x80>
    1794:	80 31       	cpi	r24, 0x10	; 16
    1796:	91 05       	cpc	r25, r1
    1798:	41 f4       	brne	.+16     	; 0x17aa <node_behave+0x6a>
    179a:	e0 91 ab 02 	lds	r30, 0x02AB
    179e:	f0 91 ac 02 	lds	r31, 0x02AC
    17a2:	20 81       	ld	r18, Z
    17a4:	27 35       	cpi	r18, 0x57	; 87
    17a6:	f9 f4       	brne	.+62     	; 0x17e6 <node_behave+0xa6>
    17a8:	15 c0       	rjmp	.+42     	; 0x17d4 <node_behave+0x94>
    17aa:	8f 30       	cpi	r24, 0x0F	; 15
    17ac:	91 05       	cpc	r25, r1
    17ae:	41 f4       	brne	.+16     	; 0x17c0 <node_behave+0x80>
    17b0:	e0 91 ab 02 	lds	r30, 0x02AB
    17b4:	f0 91 ac 02 	lds	r31, 0x02AC
    17b8:	80 81       	ld	r24, Z
    17ba:	87 35       	cpi	r24, 0x57	; 87
    17bc:	01 f5       	brne	.+64     	; 0x17fe <node_behave+0xbe>
    17be:	0a c0       	rjmp	.+20     	; 0x17d4 <node_behave+0x94>
    17c0:	81 31       	cpi	r24, 0x11	; 17
    17c2:	91 05       	cpc	r25, r1
    17c4:	81 f4       	brne	.+32     	; 0x17e6 <node_behave+0xa6>
    17c6:	e0 91 ab 02 	lds	r30, 0x02AB
    17ca:	f0 91 ac 02 	lds	r31, 0x02AC
    17ce:	80 81       	ld	r24, Z
    17d0:	87 35       	cpi	r24, 0x57	; 87
    17d2:	a9 f4       	brne	.+42     	; 0x17fe <node_behave+0xbe>
		distance('f',3,'o');
    17d4:	86 e6       	ldi	r24, 0x66	; 102
    17d6:	40 e0       	ldi	r20, 0x00	; 0
    17d8:	50 e0       	ldi	r21, 0x00	; 0
    17da:	60 e4       	ldi	r22, 0x40	; 64
    17dc:	70 e4       	ldi	r23, 0x40	; 64
    17de:	2f e6       	ldi	r18, 0x6F	; 111
    17e0:	0e 94 8a 07 	call	0xf14	; 0xf14 <distance>
    17e4:	14 c0       	rjmp	.+40     	; 0x180e <node_behave+0xce>
		else if(node_number==14)
    17e6:	8e 30       	cpi	r24, 0x0E	; 14
    17e8:	91 05       	cpc	r25, r1
    17ea:	49 f4       	brne	.+18     	; 0x17fe <node_behave+0xbe>
		distance('f',7,'o');
    17ec:	86 e6       	ldi	r24, 0x66	; 102
    17ee:	40 e0       	ldi	r20, 0x00	; 0
    17f0:	50 e0       	ldi	r21, 0x00	; 0
    17f2:	60 ee       	ldi	r22, 0xE0	; 224
    17f4:	70 e4       	ldi	r23, 0x40	; 64
    17f6:	2f e6       	ldi	r18, 0x6F	; 111
    17f8:	0e 94 8a 07 	call	0xf14	; 0xf14 <distance>
    17fc:	08 c0       	rjmp	.+16     	; 0x180e <node_behave+0xce>
		else
		distance('f',8.5,'o');
    17fe:	86 e6       	ldi	r24, 0x66	; 102
    1800:	40 e0       	ldi	r20, 0x00	; 0
    1802:	50 e0       	ldi	r21, 0x00	; 0
    1804:	68 e0       	ldi	r22, 0x08	; 8
    1806:	71 e4       	ldi	r23, 0x41	; 65
    1808:	2f e6       	ldi	r18, 0x6F	; 111
    180a:	0e 94 8a 07 	call	0xf14	; 0xf14 <distance>
		if((*navigation_pointer-path[path_index])==-9 || (*navigation_pointer-path[path_index])==4 || (*navigation_pointer-path[path_index])==14) //-9,4,14 are ASCII values for 270 degree while rotating in rightwards
    180e:	e0 91 ab 02 	lds	r30, 0x02AB
    1812:	f0 91 ac 02 	lds	r31, 0x02AC
    1816:	50 81       	ld	r21, Z
    1818:	e0 91 59 02 	lds	r30, 0x0259
    181c:	f0 91 5a 02 	lds	r31, 0x025A
    1820:	e1 59       	subi	r30, 0x91	; 145
    1822:	fd 4f       	sbci	r31, 0xFD	; 253
    1824:	40 81       	ld	r20, Z
    1826:	85 2f       	mov	r24, r21
    1828:	90 e0       	ldi	r25, 0x00	; 0
    182a:	84 1b       	sub	r24, r20
    182c:	91 09       	sbc	r25, r1
    182e:	2f ef       	ldi	r18, 0xFF	; 255
    1830:	87 3f       	cpi	r24, 0xF7	; 247
    1832:	92 07       	cpc	r25, r18
    1834:	31 f0       	breq	.+12     	; 0x1842 <node_behave+0x102>
    1836:	84 30       	cpi	r24, 0x04	; 4
    1838:	91 05       	cpc	r25, r1
    183a:	19 f0       	breq	.+6      	; 0x1842 <node_behave+0x102>
    183c:	8e 30       	cpi	r24, 0x0E	; 14
    183e:	91 05       	cpc	r25, r1
    1840:	c1 f4       	brne	.+48     	; 0x1872 <node_behave+0x132>
			while(*navigation_pointer!=path[path_index])
    1842:	54 17       	cp	r21, r20
    1844:	09 f4       	brne	.+2      	; 0x1848 <node_behave+0x108>
    1846:	70 c0       	rjmp	.+224    	; 0x1928 <node_behave+0x1e8>
    1848:	cf e6       	ldi	r28, 0x6F	; 111
    184a:	d2 e0       	ldi	r29, 0x02	; 2
				{left_degrees(90);}
    184c:	8a e5       	ldi	r24, 0x5A	; 90
    184e:	90 e0       	ldi	r25, 0x00	; 0
    1850:	0e 94 99 08 	call	0x1132	; 0x1132 <left_degrees>
		else if(node_number==14)
		distance('f',7,'o');
		else
		distance('f',8.5,'o');
		if((*navigation_pointer-path[path_index])==-9 || (*navigation_pointer-path[path_index])==4 || (*navigation_pointer-path[path_index])==14) //-9,4,14 are ASCII values for 270 degree while rotating in rightwards
			while(*navigation_pointer!=path[path_index])
    1854:	e0 91 ab 02 	lds	r30, 0x02AB
    1858:	f0 91 ac 02 	lds	r31, 0x02AC
    185c:	a0 91 59 02 	lds	r26, 0x0259
    1860:	b0 91 5a 02 	lds	r27, 0x025A
    1864:	ac 0f       	add	r26, r28
    1866:	bd 1f       	adc	r27, r29
    1868:	90 81       	ld	r25, Z
    186a:	8c 91       	ld	r24, X
    186c:	98 17       	cp	r25, r24
    186e:	71 f7       	brne	.-36     	; 0x184c <node_behave+0x10c>
    1870:	5b c0       	rjmp	.+182    	; 0x1928 <node_behave+0x1e8>
				{left_degrees(90);}
		else if(node_number==3)
    1872:	20 91 5f 02 	lds	r18, 0x025F
    1876:	30 91 60 02 	lds	r19, 0x0260
    187a:	23 30       	cpi	r18, 0x03	; 3
    187c:	31 05       	cpc	r19, r1
    187e:	c1 f4       	brne	.+48     	; 0x18b0 <node_behave+0x170>
			while(*navigation_pointer!=path[path_index])
    1880:	54 17       	cp	r21, r20
    1882:	09 f4       	brne	.+2      	; 0x1886 <node_behave+0x146>
    1884:	51 c0       	rjmp	.+162    	; 0x1928 <node_behave+0x1e8>
    1886:	cf e6       	ldi	r28, 0x6F	; 111
    1888:	d2 e0       	ldi	r29, 0x02	; 2
				right_degrees(180);
    188a:	84 eb       	ldi	r24, 0xB4	; 180
    188c:	90 e0       	ldi	r25, 0x00	; 0
    188e:	0e 94 00 09 	call	0x1200	; 0x1200 <right_degrees>
		distance('f',8.5,'o');
		if((*navigation_pointer-path[path_index])==-9 || (*navigation_pointer-path[path_index])==4 || (*navigation_pointer-path[path_index])==14) //-9,4,14 are ASCII values for 270 degree while rotating in rightwards
			while(*navigation_pointer!=path[path_index])
				{left_degrees(90);}
		else if(node_number==3)
			while(*navigation_pointer!=path[path_index])
    1892:	e0 91 ab 02 	lds	r30, 0x02AB
    1896:	f0 91 ac 02 	lds	r31, 0x02AC
    189a:	a0 91 59 02 	lds	r26, 0x0259
    189e:	b0 91 5a 02 	lds	r27, 0x025A
    18a2:	ac 0f       	add	r26, r28
    18a4:	bd 1f       	adc	r27, r29
    18a6:	90 81       	ld	r25, Z
    18a8:	8c 91       	ld	r24, X
    18aa:	98 17       	cp	r25, r24
    18ac:	71 f7       	brne	.-36     	; 0x188a <node_behave+0x14a>
    18ae:	3c c0       	rjmp	.+120    	; 0x1928 <node_behave+0x1e8>
				right_degrees(180);
		else if(abs(*navigation_pointer-path[path_index])==5 || abs(*navigation_pointer-path[path_index])==18)
    18b0:	9c 01       	movw	r18, r24
    18b2:	99 23       	and	r25, r25
    18b4:	24 f4       	brge	.+8      	; 0x18be <node_behave+0x17e>
    18b6:	22 27       	eor	r18, r18
    18b8:	33 27       	eor	r19, r19
    18ba:	28 1b       	sub	r18, r24
    18bc:	39 0b       	sbc	r19, r25
    18be:	25 30       	cpi	r18, 0x05	; 5
    18c0:	31 05       	cpc	r19, r1
    18c2:	19 f4       	brne	.+6      	; 0x18ca <node_behave+0x18a>
			while(*navigation_pointer!=path[path_index])
    18c4:	54 17       	cp	r21, r20
    18c6:	39 f4       	brne	.+14     	; 0x18d6 <node_behave+0x196>
    18c8:	2f c0       	rjmp	.+94     	; 0x1928 <node_behave+0x1e8>
			while(*navigation_pointer!=path[path_index])
				{left_degrees(90);}
		else if(node_number==3)
			while(*navigation_pointer!=path[path_index])
				right_degrees(180);
		else if(abs(*navigation_pointer-path[path_index])==5 || abs(*navigation_pointer-path[path_index])==18)
    18ca:	22 31       	cpi	r18, 0x12	; 18
    18cc:	31 05       	cpc	r19, r1
    18ce:	d1 f3       	breq	.-12     	; 0x18c4 <node_behave+0x184>
			while(*navigation_pointer!=path[path_index])
				left_degrees(180);
		else
			while(*navigation_pointer!=path[path_index])
    18d0:	54 17       	cp	r21, r20
    18d2:	b1 f4       	brne	.+44     	; 0x1900 <node_behave+0x1c0>
    18d4:	29 c0       	rjmp	.+82     	; 0x1928 <node_behave+0x1e8>
				{left_degrees(90);}
		else if(node_number==3)
			while(*navigation_pointer!=path[path_index])
				right_degrees(180);
		else if(abs(*navigation_pointer-path[path_index])==5 || abs(*navigation_pointer-path[path_index])==18)
			while(*navigation_pointer!=path[path_index])
    18d6:	cf e6       	ldi	r28, 0x6F	; 111
    18d8:	d2 e0       	ldi	r29, 0x02	; 2
				left_degrees(180);
    18da:	84 eb       	ldi	r24, 0xB4	; 180
    18dc:	90 e0       	ldi	r25, 0x00	; 0
    18de:	0e 94 99 08 	call	0x1132	; 0x1132 <left_degrees>
				{left_degrees(90);}
		else if(node_number==3)
			while(*navigation_pointer!=path[path_index])
				right_degrees(180);
		else if(abs(*navigation_pointer-path[path_index])==5 || abs(*navigation_pointer-path[path_index])==18)
			while(*navigation_pointer!=path[path_index])
    18e2:	e0 91 ab 02 	lds	r30, 0x02AB
    18e6:	f0 91 ac 02 	lds	r31, 0x02AC
    18ea:	a0 91 59 02 	lds	r26, 0x0259
    18ee:	b0 91 5a 02 	lds	r27, 0x025A
    18f2:	ac 0f       	add	r26, r28
    18f4:	bd 1f       	adc	r27, r29
    18f6:	90 81       	ld	r25, Z
    18f8:	8c 91       	ld	r24, X
    18fa:	98 17       	cp	r25, r24
    18fc:	71 f7       	brne	.-36     	; 0x18da <node_behave+0x19a>
    18fe:	14 c0       	rjmp	.+40     	; 0x1928 <node_behave+0x1e8>
				left_degrees(180);
		else
			while(*navigation_pointer!=path[path_index])
    1900:	cf e6       	ldi	r28, 0x6F	; 111
    1902:	d2 e0       	ldi	r29, 0x02	; 2
			right_degrees(90);
    1904:	8a e5       	ldi	r24, 0x5A	; 90
    1906:	90 e0       	ldi	r25, 0x00	; 0
    1908:	0e 94 00 09 	call	0x1200	; 0x1200 <right_degrees>
				right_degrees(180);
		else if(abs(*navigation_pointer-path[path_index])==5 || abs(*navigation_pointer-path[path_index])==18)
			while(*navigation_pointer!=path[path_index])
				left_degrees(180);
		else
			while(*navigation_pointer!=path[path_index])
    190c:	e0 91 ab 02 	lds	r30, 0x02AB
    1910:	f0 91 ac 02 	lds	r31, 0x02AC
    1914:	a0 91 59 02 	lds	r26, 0x0259
    1918:	b0 91 5a 02 	lds	r27, 0x025A
    191c:	ac 0f       	add	r26, r28
    191e:	bd 1f       	adc	r27, r29
    1920:	90 81       	ld	r25, Z
    1922:	8c 91       	ld	r24, X
    1924:	98 17       	cp	r25, r24
    1926:	71 f7       	brne	.-36     	; 0x1904 <node_behave+0x1c4>
			right_degrees(90);
		path_index++;
    1928:	80 91 59 02 	lds	r24, 0x0259
    192c:	90 91 5a 02 	lds	r25, 0x025A
    1930:	01 96       	adiw	r24, 0x01	; 1
    1932:	90 93 5a 02 	sts	0x025A, r25
    1936:	80 93 59 02 	sts	0x0259, r24
    193a:	0c 94 bb 14 	jmp	0x2976	; 0x2976 <__stack+0x777>
	}
	else
	{
		node_number=destinationn_node;
    193e:	80 91 5d 02 	lds	r24, 0x025D
    1942:	90 91 5e 02 	lds	r25, 0x025E
    1946:	90 93 60 02 	sts	0x0260, r25
    194a:	80 93 5f 02 	sts	0x025F, r24
		navigate();
    194e:	0e 94 55 04 	call	0x8aa	; 0x8aa <navigate>
		if(node_number==15 || node_number==16 || node_number==17)
    1952:	80 91 5f 02 	lds	r24, 0x025F
    1956:	90 91 60 02 	lds	r25, 0x0260
    195a:	0f 97       	sbiw	r24, 0x0f	; 15
    195c:	83 30       	cpi	r24, 0x03	; 3
    195e:	91 05       	cpc	r25, r1
    1960:	08 f0       	brcs	.+2      	; 0x1964 <node_behave+0x224>
    1962:	42 c1       	rjmp	.+644    	; 0x1be8 <node_behave+0x4a8>
		{
			if((deposition_zone_A+deposition_zone_B+deposition_zone_C)!=1 && color_found==0)
    1964:	80 91 3b 02 	lds	r24, 0x023B
    1968:	90 91 3c 02 	lds	r25, 0x023C
    196c:	20 91 39 02 	lds	r18, 0x0239
    1970:	30 91 3a 02 	lds	r19, 0x023A
    1974:	82 0f       	add	r24, r18
    1976:	93 1f       	adc	r25, r19
    1978:	20 91 37 02 	lds	r18, 0x0237
    197c:	30 91 38 02 	lds	r19, 0x0238
    1980:	82 0f       	add	r24, r18
    1982:	93 1f       	adc	r25, r19
    1984:	81 30       	cpi	r24, 0x01	; 1
    1986:	91 05       	cpc	r25, r1
    1988:	09 f4       	brne	.+2      	; 0x198c <node_behave+0x24c>
    198a:	89 c0       	rjmp	.+274    	; 0x1a9e <node_behave+0x35e>
    198c:	80 91 5b 02 	lds	r24, 0x025B
    1990:	90 91 5c 02 	lds	r25, 0x025C
    1994:	00 97       	sbiw	r24, 0x00	; 0
    1996:	09 f0       	breq	.+2      	; 0x199a <node_behave+0x25a>
    1998:	82 c0       	rjmp	.+260    	; 0x1a9e <node_behave+0x35e>
			{
				left(); //Turn left
    199a:	0e 94 14 08 	call	0x1028	; 0x1028 <left>
				angle_rotate(45);
    199e:	8d e2       	ldi	r24, 0x2D	; 45
    19a0:	90 e0       	ldi	r25, 0x00	; 0
    19a2:	0e 94 24 08 	call	0x1048	; 0x1048 <angle_rotate>
				distance('f',13,'o');
    19a6:	86 e6       	ldi	r24, 0x66	; 102
    19a8:	40 e0       	ldi	r20, 0x00	; 0
    19aa:	50 e0       	ldi	r21, 0x00	; 0
    19ac:	60 e5       	ldi	r22, 0x50	; 80
    19ae:	71 e4       	ldi	r23, 0x41	; 65
    19b0:	2f e6       	ldi	r18, 0x6F	; 111
    19b2:	0e 94 8a 07 	call	0xf14	; 0xf14 <distance>
				right(); //Turn left
    19b6:	0e 94 18 08 	call	0x1030	; 0x1030 <right>
				angle_rotate(170);
    19ba:	8a ea       	ldi	r24, 0xAA	; 170
    19bc:	90 e0       	ldi	r25, 0x00	; 0
    19be:	0e 94 24 08 	call	0x1048	; 0x1048 <angle_rotate>
				stop();
    19c2:	0e 94 10 08 	call	0x1020	; 0x1020 <stop>
				color_sensor();
    19c6:	0e 94 43 16 	call	0x2c86	; 0x2c86 <color_sensor>
				if(node_number==15)
    19ca:	80 91 5f 02 	lds	r24, 0x025F
    19ce:	90 91 60 02 	lds	r25, 0x0260
    19d2:	8f 30       	cpi	r24, 0x0F	; 15
    19d4:	91 05       	cpc	r25, r1
    19d6:	29 f4       	brne	.+10     	; 0x19e2 <node_behave+0x2a2>
				color_deposited[0]=color_identified;
    19d8:	80 91 54 02 	lds	r24, 0x0254
    19dc:	80 93 a3 02 	sts	0x02A3, r24
    19e0:	0f c0       	rjmp	.+30     	; 0x1a00 <node_behave+0x2c0>
				if(node_number==16)
    19e2:	80 31       	cpi	r24, 0x10	; 16
    19e4:	91 05       	cpc	r25, r1
    19e6:	29 f4       	brne	.+10     	; 0x19f2 <node_behave+0x2b2>
				color_deposited[1]=color_identified;
    19e8:	80 91 54 02 	lds	r24, 0x0254
    19ec:	80 93 a4 02 	sts	0x02A4, r24
    19f0:	07 c0       	rjmp	.+14     	; 0x1a00 <node_behave+0x2c0>
				if(node_number==17)
    19f2:	81 31       	cpi	r24, 0x11	; 17
    19f4:	91 05       	cpc	r25, r1
    19f6:	21 f4       	brne	.+8      	; 0x1a00 <node_behave+0x2c0>
				color_deposited[2]=color_identified;
    19f8:	80 91 54 02 	lds	r24, 0x0254
    19fc:	80 93 a5 02 	sts	0x02A5, r24
				left(); //Turn left
    1a00:	0e 94 14 08 	call	0x1028	; 0x1028 <left>
				angle_rotate(170);
    1a04:	8a ea       	ldi	r24, 0xAA	; 170
    1a06:	90 e0       	ldi	r25, 0x00	; 0
    1a08:	0e 94 24 08 	call	0x1048	; 0x1048 <angle_rotate>
				distance('b',11,'o');
    1a0c:	82 e6       	ldi	r24, 0x62	; 98
    1a0e:	40 e0       	ldi	r20, 0x00	; 0
    1a10:	50 e0       	ldi	r21, 0x00	; 0
    1a12:	60 e3       	ldi	r22, 0x30	; 48
    1a14:	71 e4       	ldi	r23, 0x41	; 65
    1a16:	2f e6       	ldi	r18, 0x6F	; 111
    1a18:	0e 94 8a 07 	call	0xf14	; 0xf14 <distance>
				while(digital[2]<15 && digital[1]<15 && digital[3]<15)
    1a1c:	80 91 3c 05 	lds	r24, 0x053C
    1a20:	90 91 3d 05 	lds	r25, 0x053D
    1a24:	8f 30       	cpi	r24, 0x0F	; 15
    1a26:	91 05       	cpc	r25, r1
    1a28:	90 f5       	brcc	.+100    	; 0x1a8e <node_behave+0x34e>
    1a2a:	80 91 3a 05 	lds	r24, 0x053A
    1a2e:	90 91 3b 05 	lds	r25, 0x053B
    1a32:	8f 30       	cpi	r24, 0x0F	; 15
    1a34:	91 05       	cpc	r25, r1
    1a36:	58 f5       	brcc	.+86     	; 0x1a8e <node_behave+0x34e>
    1a38:	80 91 3e 05 	lds	r24, 0x053E
    1a3c:	90 91 3f 05 	lds	r25, 0x053F
    1a40:	8f 30       	cpi	r24, 0x0F	; 15
    1a42:	91 05       	cpc	r25, r1
    1a44:	20 f5       	brcc	.+72     	; 0x1a8e <node_behave+0x34e>
    1a46:	cc e3       	ldi	r28, 0x3C	; 60
    1a48:	d5 e0       	ldi	r29, 0x05	; 5
    1a4a:	0a e3       	ldi	r16, 0x3A	; 58
    1a4c:	15 e0       	ldi	r17, 0x05	; 5
    1a4e:	0f 2e       	mov	r0, r31
    1a50:	fe e3       	ldi	r31, 0x3E	; 62
    1a52:	ef 2e       	mov	r14, r31
    1a54:	f5 e0       	ldi	r31, 0x05	; 5
    1a56:	ff 2e       	mov	r15, r31
    1a58:	f0 2d       	mov	r31, r0
				{
					sppeed(255,249);
    1a5a:	8f ef       	ldi	r24, 0xFF	; 255
    1a5c:	90 e0       	ldi	r25, 0x00	; 0
    1a5e:	69 ef       	ldi	r22, 0xF9	; 249
    1a60:	70 e0       	ldi	r23, 0x00	; 0
    1a62:	0e 94 f7 00 	call	0x1ee	; 0x1ee <sppeed>
					right();
    1a66:	0e 94 18 08 	call	0x1030	; 0x1030 <right>
				if(node_number==17)
				color_deposited[2]=color_identified;
				left(); //Turn left
				angle_rotate(170);
				distance('b',11,'o');
				while(digital[2]<15 && digital[1]<15 && digital[3]<15)
    1a6a:	88 81       	ld	r24, Y
    1a6c:	99 81       	ldd	r25, Y+1	; 0x01
    1a6e:	8f 30       	cpi	r24, 0x0F	; 15
    1a70:	91 05       	cpc	r25, r1
    1a72:	68 f4       	brcc	.+26     	; 0x1a8e <node_behave+0x34e>
    1a74:	d8 01       	movw	r26, r16
    1a76:	8d 91       	ld	r24, X+
    1a78:	9c 91       	ld	r25, X
    1a7a:	11 97       	sbiw	r26, 0x01	; 1
    1a7c:	8f 30       	cpi	r24, 0x0F	; 15
    1a7e:	91 05       	cpc	r25, r1
    1a80:	30 f4       	brcc	.+12     	; 0x1a8e <node_behave+0x34e>
    1a82:	f7 01       	movw	r30, r14
    1a84:	80 81       	ld	r24, Z
    1a86:	91 81       	ldd	r25, Z+1	; 0x01
    1a88:	8f 30       	cpi	r24, 0x0F	; 15
    1a8a:	91 05       	cpc	r25, r1
    1a8c:	30 f3       	brcs	.-52     	; 0x1a5a <node_behave+0x31a>
				{
					sppeed(255,249);
					right();
				}
				right();
    1a8e:	0e 94 18 08 	call	0x1030	; 0x1030 <right>
				angle_rotate(25);
    1a92:	89 e1       	ldi	r24, 0x19	; 25
    1a94:	90 e0       	ldi	r25, 0x00	; 0
    1a96:	0e 94 24 08 	call	0x1048	; 0x1048 <angle_rotate>
				stop();
    1a9a:	0e 94 10 08 	call	0x1020	; 0x1020 <stop>
			}
			if(color_identified==color[color_index-1] || (deposition_zone_A+deposition_zone_B+deposition_zone_C)==1)
    1a9e:	e0 91 52 02 	lds	r30, 0x0252
    1aa2:	f0 91 53 02 	lds	r31, 0x0253
    1aa6:	ee 5c       	subi	r30, 0xCE	; 206
    1aa8:	fa 4f       	sbci	r31, 0xFA	; 250
    1aaa:	90 81       	ld	r25, Z
    1aac:	80 91 54 02 	lds	r24, 0x0254
    1ab0:	98 17       	cp	r25, r24
    1ab2:	a1 f0       	breq	.+40     	; 0x1adc <node_behave+0x39c>
    1ab4:	80 91 3b 02 	lds	r24, 0x023B
    1ab8:	90 91 3c 02 	lds	r25, 0x023C
    1abc:	20 91 39 02 	lds	r18, 0x0239
    1ac0:	30 91 3a 02 	lds	r19, 0x023A
    1ac4:	82 0f       	add	r24, r18
    1ac6:	93 1f       	adc	r25, r19
    1ac8:	20 91 37 02 	lds	r18, 0x0237
    1acc:	30 91 38 02 	lds	r19, 0x0238
    1ad0:	82 0f       	add	r24, r18
    1ad2:	93 1f       	adc	r25, r19
    1ad4:	81 30       	cpi	r24, 0x01	; 1
    1ad6:	91 05       	cpc	r25, r1
    1ad8:	09 f0       	breq	.+2      	; 0x1adc <node_behave+0x39c>
    1ada:	60 c0       	rjmp	.+192    	; 0x1b9c <node_behave+0x45c>
			{
				servo1_mov(10);
    1adc:	8a e0       	ldi	r24, 0x0A	; 10
    1ade:	90 e0       	ldi	r25, 0x00	; 0
    1ae0:	0e 94 c9 09 	call	0x1392	; 0x1392 <servo1_mov>
    1ae4:	8f ef       	ldi	r24, 0xFF	; 255
    1ae6:	9f ef       	ldi	r25, 0xFF	; 255
    1ae8:	ac e2       	ldi	r26, 0x2C	; 44
    1aea:	81 50       	subi	r24, 0x01	; 1
    1aec:	90 40       	sbci	r25, 0x00	; 0
    1aee:	a0 40       	sbci	r26, 0x00	; 0
    1af0:	e1 f7       	brne	.-8      	; 0x1aea <node_behave+0x3aa>
    1af2:	00 c0       	rjmp	.+0      	; 0x1af4 <node_behave+0x3b4>
    1af4:	00 00       	nop
				_delay_ms(1000);
				servo2_mov(45);
    1af6:	8d e2       	ldi	r24, 0x2D	; 45
    1af8:	90 e0       	ldi	r25, 0x00	; 0
    1afa:	0e 94 13 0a 	call	0x1426	; 0x1426 <servo2_mov>
    1afe:	8f ef       	ldi	r24, 0xFF	; 255
    1b00:	9f e7       	ldi	r25, 0x7F	; 127
    1b02:	a4 e0       	ldi	r26, 0x04	; 4
    1b04:	81 50       	subi	r24, 0x01	; 1
    1b06:	90 40       	sbci	r25, 0x00	; 0
    1b08:	a0 40       	sbci	r26, 0x00	; 0
    1b0a:	e1 f7       	brne	.-8      	; 0x1b04 <node_behave+0x3c4>
    1b0c:	00 c0       	rjmp	.+0      	; 0x1b0e <node_behave+0x3ce>
    1b0e:	00 00       	nop
				_delay_ms(100);
				servo1_mov(80);
    1b10:	80 e5       	ldi	r24, 0x50	; 80
    1b12:	90 e0       	ldi	r25, 0x00	; 0
    1b14:	0e 94 c9 09 	call	0x1392	; 0x1392 <servo1_mov>
    1b18:	8f ef       	ldi	r24, 0xFF	; 255
    1b1a:	9f ef       	ldi	r25, 0xFF	; 255
    1b1c:	ac e2       	ldi	r26, 0x2C	; 44
    1b1e:	81 50       	subi	r24, 0x01	; 1
    1b20:	90 40       	sbci	r25, 0x00	; 0
    1b22:	a0 40       	sbci	r26, 0x00	; 0
    1b24:	e1 f7       	brne	.-8      	; 0x1b1e <node_behave+0x3de>
    1b26:	00 c0       	rjmp	.+0      	; 0x1b28 <node_behave+0x3e8>
    1b28:	00 00       	nop
				_delay_ms(1000);
				servo2_free();
    1b2a:	0e 94 41 0a 	call	0x1482	; 0x1482 <servo2_free>
				if(node_number==15)
    1b2e:	80 91 5f 02 	lds	r24, 0x025F
    1b32:	90 91 60 02 	lds	r25, 0x0260
    1b36:	8f 30       	cpi	r24, 0x0F	; 15
    1b38:	91 05       	cpc	r25, r1
    1b3a:	51 f4       	brne	.+20     	; 0x1b50 <node_behave+0x410>
				deposition_zone_A--;
    1b3c:	80 91 3b 02 	lds	r24, 0x023B
    1b40:	90 91 3c 02 	lds	r25, 0x023C
    1b44:	01 97       	sbiw	r24, 0x01	; 1
    1b46:	90 93 3c 02 	sts	0x023C, r25
    1b4a:	80 93 3b 02 	sts	0x023B, r24
    1b4e:	19 c0       	rjmp	.+50     	; 0x1b82 <node_behave+0x442>
				if(node_number==16)
    1b50:	80 31       	cpi	r24, 0x10	; 16
    1b52:	91 05       	cpc	r25, r1
    1b54:	51 f4       	brne	.+20     	; 0x1b6a <node_behave+0x42a>
				deposition_zone_B--;
    1b56:	80 91 39 02 	lds	r24, 0x0239
    1b5a:	90 91 3a 02 	lds	r25, 0x023A
    1b5e:	01 97       	sbiw	r24, 0x01	; 1
    1b60:	90 93 3a 02 	sts	0x023A, r25
    1b64:	80 93 39 02 	sts	0x0239, r24
    1b68:	0c c0       	rjmp	.+24     	; 0x1b82 <node_behave+0x442>
				if(node_number==17)
    1b6a:	81 31       	cpi	r24, 0x11	; 17
    1b6c:	91 05       	cpc	r25, r1
    1b6e:	49 f4       	brne	.+18     	; 0x1b82 <node_behave+0x442>
				deposition_zone_C--;
    1b70:	80 91 37 02 	lds	r24, 0x0237
    1b74:	90 91 38 02 	lds	r25, 0x0238
    1b78:	01 97       	sbiw	r24, 0x01	; 1
    1b7a:	90 93 38 02 	sts	0x0238, r25
    1b7e:	80 93 37 02 	sts	0x0237, r24
				path_find(10);
    1b82:	8a e0       	ldi	r24, 0x0A	; 10
    1b84:	90 e0       	ldi	r25, 0x00	; 0
    1b86:	0e 94 e3 05 	call	0xbc6	; 0xbc6 <path_find>
				distance('b',6,'o');
    1b8a:	82 e6       	ldi	r24, 0x62	; 98
    1b8c:	40 e0       	ldi	r20, 0x00	; 0
    1b8e:	50 e0       	ldi	r21, 0x00	; 0
    1b90:	60 ec       	ldi	r22, 0xC0	; 192
    1b92:	70 e4       	ldi	r23, 0x40	; 64
    1b94:	2f e6       	ldi	r18, 0x6F	; 111
    1b96:	0e 94 8a 07 	call	0xf14	; 0xf14 <distance>
    1b9a:	26 c0       	rjmp	.+76     	; 0x1be8 <node_behave+0x4a8>
			}
			else
			{
				distance('b',6,'o');
    1b9c:	82 e6       	ldi	r24, 0x62	; 98
    1b9e:	40 e0       	ldi	r20, 0x00	; 0
    1ba0:	50 e0       	ldi	r21, 0x00	; 0
    1ba2:	60 ec       	ldi	r22, 0xC0	; 192
    1ba4:	70 e4       	ldi	r23, 0x40	; 64
    1ba6:	2f e6       	ldi	r18, 0x6F	; 111
    1ba8:	0e 94 8a 07 	call	0xf14	; 0xf14 <distance>
				if(deposition_zone_A==1 && node_number!=15)
    1bac:	80 91 3b 02 	lds	r24, 0x023B
    1bb0:	90 91 3c 02 	lds	r25, 0x023C
    1bb4:	81 30       	cpi	r24, 0x01	; 1
    1bb6:	91 05       	cpc	r25, r1
    1bb8:	61 f4       	brne	.+24     	; 0x1bd2 <node_behave+0x492>
    1bba:	80 91 5f 02 	lds	r24, 0x025F
    1bbe:	90 91 60 02 	lds	r25, 0x0260
    1bc2:	8f 30       	cpi	r24, 0x0F	; 15
    1bc4:	91 05       	cpc	r25, r1
    1bc6:	29 f0       	breq	.+10     	; 0x1bd2 <node_behave+0x492>
				enq_end(15);
    1bc8:	8f e0       	ldi	r24, 0x0F	; 15
    1bca:	90 e0       	ldi	r25, 0x00	; 0
    1bcc:	0e 94 d8 06 	call	0xdb0	; 0xdb0 <enq_end>
    1bd0:	0b c0       	rjmp	.+22     	; 0x1be8 <node_behave+0x4a8>
				else if(deposition_zone_C==1)
    1bd2:	80 91 37 02 	lds	r24, 0x0237
    1bd6:	90 91 38 02 	lds	r25, 0x0238
    1bda:	81 30       	cpi	r24, 0x01	; 1
    1bdc:	91 05       	cpc	r25, r1
    1bde:	21 f4       	brne	.+8      	; 0x1be8 <node_behave+0x4a8>
				enq_end(17);
    1be0:	81 e1       	ldi	r24, 0x11	; 17
    1be2:	90 e0       	ldi	r25, 0x00	; 0
    1be4:	0e 94 d8 06 	call	0xdb0	; 0xdb0 <enq_end>
			}
		}
		if(node_number==1)
    1be8:	80 91 5f 02 	lds	r24, 0x025F
    1bec:	90 91 60 02 	lds	r25, 0x0260
    1bf0:	81 30       	cpi	r24, 0x01	; 1
    1bf2:	91 05       	cpc	r25, r1
    1bf4:	09 f0       	breq	.+2      	; 0x1bf8 <node_behave+0x4b8>
    1bf6:	9c c0       	rjmp	.+312    	; 0x1d30 <node_behave+0x5f0>
		{
			distance('f',10,'o');
    1bf8:	86 e6       	ldi	r24, 0x66	; 102
    1bfa:	40 e0       	ldi	r20, 0x00	; 0
    1bfc:	50 e0       	ldi	r21, 0x00	; 0
    1bfe:	60 e2       	ldi	r22, 0x20	; 32
    1c00:	71 e4       	ldi	r23, 0x41	; 65
    1c02:	2f e6       	ldi	r18, 0x6F	; 111
    1c04:	0e 94 8a 07 	call	0xf14	; 0xf14 <distance>
			left();
    1c08:	0e 94 14 08 	call	0x1028	; 0x1028 <left>
			navigation_in_degrees=navigation_in_degrees+90;
    1c0c:	80 91 3d 02 	lds	r24, 0x023D
    1c10:	90 91 3e 02 	lds	r25, 0x023E
    1c14:	86 5a       	subi	r24, 0xA6	; 166
    1c16:	9f 4f       	sbci	r25, 0xFF	; 255
    1c18:	90 93 3e 02 	sts	0x023E, r25
    1c1c:	80 93 3d 02 	sts	0x023D, r24
			angle_rotate(105);
    1c20:	89 e6       	ldi	r24, 0x69	; 105
    1c22:	90 e0       	ldi	r25, 0x00	; 0
    1c24:	0e 94 24 08 	call	0x1048	; 0x1048 <angle_rotate>
			stop();
    1c28:	0e 94 10 08 	call	0x1020	; 0x1020 <stop>
			if(weight_block_position_1==2)
    1c2c:	80 91 33 02 	lds	r24, 0x0233
    1c30:	90 91 34 02 	lds	r25, 0x0234
    1c34:	82 30       	cpi	r24, 0x02	; 2
    1c36:	91 05       	cpc	r25, r1
    1c38:	91 f5       	brne	.+100    	; 0x1c9e <node_behave+0x55e>
			{
				distance('f',3,'o');
    1c3a:	86 e6       	ldi	r24, 0x66	; 102
    1c3c:	40 e0       	ldi	r20, 0x00	; 0
    1c3e:	50 e0       	ldi	r21, 0x00	; 0
    1c40:	60 e4       	ldi	r22, 0x40	; 64
    1c42:	70 e4       	ldi	r23, 0x40	; 64
    1c44:	2f e6       	ldi	r18, 0x6F	; 111
    1c46:	0e 94 8a 07 	call	0xf14	; 0xf14 <distance>
				servo1_mov(16);
    1c4a:	80 e1       	ldi	r24, 0x10	; 16
    1c4c:	90 e0       	ldi	r25, 0x00	; 0
    1c4e:	0e 94 c9 09 	call	0x1392	; 0x1392 <servo1_mov>
    1c52:	8f ef       	ldi	r24, 0xFF	; 255
    1c54:	9f ef       	ldi	r25, 0xFF	; 255
    1c56:	ac e2       	ldi	r26, 0x2C	; 44
    1c58:	81 50       	subi	r24, 0x01	; 1
    1c5a:	90 40       	sbci	r25, 0x00	; 0
    1c5c:	a0 40       	sbci	r26, 0x00	; 0
    1c5e:	e1 f7       	brne	.-8      	; 0x1c58 <node_behave+0x518>
    1c60:	00 c0       	rjmp	.+0      	; 0x1c62 <node_behave+0x522>
    1c62:	00 00       	nop
				_delay_ms(1000);
				servo2_mov(1);
    1c64:	81 e0       	ldi	r24, 0x01	; 1
    1c66:	90 e0       	ldi	r25, 0x00	; 0
    1c68:	0e 94 13 0a 	call	0x1426	; 0x1426 <servo2_mov>
    1c6c:	8f ef       	ldi	r24, 0xFF	; 255
    1c6e:	9f ef       	ldi	r25, 0xFF	; 255
    1c70:	ac e2       	ldi	r26, 0x2C	; 44
    1c72:	81 50       	subi	r24, 0x01	; 1
    1c74:	90 40       	sbci	r25, 0x00	; 0
    1c76:	a0 40       	sbci	r26, 0x00	; 0
    1c78:	e1 f7       	brne	.-8      	; 0x1c72 <node_behave+0x532>
    1c7a:	00 c0       	rjmp	.+0      	; 0x1c7c <node_behave+0x53c>
    1c7c:	00 00       	nop
				_delay_ms(1000);
				servo1_mov(130);
    1c7e:	82 e8       	ldi	r24, 0x82	; 130
    1c80:	90 e0       	ldi	r25, 0x00	; 0
    1c82:	0e 94 c9 09 	call	0x1392	; 0x1392 <servo1_mov>
    1c86:	8f ef       	ldi	r24, 0xFF	; 255
    1c88:	9f e7       	ldi	r25, 0x7F	; 127
    1c8a:	a1 e3       	ldi	r26, 0x31	; 49
    1c8c:	81 50       	subi	r24, 0x01	; 1
    1c8e:	90 40       	sbci	r25, 0x00	; 0
    1c90:	a0 40       	sbci	r26, 0x00	; 0
    1c92:	e1 f7       	brne	.-8      	; 0x1c8c <node_behave+0x54c>
    1c94:	00 c0       	rjmp	.+0      	; 0x1c96 <node_behave+0x556>
    1c96:	00 00       	nop
				_delay_ms(1100);
				servo1_free();
    1c98:	0e 94 3a 0a 	call	0x1474	; 0x1474 <servo1_free>
    1c9c:	34 c0       	rjmp	.+104    	; 0x1d06 <node_behave+0x5c6>
			}
			else if(weight_block_position_1==1)
    1c9e:	81 30       	cpi	r24, 0x01	; 1
    1ca0:	91 05       	cpc	r25, r1
    1ca2:	89 f5       	brne	.+98     	; 0x1d06 <node_behave+0x5c6>
			{
				distance('f',4,'o');
    1ca4:	86 e6       	ldi	r24, 0x66	; 102
    1ca6:	40 e0       	ldi	r20, 0x00	; 0
    1ca8:	50 e0       	ldi	r21, 0x00	; 0
    1caa:	60 e8       	ldi	r22, 0x80	; 128
    1cac:	70 e4       	ldi	r23, 0x40	; 64
    1cae:	2f e6       	ldi	r18, 0x6F	; 111
    1cb0:	0e 94 8a 07 	call	0xf14	; 0xf14 <distance>
				servo1_mov(11);
    1cb4:	8b e0       	ldi	r24, 0x0B	; 11
    1cb6:	90 e0       	ldi	r25, 0x00	; 0
    1cb8:	0e 94 c9 09 	call	0x1392	; 0x1392 <servo1_mov>
    1cbc:	8f ef       	ldi	r24, 0xFF	; 255
    1cbe:	9f ef       	ldi	r25, 0xFF	; 255
    1cc0:	ac e2       	ldi	r26, 0x2C	; 44
    1cc2:	81 50       	subi	r24, 0x01	; 1
    1cc4:	90 40       	sbci	r25, 0x00	; 0
    1cc6:	a0 40       	sbci	r26, 0x00	; 0
    1cc8:	e1 f7       	brne	.-8      	; 0x1cc2 <node_behave+0x582>
    1cca:	00 c0       	rjmp	.+0      	; 0x1ccc <node_behave+0x58c>
    1ccc:	00 00       	nop
				_delay_ms(1000);
				servo2_mov(1);
    1cce:	81 e0       	ldi	r24, 0x01	; 1
    1cd0:	90 e0       	ldi	r25, 0x00	; 0
    1cd2:	0e 94 13 0a 	call	0x1426	; 0x1426 <servo2_mov>
    1cd6:	8f ef       	ldi	r24, 0xFF	; 255
    1cd8:	9f ef       	ldi	r25, 0xFF	; 255
    1cda:	ac e2       	ldi	r26, 0x2C	; 44
    1cdc:	81 50       	subi	r24, 0x01	; 1
    1cde:	90 40       	sbci	r25, 0x00	; 0
    1ce0:	a0 40       	sbci	r26, 0x00	; 0
    1ce2:	e1 f7       	brne	.-8      	; 0x1cdc <node_behave+0x59c>
    1ce4:	00 c0       	rjmp	.+0      	; 0x1ce6 <node_behave+0x5a6>
    1ce6:	00 00       	nop
				_delay_ms(1000);
				servo1_mov(130);
    1ce8:	82 e8       	ldi	r24, 0x82	; 130
    1cea:	90 e0       	ldi	r25, 0x00	; 0
    1cec:	0e 94 c9 09 	call	0x1392	; 0x1392 <servo1_mov>
    1cf0:	8f ef       	ldi	r24, 0xFF	; 255
    1cf2:	9f e7       	ldi	r25, 0x7F	; 127
    1cf4:	a1 e3       	ldi	r26, 0x31	; 49
    1cf6:	81 50       	subi	r24, 0x01	; 1
    1cf8:	90 40       	sbci	r25, 0x00	; 0
    1cfa:	a0 40       	sbci	r26, 0x00	; 0
    1cfc:	e1 f7       	brne	.-8      	; 0x1cf6 <node_behave+0x5b6>
    1cfe:	00 c0       	rjmp	.+0      	; 0x1d00 <node_behave+0x5c0>
    1d00:	00 00       	nop
				_delay_ms(1100);
				servo1_free();
    1d02:	0e 94 3a 0a 	call	0x1474	; 0x1474 <servo1_free>
			}
			weight_block_position_1--;
    1d06:	80 91 33 02 	lds	r24, 0x0233
    1d0a:	90 91 34 02 	lds	r25, 0x0234
    1d0e:	01 97       	sbiw	r24, 0x01	; 1
    1d10:	90 93 34 02 	sts	0x0234, r25
    1d14:	80 93 33 02 	sts	0x0233, r24
			distance('b',14,'o');
    1d18:	82 e6       	ldi	r24, 0x62	; 98
    1d1a:	40 e0       	ldi	r20, 0x00	; 0
    1d1c:	50 e0       	ldi	r21, 0x00	; 0
    1d1e:	60 e6       	ldi	r22, 0x60	; 96
    1d20:	71 e4       	ldi	r23, 0x41	; 65
    1d22:	2f e6       	ldi	r18, 0x6F	; 111
    1d24:	0e 94 8a 07 	call	0xf14	; 0xf14 <distance>
			enq_end(4);
    1d28:	84 e0       	ldi	r24, 0x04	; 4
    1d2a:	90 e0       	ldi	r25, 0x00	; 0
    1d2c:	0e 94 d8 06 	call	0xdb0	; 0xdb0 <enq_end>
		}

		if(node_number==13)
    1d30:	80 91 5f 02 	lds	r24, 0x025F
    1d34:	90 91 60 02 	lds	r25, 0x0260
    1d38:	8d 30       	cpi	r24, 0x0D	; 13
    1d3a:	91 05       	cpc	r25, r1
    1d3c:	09 f0       	breq	.+2      	; 0x1d40 <node_behave+0x600>
    1d3e:	1e c1       	rjmp	.+572    	; 0x1f7c <node_behave+0x83c>
		{
			if(weight_block_position_5!=0)
    1d40:	80 91 2b 02 	lds	r24, 0x022B
    1d44:	90 91 2c 02 	lds	r25, 0x022C
    1d48:	00 97       	sbiw	r24, 0x00	; 0
    1d4a:	09 f4       	brne	.+2      	; 0x1d4e <node_behave+0x60e>
    1d4c:	7b c0       	rjmp	.+246    	; 0x1e44 <node_behave+0x704>
			{
				distance('f',12,'o');
    1d4e:	86 e6       	ldi	r24, 0x66	; 102
    1d50:	40 e0       	ldi	r20, 0x00	; 0
    1d52:	50 e0       	ldi	r21, 0x00	; 0
    1d54:	60 e4       	ldi	r22, 0x40	; 64
    1d56:	71 e4       	ldi	r23, 0x41	; 65
    1d58:	2f e6       	ldi	r18, 0x6F	; 111
    1d5a:	0e 94 8a 07 	call	0xf14	; 0xf14 <distance>
				if(weight_block_position_5==2)
    1d5e:	80 91 2b 02 	lds	r24, 0x022B
    1d62:	90 91 2c 02 	lds	r25, 0x022C
    1d66:	82 30       	cpi	r24, 0x02	; 2
    1d68:	91 05       	cpc	r25, r1
    1d6a:	51 f5       	brne	.+84     	; 0x1dc0 <node_behave+0x680>
				{
					servo1_mov(16);
    1d6c:	80 e1       	ldi	r24, 0x10	; 16
    1d6e:	90 e0       	ldi	r25, 0x00	; 0
    1d70:	0e 94 c9 09 	call	0x1392	; 0x1392 <servo1_mov>
    1d74:	8f ef       	ldi	r24, 0xFF	; 255
    1d76:	9f ef       	ldi	r25, 0xFF	; 255
    1d78:	ac e2       	ldi	r26, 0x2C	; 44
    1d7a:	81 50       	subi	r24, 0x01	; 1
    1d7c:	90 40       	sbci	r25, 0x00	; 0
    1d7e:	a0 40       	sbci	r26, 0x00	; 0
    1d80:	e1 f7       	brne	.-8      	; 0x1d7a <node_behave+0x63a>
    1d82:	00 c0       	rjmp	.+0      	; 0x1d84 <node_behave+0x644>
    1d84:	00 00       	nop
					_delay_ms(1000);
					servo2_mov(1);
    1d86:	81 e0       	ldi	r24, 0x01	; 1
    1d88:	90 e0       	ldi	r25, 0x00	; 0
    1d8a:	0e 94 13 0a 	call	0x1426	; 0x1426 <servo2_mov>
    1d8e:	8f ef       	ldi	r24, 0xFF	; 255
    1d90:	9f ef       	ldi	r25, 0xFF	; 255
    1d92:	ac e2       	ldi	r26, 0x2C	; 44
    1d94:	81 50       	subi	r24, 0x01	; 1
    1d96:	90 40       	sbci	r25, 0x00	; 0
    1d98:	a0 40       	sbci	r26, 0x00	; 0
    1d9a:	e1 f7       	brne	.-8      	; 0x1d94 <node_behave+0x654>
    1d9c:	00 c0       	rjmp	.+0      	; 0x1d9e <node_behave+0x65e>
    1d9e:	00 00       	nop
					_delay_ms(1000);
					servo1_mov(130);
    1da0:	82 e8       	ldi	r24, 0x82	; 130
    1da2:	90 e0       	ldi	r25, 0x00	; 0
    1da4:	0e 94 c9 09 	call	0x1392	; 0x1392 <servo1_mov>
    1da8:	8f ef       	ldi	r24, 0xFF	; 255
    1daa:	9f e7       	ldi	r25, 0x7F	; 127
    1dac:	a1 e3       	ldi	r26, 0x31	; 49
    1dae:	81 50       	subi	r24, 0x01	; 1
    1db0:	90 40       	sbci	r25, 0x00	; 0
    1db2:	a0 40       	sbci	r26, 0x00	; 0
    1db4:	e1 f7       	brne	.-8      	; 0x1dae <node_behave+0x66e>
    1db6:	00 c0       	rjmp	.+0      	; 0x1db8 <node_behave+0x678>
    1db8:	00 00       	nop
					_delay_ms(1100);
					servo1_free();
    1dba:	0e 94 3a 0a 	call	0x1474	; 0x1474 <servo1_free>
    1dbe:	2c c0       	rjmp	.+88     	; 0x1e18 <node_behave+0x6d8>
				}
				else if(weight_block_position_5==1)
    1dc0:	81 30       	cpi	r24, 0x01	; 1
    1dc2:	91 05       	cpc	r25, r1
    1dc4:	49 f5       	brne	.+82     	; 0x1e18 <node_behave+0x6d8>
				{
					servo1_mov(11);
    1dc6:	8b e0       	ldi	r24, 0x0B	; 11
    1dc8:	90 e0       	ldi	r25, 0x00	; 0
    1dca:	0e 94 c9 09 	call	0x1392	; 0x1392 <servo1_mov>
    1dce:	8f ef       	ldi	r24, 0xFF	; 255
    1dd0:	9f ef       	ldi	r25, 0xFF	; 255
    1dd2:	ac e2       	ldi	r26, 0x2C	; 44
    1dd4:	81 50       	subi	r24, 0x01	; 1
    1dd6:	90 40       	sbci	r25, 0x00	; 0
    1dd8:	a0 40       	sbci	r26, 0x00	; 0
    1dda:	e1 f7       	brne	.-8      	; 0x1dd4 <node_behave+0x694>
    1ddc:	00 c0       	rjmp	.+0      	; 0x1dde <node_behave+0x69e>
    1dde:	00 00       	nop
					_delay_ms(1000);
					servo2_mov(1);
    1de0:	81 e0       	ldi	r24, 0x01	; 1
    1de2:	90 e0       	ldi	r25, 0x00	; 0
    1de4:	0e 94 13 0a 	call	0x1426	; 0x1426 <servo2_mov>
    1de8:	8f ef       	ldi	r24, 0xFF	; 255
    1dea:	9f ef       	ldi	r25, 0xFF	; 255
    1dec:	ac e2       	ldi	r26, 0x2C	; 44
    1dee:	81 50       	subi	r24, 0x01	; 1
    1df0:	90 40       	sbci	r25, 0x00	; 0
    1df2:	a0 40       	sbci	r26, 0x00	; 0
    1df4:	e1 f7       	brne	.-8      	; 0x1dee <node_behave+0x6ae>
    1df6:	00 c0       	rjmp	.+0      	; 0x1df8 <node_behave+0x6b8>
    1df8:	00 00       	nop
					_delay_ms(1000);
					servo1_mov(130);
    1dfa:	82 e8       	ldi	r24, 0x82	; 130
    1dfc:	90 e0       	ldi	r25, 0x00	; 0
    1dfe:	0e 94 c9 09 	call	0x1392	; 0x1392 <servo1_mov>
    1e02:	8f ef       	ldi	r24, 0xFF	; 255
    1e04:	9f e7       	ldi	r25, 0x7F	; 127
    1e06:	a1 e3       	ldi	r26, 0x31	; 49
    1e08:	81 50       	subi	r24, 0x01	; 1
    1e0a:	90 40       	sbci	r25, 0x00	; 0
    1e0c:	a0 40       	sbci	r26, 0x00	; 0
    1e0e:	e1 f7       	brne	.-8      	; 0x1e08 <node_behave+0x6c8>
    1e10:	00 c0       	rjmp	.+0      	; 0x1e12 <node_behave+0x6d2>
    1e12:	00 00       	nop
					_delay_ms(1100);
					servo1_free();
    1e14:	0e 94 3a 0a 	call	0x1474	; 0x1474 <servo1_free>
				}
				weight_block_position_5--;
    1e18:	80 91 2b 02 	lds	r24, 0x022B
    1e1c:	90 91 2c 02 	lds	r25, 0x022C
    1e20:	01 97       	sbiw	r24, 0x01	; 1
    1e22:	90 93 2c 02 	sts	0x022C, r25
    1e26:	80 93 2b 02 	sts	0x022B, r24
				distance('b',14,'o');
    1e2a:	82 e6       	ldi	r24, 0x62	; 98
    1e2c:	40 e0       	ldi	r20, 0x00	; 0
    1e2e:	50 e0       	ldi	r21, 0x00	; 0
    1e30:	60 e6       	ldi	r22, 0x60	; 96
    1e32:	71 e4       	ldi	r23, 0x41	; 65
    1e34:	2f e6       	ldi	r18, 0x6F	; 111
    1e36:	0e 94 8a 07 	call	0xf14	; 0xf14 <distance>
				enq_end(14);
    1e3a:	8e e0       	ldi	r24, 0x0E	; 14
    1e3c:	90 e0       	ldi	r25, 0x00	; 0
    1e3e:	0e 94 d8 06 	call	0xdb0	; 0xdb0 <enq_end>
    1e42:	9c c0       	rjmp	.+312    	; 0x1f7c <node_behave+0x83c>
			}
			else
			{
				distance('f',11,'o');
    1e44:	86 e6       	ldi	r24, 0x66	; 102
    1e46:	40 e0       	ldi	r20, 0x00	; 0
    1e48:	50 e0       	ldi	r21, 0x00	; 0
    1e4a:	60 e3       	ldi	r22, 0x30	; 48
    1e4c:	71 e4       	ldi	r23, 0x41	; 65
    1e4e:	2f e6       	ldi	r18, 0x6F	; 111
    1e50:	0e 94 8a 07 	call	0xf14	; 0xf14 <distance>
				left();
    1e54:	0e 94 14 08 	call	0x1028	; 0x1028 <left>
				navigation_in_degrees=navigation_in_degrees+90;
    1e58:	80 91 3d 02 	lds	r24, 0x023D
    1e5c:	90 91 3e 02 	lds	r25, 0x023E
    1e60:	86 5a       	subi	r24, 0xA6	; 166
    1e62:	9f 4f       	sbci	r25, 0xFF	; 255
    1e64:	90 93 3e 02 	sts	0x023E, r25
    1e68:	80 93 3d 02 	sts	0x023D, r24
				angle_rotate(97);
    1e6c:	81 e6       	ldi	r24, 0x61	; 97
    1e6e:	90 e0       	ldi	r25, 0x00	; 0
    1e70:	0e 94 24 08 	call	0x1048	; 0x1048 <angle_rotate>
				stop();
    1e74:	0e 94 10 08 	call	0x1020	; 0x1020 <stop>
				if(weight_block_position_4==2)
    1e78:	80 91 2d 02 	lds	r24, 0x022D
    1e7c:	90 91 2e 02 	lds	r25, 0x022E
    1e80:	82 30       	cpi	r24, 0x02	; 2
    1e82:	91 05       	cpc	r25, r1
    1e84:	91 f5       	brne	.+100    	; 0x1eea <node_behave+0x7aa>
				{
					distance('f',4,'o');
    1e86:	86 e6       	ldi	r24, 0x66	; 102
    1e88:	40 e0       	ldi	r20, 0x00	; 0
    1e8a:	50 e0       	ldi	r21, 0x00	; 0
    1e8c:	60 e8       	ldi	r22, 0x80	; 128
    1e8e:	70 e4       	ldi	r23, 0x40	; 64
    1e90:	2f e6       	ldi	r18, 0x6F	; 111
    1e92:	0e 94 8a 07 	call	0xf14	; 0xf14 <distance>
					servo1_mov(16);
    1e96:	80 e1       	ldi	r24, 0x10	; 16
    1e98:	90 e0       	ldi	r25, 0x00	; 0
    1e9a:	0e 94 c9 09 	call	0x1392	; 0x1392 <servo1_mov>
    1e9e:	8f ef       	ldi	r24, 0xFF	; 255
    1ea0:	9f ef       	ldi	r25, 0xFF	; 255
    1ea2:	ac e2       	ldi	r26, 0x2C	; 44
    1ea4:	81 50       	subi	r24, 0x01	; 1
    1ea6:	90 40       	sbci	r25, 0x00	; 0
    1ea8:	a0 40       	sbci	r26, 0x00	; 0
    1eaa:	e1 f7       	brne	.-8      	; 0x1ea4 <node_behave+0x764>
    1eac:	00 c0       	rjmp	.+0      	; 0x1eae <node_behave+0x76e>
    1eae:	00 00       	nop
					_delay_ms(1000);
					servo2_mov(1);
    1eb0:	81 e0       	ldi	r24, 0x01	; 1
    1eb2:	90 e0       	ldi	r25, 0x00	; 0
    1eb4:	0e 94 13 0a 	call	0x1426	; 0x1426 <servo2_mov>
    1eb8:	8f ef       	ldi	r24, 0xFF	; 255
    1eba:	9f ef       	ldi	r25, 0xFF	; 255
    1ebc:	ac e2       	ldi	r26, 0x2C	; 44
    1ebe:	81 50       	subi	r24, 0x01	; 1
    1ec0:	90 40       	sbci	r25, 0x00	; 0
    1ec2:	a0 40       	sbci	r26, 0x00	; 0
    1ec4:	e1 f7       	brne	.-8      	; 0x1ebe <node_behave+0x77e>
    1ec6:	00 c0       	rjmp	.+0      	; 0x1ec8 <node_behave+0x788>
    1ec8:	00 00       	nop
					_delay_ms(1000);
					servo1_mov(130);
    1eca:	82 e8       	ldi	r24, 0x82	; 130
    1ecc:	90 e0       	ldi	r25, 0x00	; 0
    1ece:	0e 94 c9 09 	call	0x1392	; 0x1392 <servo1_mov>
    1ed2:	8f ef       	ldi	r24, 0xFF	; 255
    1ed4:	9f e7       	ldi	r25, 0x7F	; 127
    1ed6:	a1 e3       	ldi	r26, 0x31	; 49
    1ed8:	81 50       	subi	r24, 0x01	; 1
    1eda:	90 40       	sbci	r25, 0x00	; 0
    1edc:	a0 40       	sbci	r26, 0x00	; 0
    1ede:	e1 f7       	brne	.-8      	; 0x1ed8 <node_behave+0x798>
    1ee0:	00 c0       	rjmp	.+0      	; 0x1ee2 <node_behave+0x7a2>
    1ee2:	00 00       	nop
					_delay_ms(1100);
					servo1_free();
    1ee4:	0e 94 3a 0a 	call	0x1474	; 0x1474 <servo1_free>
    1ee8:	34 c0       	rjmp	.+104    	; 0x1f52 <node_behave+0x812>
				}
				else if(weight_block_position_4==1)
    1eea:	81 30       	cpi	r24, 0x01	; 1
    1eec:	91 05       	cpc	r25, r1
    1eee:	89 f5       	brne	.+98     	; 0x1f52 <node_behave+0x812>
				{
					distance('f',4,'o');
    1ef0:	86 e6       	ldi	r24, 0x66	; 102
    1ef2:	40 e0       	ldi	r20, 0x00	; 0
    1ef4:	50 e0       	ldi	r21, 0x00	; 0
    1ef6:	60 e8       	ldi	r22, 0x80	; 128
    1ef8:	70 e4       	ldi	r23, 0x40	; 64
    1efa:	2f e6       	ldi	r18, 0x6F	; 111
    1efc:	0e 94 8a 07 	call	0xf14	; 0xf14 <distance>
					servo1_mov(11);
    1f00:	8b e0       	ldi	r24, 0x0B	; 11
    1f02:	90 e0       	ldi	r25, 0x00	; 0
    1f04:	0e 94 c9 09 	call	0x1392	; 0x1392 <servo1_mov>
    1f08:	8f ef       	ldi	r24, 0xFF	; 255
    1f0a:	9f ef       	ldi	r25, 0xFF	; 255
    1f0c:	ac e2       	ldi	r26, 0x2C	; 44
    1f0e:	81 50       	subi	r24, 0x01	; 1
    1f10:	90 40       	sbci	r25, 0x00	; 0
    1f12:	a0 40       	sbci	r26, 0x00	; 0
    1f14:	e1 f7       	brne	.-8      	; 0x1f0e <node_behave+0x7ce>
    1f16:	00 c0       	rjmp	.+0      	; 0x1f18 <node_behave+0x7d8>
    1f18:	00 00       	nop
					_delay_ms(1000);
					servo2_mov(1);
    1f1a:	81 e0       	ldi	r24, 0x01	; 1
    1f1c:	90 e0       	ldi	r25, 0x00	; 0
    1f1e:	0e 94 13 0a 	call	0x1426	; 0x1426 <servo2_mov>
    1f22:	8f ef       	ldi	r24, 0xFF	; 255
    1f24:	9f ef       	ldi	r25, 0xFF	; 255
    1f26:	ac e2       	ldi	r26, 0x2C	; 44
    1f28:	81 50       	subi	r24, 0x01	; 1
    1f2a:	90 40       	sbci	r25, 0x00	; 0
    1f2c:	a0 40       	sbci	r26, 0x00	; 0
    1f2e:	e1 f7       	brne	.-8      	; 0x1f28 <node_behave+0x7e8>
    1f30:	00 c0       	rjmp	.+0      	; 0x1f32 <node_behave+0x7f2>
    1f32:	00 00       	nop
					_delay_ms(1000);
					servo1_mov(130);
    1f34:	82 e8       	ldi	r24, 0x82	; 130
    1f36:	90 e0       	ldi	r25, 0x00	; 0
    1f38:	0e 94 c9 09 	call	0x1392	; 0x1392 <servo1_mov>
    1f3c:	8f ef       	ldi	r24, 0xFF	; 255
    1f3e:	9f e7       	ldi	r25, 0x7F	; 127
    1f40:	a1 e3       	ldi	r26, 0x31	; 49
    1f42:	81 50       	subi	r24, 0x01	; 1
    1f44:	90 40       	sbci	r25, 0x00	; 0
    1f46:	a0 40       	sbci	r26, 0x00	; 0
    1f48:	e1 f7       	brne	.-8      	; 0x1f42 <node_behave+0x802>
    1f4a:	00 c0       	rjmp	.+0      	; 0x1f4c <node_behave+0x80c>
    1f4c:	00 00       	nop
					_delay_ms(1100);
					servo1_free();
    1f4e:	0e 94 3a 0a 	call	0x1474	; 0x1474 <servo1_free>
				}
			weight_block_position_4--;
    1f52:	80 91 2d 02 	lds	r24, 0x022D
    1f56:	90 91 2e 02 	lds	r25, 0x022E
    1f5a:	01 97       	sbiw	r24, 0x01	; 1
    1f5c:	90 93 2e 02 	sts	0x022E, r25
    1f60:	80 93 2d 02 	sts	0x022D, r24
			distance('b',14,'o');
    1f64:	82 e6       	ldi	r24, 0x62	; 98
    1f66:	40 e0       	ldi	r20, 0x00	; 0
    1f68:	50 e0       	ldi	r21, 0x00	; 0
    1f6a:	60 e6       	ldi	r22, 0x60	; 96
    1f6c:	71 e4       	ldi	r23, 0x41	; 65
    1f6e:	2f e6       	ldi	r18, 0x6F	; 111
    1f70:	0e 94 8a 07 	call	0xf14	; 0xf14 <distance>
			enq_end(14);
    1f74:	8e e0       	ldi	r24, 0x0E	; 14
    1f76:	90 e0       	ldi	r25, 0x00	; 0
    1f78:	0e 94 d8 06 	call	0xdb0	; 0xdb0 <enq_end>
			}
		}

		if(node_number==3)
    1f7c:	80 91 5f 02 	lds	r24, 0x025F
    1f80:	90 91 60 02 	lds	r25, 0x0260
    1f84:	83 30       	cpi	r24, 0x03	; 3
    1f86:	91 05       	cpc	r25, r1
    1f88:	09 f0       	breq	.+2      	; 0x1f8c <node_behave+0x84c>
    1f8a:	82 c0       	rjmp	.+260    	; 0x2090 <node_behave+0x950>
		{
			distance('f',12.5,'o');
    1f8c:	86 e6       	ldi	r24, 0x66	; 102
    1f8e:	40 e0       	ldi	r20, 0x00	; 0
    1f90:	50 e0       	ldi	r21, 0x00	; 0
    1f92:	68 e4       	ldi	r22, 0x48	; 72
    1f94:	71 e4       	ldi	r23, 0x41	; 65
    1f96:	2f e6       	ldi	r18, 0x6F	; 111
    1f98:	0e 94 8a 07 	call	0xf14	; 0xf14 <distance>
			if(weight_block_position_2==2)
    1f9c:	80 91 31 02 	lds	r24, 0x0231
    1fa0:	90 91 32 02 	lds	r25, 0x0232
    1fa4:	82 30       	cpi	r24, 0x02	; 2
    1fa6:	91 05       	cpc	r25, r1
    1fa8:	51 f5       	brne	.+84     	; 0x1ffe <node_behave+0x8be>
			{
				servo1_mov(16);
    1faa:	80 e1       	ldi	r24, 0x10	; 16
    1fac:	90 e0       	ldi	r25, 0x00	; 0
    1fae:	0e 94 c9 09 	call	0x1392	; 0x1392 <servo1_mov>
    1fb2:	8f ef       	ldi	r24, 0xFF	; 255
    1fb4:	9f ef       	ldi	r25, 0xFF	; 255
    1fb6:	ac e2       	ldi	r26, 0x2C	; 44
    1fb8:	81 50       	subi	r24, 0x01	; 1
    1fba:	90 40       	sbci	r25, 0x00	; 0
    1fbc:	a0 40       	sbci	r26, 0x00	; 0
    1fbe:	e1 f7       	brne	.-8      	; 0x1fb8 <node_behave+0x878>
    1fc0:	00 c0       	rjmp	.+0      	; 0x1fc2 <node_behave+0x882>
    1fc2:	00 00       	nop
				_delay_ms(1000);
				servo2_mov(1);
    1fc4:	81 e0       	ldi	r24, 0x01	; 1
    1fc6:	90 e0       	ldi	r25, 0x00	; 0
    1fc8:	0e 94 13 0a 	call	0x1426	; 0x1426 <servo2_mov>
    1fcc:	8f ef       	ldi	r24, 0xFF	; 255
    1fce:	9f ef       	ldi	r25, 0xFF	; 255
    1fd0:	ac e2       	ldi	r26, 0x2C	; 44
    1fd2:	81 50       	subi	r24, 0x01	; 1
    1fd4:	90 40       	sbci	r25, 0x00	; 0
    1fd6:	a0 40       	sbci	r26, 0x00	; 0
    1fd8:	e1 f7       	brne	.-8      	; 0x1fd2 <node_behave+0x892>
    1fda:	00 c0       	rjmp	.+0      	; 0x1fdc <node_behave+0x89c>
    1fdc:	00 00       	nop
				_delay_ms(1000);
				servo1_mov(130);
    1fde:	82 e8       	ldi	r24, 0x82	; 130
    1fe0:	90 e0       	ldi	r25, 0x00	; 0
    1fe2:	0e 94 c9 09 	call	0x1392	; 0x1392 <servo1_mov>
    1fe6:	8f ef       	ldi	r24, 0xFF	; 255
    1fe8:	9f e7       	ldi	r25, 0x7F	; 127
    1fea:	a1 e3       	ldi	r26, 0x31	; 49
    1fec:	81 50       	subi	r24, 0x01	; 1
    1fee:	90 40       	sbci	r25, 0x00	; 0
    1ff0:	a0 40       	sbci	r26, 0x00	; 0
    1ff2:	e1 f7       	brne	.-8      	; 0x1fec <node_behave+0x8ac>
    1ff4:	00 c0       	rjmp	.+0      	; 0x1ff6 <node_behave+0x8b6>
    1ff6:	00 00       	nop
				_delay_ms(1100);
				servo1_free();
    1ff8:	0e 94 3a 0a 	call	0x1474	; 0x1474 <servo1_free>
    1ffc:	34 c0       	rjmp	.+104    	; 0x2066 <node_behave+0x926>
			}
			else if(weight_block_position_2==1)
    1ffe:	81 30       	cpi	r24, 0x01	; 1
    2000:	91 05       	cpc	r25, r1
    2002:	89 f5       	brne	.+98     	; 0x2066 <node_behave+0x926>
			{
				distance('f',1,'o');
    2004:	86 e6       	ldi	r24, 0x66	; 102
    2006:	40 e0       	ldi	r20, 0x00	; 0
    2008:	50 e0       	ldi	r21, 0x00	; 0
    200a:	60 e8       	ldi	r22, 0x80	; 128
    200c:	7f e3       	ldi	r23, 0x3F	; 63
    200e:	2f e6       	ldi	r18, 0x6F	; 111
    2010:	0e 94 8a 07 	call	0xf14	; 0xf14 <distance>
				servo1_mov(10);
    2014:	8a e0       	ldi	r24, 0x0A	; 10
    2016:	90 e0       	ldi	r25, 0x00	; 0
    2018:	0e 94 c9 09 	call	0x1392	; 0x1392 <servo1_mov>
    201c:	8f ef       	ldi	r24, 0xFF	; 255
    201e:	9f ef       	ldi	r25, 0xFF	; 255
    2020:	ac e2       	ldi	r26, 0x2C	; 44
    2022:	81 50       	subi	r24, 0x01	; 1
    2024:	90 40       	sbci	r25, 0x00	; 0
    2026:	a0 40       	sbci	r26, 0x00	; 0
    2028:	e1 f7       	brne	.-8      	; 0x2022 <node_behave+0x8e2>
    202a:	00 c0       	rjmp	.+0      	; 0x202c <node_behave+0x8ec>
    202c:	00 00       	nop
				_delay_ms(1000);
				servo2_mov(1);
    202e:	81 e0       	ldi	r24, 0x01	; 1
    2030:	90 e0       	ldi	r25, 0x00	; 0
    2032:	0e 94 13 0a 	call	0x1426	; 0x1426 <servo2_mov>
    2036:	8f ef       	ldi	r24, 0xFF	; 255
    2038:	9f ef       	ldi	r25, 0xFF	; 255
    203a:	ac e2       	ldi	r26, 0x2C	; 44
    203c:	81 50       	subi	r24, 0x01	; 1
    203e:	90 40       	sbci	r25, 0x00	; 0
    2040:	a0 40       	sbci	r26, 0x00	; 0
    2042:	e1 f7       	brne	.-8      	; 0x203c <node_behave+0x8fc>
    2044:	00 c0       	rjmp	.+0      	; 0x2046 <node_behave+0x906>
    2046:	00 00       	nop
				_delay_ms(1000);
				servo1_mov(130);
    2048:	82 e8       	ldi	r24, 0x82	; 130
    204a:	90 e0       	ldi	r25, 0x00	; 0
    204c:	0e 94 c9 09 	call	0x1392	; 0x1392 <servo1_mov>
    2050:	8f ef       	ldi	r24, 0xFF	; 255
    2052:	9f e7       	ldi	r25, 0x7F	; 127
    2054:	a1 e3       	ldi	r26, 0x31	; 49
    2056:	81 50       	subi	r24, 0x01	; 1
    2058:	90 40       	sbci	r25, 0x00	; 0
    205a:	a0 40       	sbci	r26, 0x00	; 0
    205c:	e1 f7       	brne	.-8      	; 0x2056 <node_behave+0x916>
    205e:	00 c0       	rjmp	.+0      	; 0x2060 <node_behave+0x920>
    2060:	00 00       	nop
				_delay_ms(1100);
				servo1_free();
    2062:	0e 94 3a 0a 	call	0x1474	; 0x1474 <servo1_free>
			}
			weight_block_position_2--;
    2066:	80 91 31 02 	lds	r24, 0x0231
    206a:	90 91 32 02 	lds	r25, 0x0232
    206e:	01 97       	sbiw	r24, 0x01	; 1
    2070:	90 93 32 02 	sts	0x0232, r25
    2074:	80 93 31 02 	sts	0x0231, r24
			distance('b',14.5,'o');
    2078:	82 e6       	ldi	r24, 0x62	; 98
    207a:	40 e0       	ldi	r20, 0x00	; 0
    207c:	50 e0       	ldi	r21, 0x00	; 0
    207e:	68 e6       	ldi	r22, 0x68	; 104
    2080:	71 e4       	ldi	r23, 0x41	; 65
    2082:	2f e6       	ldi	r18, 0x6F	; 111
    2084:	0e 94 8a 07 	call	0xf14	; 0xf14 <distance>
			enq_end(4);              //adding node 4 in priority queue
    2088:	84 e0       	ldi	r24, 0x04	; 4
    208a:	90 e0       	ldi	r25, 0x00	; 0
    208c:	0e 94 d8 06 	call	0xdb0	; 0xdb0 <enq_end>
		}
		if(node_number==12)
    2090:	80 91 5f 02 	lds	r24, 0x025F
    2094:	90 91 60 02 	lds	r25, 0x0260
    2098:	8c 30       	cpi	r24, 0x0C	; 12
    209a:	91 05       	cpc	r25, r1
    209c:	09 f0       	breq	.+2      	; 0x20a0 <node_behave+0x960>
    209e:	82 c0       	rjmp	.+260    	; 0x21a4 <node_behave+0xa64>
		{
			distance('f',12,'o');
    20a0:	86 e6       	ldi	r24, 0x66	; 102
    20a2:	40 e0       	ldi	r20, 0x00	; 0
    20a4:	50 e0       	ldi	r21, 0x00	; 0
    20a6:	60 e4       	ldi	r22, 0x40	; 64
    20a8:	71 e4       	ldi	r23, 0x41	; 65
    20aa:	2f e6       	ldi	r18, 0x6F	; 111
    20ac:	0e 94 8a 07 	call	0xf14	; 0xf14 <distance>
			if(weight_block_position_3==2)
    20b0:	80 91 2f 02 	lds	r24, 0x022F
    20b4:	90 91 30 02 	lds	r25, 0x0230
    20b8:	82 30       	cpi	r24, 0x02	; 2
    20ba:	91 05       	cpc	r25, r1
    20bc:	51 f5       	brne	.+84     	; 0x2112 <node_behave+0x9d2>
			{
				servo1_mov(16);
    20be:	80 e1       	ldi	r24, 0x10	; 16
    20c0:	90 e0       	ldi	r25, 0x00	; 0
    20c2:	0e 94 c9 09 	call	0x1392	; 0x1392 <servo1_mov>
    20c6:	8f ef       	ldi	r24, 0xFF	; 255
    20c8:	9f ef       	ldi	r25, 0xFF	; 255
    20ca:	ac e2       	ldi	r26, 0x2C	; 44
    20cc:	81 50       	subi	r24, 0x01	; 1
    20ce:	90 40       	sbci	r25, 0x00	; 0
    20d0:	a0 40       	sbci	r26, 0x00	; 0
    20d2:	e1 f7       	brne	.-8      	; 0x20cc <node_behave+0x98c>
    20d4:	00 c0       	rjmp	.+0      	; 0x20d6 <node_behave+0x996>
    20d6:	00 00       	nop
				_delay_ms(1000);
				servo2_mov(1);
    20d8:	81 e0       	ldi	r24, 0x01	; 1
    20da:	90 e0       	ldi	r25, 0x00	; 0
    20dc:	0e 94 13 0a 	call	0x1426	; 0x1426 <servo2_mov>
    20e0:	8f ef       	ldi	r24, 0xFF	; 255
    20e2:	9f ef       	ldi	r25, 0xFF	; 255
    20e4:	ac e2       	ldi	r26, 0x2C	; 44
    20e6:	81 50       	subi	r24, 0x01	; 1
    20e8:	90 40       	sbci	r25, 0x00	; 0
    20ea:	a0 40       	sbci	r26, 0x00	; 0
    20ec:	e1 f7       	brne	.-8      	; 0x20e6 <node_behave+0x9a6>
    20ee:	00 c0       	rjmp	.+0      	; 0x20f0 <node_behave+0x9b0>
    20f0:	00 00       	nop
				_delay_ms(1000);
				servo1_mov(130);
    20f2:	82 e8       	ldi	r24, 0x82	; 130
    20f4:	90 e0       	ldi	r25, 0x00	; 0
    20f6:	0e 94 c9 09 	call	0x1392	; 0x1392 <servo1_mov>
    20fa:	8f ef       	ldi	r24, 0xFF	; 255
    20fc:	9f e7       	ldi	r25, 0x7F	; 127
    20fe:	a1 e3       	ldi	r26, 0x31	; 49
    2100:	81 50       	subi	r24, 0x01	; 1
    2102:	90 40       	sbci	r25, 0x00	; 0
    2104:	a0 40       	sbci	r26, 0x00	; 0
    2106:	e1 f7       	brne	.-8      	; 0x2100 <node_behave+0x9c0>
    2108:	00 c0       	rjmp	.+0      	; 0x210a <node_behave+0x9ca>
    210a:	00 00       	nop
				_delay_ms(1100);
				servo1_free();
    210c:	0e 94 3a 0a 	call	0x1474	; 0x1474 <servo1_free>
    2110:	34 c0       	rjmp	.+104    	; 0x217a <node_behave+0xa3a>
			}
			else if(weight_block_position_3==1)
    2112:	81 30       	cpi	r24, 0x01	; 1
    2114:	91 05       	cpc	r25, r1
    2116:	89 f5       	brne	.+98     	; 0x217a <node_behave+0xa3a>
			{
				distance('f',1,'o');
    2118:	86 e6       	ldi	r24, 0x66	; 102
    211a:	40 e0       	ldi	r20, 0x00	; 0
    211c:	50 e0       	ldi	r21, 0x00	; 0
    211e:	60 e8       	ldi	r22, 0x80	; 128
    2120:	7f e3       	ldi	r23, 0x3F	; 63
    2122:	2f e6       	ldi	r18, 0x6F	; 111
    2124:	0e 94 8a 07 	call	0xf14	; 0xf14 <distance>
				servo1_mov(11);
    2128:	8b e0       	ldi	r24, 0x0B	; 11
    212a:	90 e0       	ldi	r25, 0x00	; 0
    212c:	0e 94 c9 09 	call	0x1392	; 0x1392 <servo1_mov>
    2130:	8f ef       	ldi	r24, 0xFF	; 255
    2132:	9f ef       	ldi	r25, 0xFF	; 255
    2134:	ac e2       	ldi	r26, 0x2C	; 44
    2136:	81 50       	subi	r24, 0x01	; 1
    2138:	90 40       	sbci	r25, 0x00	; 0
    213a:	a0 40       	sbci	r26, 0x00	; 0
    213c:	e1 f7       	brne	.-8      	; 0x2136 <node_behave+0x9f6>
    213e:	00 c0       	rjmp	.+0      	; 0x2140 <node_behave+0xa00>
    2140:	00 00       	nop
				_delay_ms(1000);
				servo2_mov(1);
    2142:	81 e0       	ldi	r24, 0x01	; 1
    2144:	90 e0       	ldi	r25, 0x00	; 0
    2146:	0e 94 13 0a 	call	0x1426	; 0x1426 <servo2_mov>
    214a:	8f ef       	ldi	r24, 0xFF	; 255
    214c:	9f ef       	ldi	r25, 0xFF	; 255
    214e:	ac e2       	ldi	r26, 0x2C	; 44
    2150:	81 50       	subi	r24, 0x01	; 1
    2152:	90 40       	sbci	r25, 0x00	; 0
    2154:	a0 40       	sbci	r26, 0x00	; 0
    2156:	e1 f7       	brne	.-8      	; 0x2150 <node_behave+0xa10>
    2158:	00 c0       	rjmp	.+0      	; 0x215a <node_behave+0xa1a>
    215a:	00 00       	nop
				_delay_ms(1000);
				servo1_mov(130);
    215c:	82 e8       	ldi	r24, 0x82	; 130
    215e:	90 e0       	ldi	r25, 0x00	; 0
    2160:	0e 94 c9 09 	call	0x1392	; 0x1392 <servo1_mov>
    2164:	8f ef       	ldi	r24, 0xFF	; 255
    2166:	9f e7       	ldi	r25, 0x7F	; 127
    2168:	a1 e3       	ldi	r26, 0x31	; 49
    216a:	81 50       	subi	r24, 0x01	; 1
    216c:	90 40       	sbci	r25, 0x00	; 0
    216e:	a0 40       	sbci	r26, 0x00	; 0
    2170:	e1 f7       	brne	.-8      	; 0x216a <node_behave+0xa2a>
    2172:	00 c0       	rjmp	.+0      	; 0x2174 <node_behave+0xa34>
    2174:	00 00       	nop
				_delay_ms(1100);
				servo1_free();
    2176:	0e 94 3a 0a 	call	0x1474	; 0x1474 <servo1_free>
			}
			weight_block_position_3--;
    217a:	80 91 2f 02 	lds	r24, 0x022F
    217e:	90 91 30 02 	lds	r25, 0x0230
    2182:	01 97       	sbiw	r24, 0x01	; 1
    2184:	90 93 30 02 	sts	0x0230, r25
    2188:	80 93 2f 02 	sts	0x022F, r24
			distance('b',14,'o');
    218c:	82 e6       	ldi	r24, 0x62	; 98
    218e:	40 e0       	ldi	r20, 0x00	; 0
    2190:	50 e0       	ldi	r21, 0x00	; 0
    2192:	60 e6       	ldi	r22, 0x60	; 96
    2194:	71 e4       	ldi	r23, 0x41	; 65
    2196:	2f e6       	ldi	r18, 0x6F	; 111
    2198:	0e 94 8a 07 	call	0xf14	; 0xf14 <distance>
			enq_end(14);
    219c:	8e e0       	ldi	r24, 0x0E	; 14
    219e:	90 e0       	ldi	r25, 0x00	; 0
    21a0:	0e 94 d8 06 	call	0xdb0	; 0xdb0 <enq_end>
		}
		if(node_number==6)
    21a4:	80 91 5f 02 	lds	r24, 0x025F
    21a8:	90 91 60 02 	lds	r25, 0x0260
    21ac:	86 30       	cpi	r24, 0x06	; 6
    21ae:	91 05       	cpc	r25, r1
    21b0:	09 f0       	breq	.+2      	; 0x21b4 <node_behave+0xa74>
    21b2:	d2 c1       	rjmp	.+932    	; 0x2558 <__stack+0x359>
		{
			if(IP!=1)
    21b4:	80 91 35 02 	lds	r24, 0x0235
    21b8:	90 91 36 02 	lds	r25, 0x0236
    21bc:	81 30       	cpi	r24, 0x01	; 1
    21be:	91 05       	cpc	r25, r1
    21c0:	09 f4       	brne	.+2      	; 0x21c4 <node_behave+0xa84>
    21c2:	79 c1       	rjmp	.+754    	; 0x24b6 <__stack+0x2b7>
			{
				distance('b',3,'0');
    21c4:	82 e6       	ldi	r24, 0x62	; 98
    21c6:	40 e0       	ldi	r20, 0x00	; 0
    21c8:	50 e0       	ldi	r21, 0x00	; 0
    21ca:	60 e4       	ldi	r22, 0x40	; 64
    21cc:	70 e4       	ldi	r23, 0x40	; 64
    21ce:	20 e3       	ldi	r18, 0x30	; 48
    21d0:	0e 94 8a 07 	call	0xf14	; 0xf14 <distance>
				if(IP==3)
    21d4:	80 91 35 02 	lds	r24, 0x0235
    21d8:	90 91 36 02 	lds	r25, 0x0236
    21dc:	83 30       	cpi	r24, 0x03	; 3
    21de:	91 05       	cpc	r25, r1
    21e0:	09 f0       	breq	.+2      	; 0x21e4 <node_behave+0xaa4>
    21e2:	82 c0       	rjmp	.+260    	; 0x22e8 <__stack+0xe9>
				{
					distance('f',2,'0');
    21e4:	86 e6       	ldi	r24, 0x66	; 102
    21e6:	40 e0       	ldi	r20, 0x00	; 0
    21e8:	50 e0       	ldi	r21, 0x00	; 0
    21ea:	60 e0       	ldi	r22, 0x00	; 0
    21ec:	70 e4       	ldi	r23, 0x40	; 64
    21ee:	20 e3       	ldi	r18, 0x30	; 48
    21f0:	0e 94 8a 07 	call	0xf14	; 0xf14 <distance>
					servo1_mov(37);
    21f4:	85 e2       	ldi	r24, 0x25	; 37
    21f6:	90 e0       	ldi	r25, 0x00	; 0
    21f8:	0e 94 c9 09 	call	0x1392	; 0x1392 <servo1_mov>
    21fc:	8f ef       	ldi	r24, 0xFF	; 255
    21fe:	9f ef       	ldi	r25, 0xFF	; 255
    2200:	ac e2       	ldi	r26, 0x2C	; 44
    2202:	81 50       	subi	r24, 0x01	; 1
    2204:	90 40       	sbci	r25, 0x00	; 0
    2206:	a0 40       	sbci	r26, 0x00	; 0
    2208:	e1 f7       	brne	.-8      	; 0x2202 <__stack+0x3>
    220a:	00 c0       	rjmp	.+0      	; 0x220c <__stack+0xd>
    220c:	00 00       	nop
					_delay_ms(1000);
					pick_waste();
    220e:	0e 94 48 0a 	call	0x1490	; 0x1490 <pick_waste>
					servo1_mov(80);
    2212:	80 e5       	ldi	r24, 0x50	; 80
    2214:	90 e0       	ldi	r25, 0x00	; 0
    2216:	0e 94 c9 09 	call	0x1392	; 0x1392 <servo1_mov>
    221a:	8f ef       	ldi	r24, 0xFF	; 255
    221c:	9f ef       	ldi	r25, 0xFF	; 255
    221e:	ac e2       	ldi	r26, 0x2C	; 44
    2220:	81 50       	subi	r24, 0x01	; 1
    2222:	90 40       	sbci	r25, 0x00	; 0
    2224:	a0 40       	sbci	r26, 0x00	; 0
    2226:	e1 f7       	brne	.-8      	; 0x2220 <__stack+0x21>
    2228:	00 c0       	rjmp	.+0      	; 0x222a <__stack+0x2b>
    222a:	00 00       	nop
					_delay_ms(1000);
					left_degrees(180);
    222c:	84 eb       	ldi	r24, 0xB4	; 180
    222e:	90 e0       	ldi	r25, 0x00	; 0
    2230:	0e 94 99 08 	call	0x1132	; 0x1132 <left_degrees>
					servo1_mov(0);
    2234:	80 e0       	ldi	r24, 0x00	; 0
    2236:	90 e0       	ldi	r25, 0x00	; 0
    2238:	0e 94 c9 09 	call	0x1392	; 0x1392 <servo1_mov>
    223c:	8f ef       	ldi	r24, 0xFF	; 255
    223e:	9f ef       	ldi	r25, 0xFF	; 255
    2240:	ac e2       	ldi	r26, 0x2C	; 44
    2242:	81 50       	subi	r24, 0x01	; 1
    2244:	90 40       	sbci	r25, 0x00	; 0
    2246:	a0 40       	sbci	r26, 0x00	; 0
    2248:	e1 f7       	brne	.-8      	; 0x2242 <__stack+0x43>
    224a:	00 c0       	rjmp	.+0      	; 0x224c <__stack+0x4d>
    224c:	00 00       	nop
					_delay_ms(1000);
					color_sensor();
    224e:	0e 94 43 16 	call	0x2c86	; 0x2c86 <color_sensor>
					color[color_index]=color_identified;
    2252:	e0 91 52 02 	lds	r30, 0x0252
    2256:	f0 91 53 02 	lds	r31, 0x0253
    225a:	ed 5c       	subi	r30, 0xCD	; 205
    225c:	fa 4f       	sbci	r31, 0xFA	; 250
    225e:	80 91 54 02 	lds	r24, 0x0254
    2262:	80 83       	st	Z, r24
					servo1_mov(80);
    2264:	80 e5       	ldi	r24, 0x50	; 80
    2266:	90 e0       	ldi	r25, 0x00	; 0
    2268:	0e 94 c9 09 	call	0x1392	; 0x1392 <servo1_mov>
    226c:	8f ef       	ldi	r24, 0xFF	; 255
    226e:	9f e7       	ldi	r25, 0x7F	; 127
    2270:	a4 e0       	ldi	r26, 0x04	; 4
    2272:	81 50       	subi	r24, 0x01	; 1
    2274:	90 40       	sbci	r25, 0x00	; 0
    2276:	a0 40       	sbci	r26, 0x00	; 0
    2278:	e1 f7       	brne	.-8      	; 0x2272 <__stack+0x73>
    227a:	00 c0       	rjmp	.+0      	; 0x227c <__stack+0x7d>
    227c:	00 00       	nop
					_delay_ms(100);
					if(deposition_zone_B==1)
    227e:	80 91 39 02 	lds	r24, 0x0239
    2282:	90 91 3a 02 	lds	r25, 0x023A
    2286:	81 30       	cpi	r24, 0x01	; 1
    2288:	91 05       	cpc	r25, r1
    228a:	29 f4       	brne	.+10     	; 0x2296 <__stack+0x97>
					path_find(16);
    228c:	80 e1       	ldi	r24, 0x10	; 16
    228e:	90 e0       	ldi	r25, 0x00	; 0
    2290:	0e 94 e3 05 	call	0xbc6	; 0xbc6 <path_find>
    2294:	17 c0       	rjmp	.+46     	; 0x22c4 <__stack+0xc5>
					else if(deposition_zone_A==1)
    2296:	80 91 3b 02 	lds	r24, 0x023B
    229a:	90 91 3c 02 	lds	r25, 0x023C
    229e:	81 30       	cpi	r24, 0x01	; 1
    22a0:	91 05       	cpc	r25, r1
    22a2:	29 f4       	brne	.+10     	; 0x22ae <__stack+0xaf>
					path_find(15);
    22a4:	8f e0       	ldi	r24, 0x0F	; 15
    22a6:	90 e0       	ldi	r25, 0x00	; 0
    22a8:	0e 94 e3 05 	call	0xbc6	; 0xbc6 <path_find>
    22ac:	0b c0       	rjmp	.+22     	; 0x22c4 <__stack+0xc5>
					else if(deposition_zone_C==1)
    22ae:	80 91 37 02 	lds	r24, 0x0237
    22b2:	90 91 38 02 	lds	r25, 0x0238
    22b6:	81 30       	cpi	r24, 0x01	; 1
    22b8:	91 05       	cpc	r25, r1
    22ba:	21 f4       	brne	.+8      	; 0x22c4 <__stack+0xc5>
					path_find(17);
    22bc:	81 e1       	ldi	r24, 0x11	; 17
    22be:	90 e0       	ldi	r25, 0x00	; 0
    22c0:	0e 94 e3 05 	call	0xbc6	; 0xbc6 <path_find>
					path_index++;
    22c4:	80 91 59 02 	lds	r24, 0x0259
    22c8:	90 91 5a 02 	lds	r25, 0x025A
    22cc:	01 96       	adiw	r24, 0x01	; 1
    22ce:	90 93 5a 02 	sts	0x025A, r25
    22d2:	80 93 59 02 	sts	0x0259, r24
					color_index++;
    22d6:	80 91 52 02 	lds	r24, 0x0252
    22da:	90 91 53 02 	lds	r25, 0x0253
    22de:	01 96       	adiw	r24, 0x01	; 1
    22e0:	90 93 53 02 	sts	0x0253, r25
    22e4:	80 93 52 02 	sts	0x0252, r24
				}
			if(IP==2)
    22e8:	80 91 35 02 	lds	r24, 0x0235
    22ec:	90 91 36 02 	lds	r25, 0x0236
    22f0:	82 30       	cpi	r24, 0x02	; 2
    22f2:	91 05       	cpc	r25, r1
    22f4:	09 f0       	breq	.+2      	; 0x22f8 <__stack+0xf9>
    22f6:	d5 c0       	rjmp	.+426    	; 0x24a2 <__stack+0x2a3>
				{
					distance('f',2,'o');
    22f8:	86 e6       	ldi	r24, 0x66	; 102
    22fa:	40 e0       	ldi	r20, 0x00	; 0
    22fc:	50 e0       	ldi	r21, 0x00	; 0
    22fe:	60 e0       	ldi	r22, 0x00	; 0
    2300:	70 e4       	ldi	r23, 0x40	; 64
    2302:	2f e6       	ldi	r18, 0x6F	; 111
    2304:	0e 94 8a 07 	call	0xf14	; 0xf14 <distance>
					servo1_mov(25);
    2308:	89 e1       	ldi	r24, 0x19	; 25
    230a:	90 e0       	ldi	r25, 0x00	; 0
    230c:	0e 94 c9 09 	call	0x1392	; 0x1392 <servo1_mov>
    2310:	8f ef       	ldi	r24, 0xFF	; 255
    2312:	9f ef       	ldi	r25, 0xFF	; 255
    2314:	ac e2       	ldi	r26, 0x2C	; 44
    2316:	81 50       	subi	r24, 0x01	; 1
    2318:	90 40       	sbci	r25, 0x00	; 0
    231a:	a0 40       	sbci	r26, 0x00	; 0
    231c:	e1 f7       	brne	.-8      	; 0x2316 <__stack+0x117>
    231e:	00 c0       	rjmp	.+0      	; 0x2320 <__stack+0x121>
    2320:	00 00       	nop
					_delay_ms(1000);
					pick_waste();
    2322:	0e 94 48 0a 	call	0x1490	; 0x1490 <pick_waste>
					servo1_mov(80);
    2326:	80 e5       	ldi	r24, 0x50	; 80
    2328:	90 e0       	ldi	r25, 0x00	; 0
    232a:	0e 94 c9 09 	call	0x1392	; 0x1392 <servo1_mov>
    232e:	8f ef       	ldi	r24, 0xFF	; 255
    2330:	9f ef       	ldi	r25, 0xFF	; 255
    2332:	ac e2       	ldi	r26, 0x2C	; 44
    2334:	81 50       	subi	r24, 0x01	; 1
    2336:	90 40       	sbci	r25, 0x00	; 0
    2338:	a0 40       	sbci	r26, 0x00	; 0
    233a:	e1 f7       	brne	.-8      	; 0x2334 <__stack+0x135>
    233c:	00 c0       	rjmp	.+0      	; 0x233e <__stack+0x13f>
    233e:	00 00       	nop
					_delay_ms(1000);
					left_degrees(180);
    2340:	84 eb       	ldi	r24, 0xB4	; 180
    2342:	90 e0       	ldi	r25, 0x00	; 0
    2344:	0e 94 99 08 	call	0x1132	; 0x1132 <left_degrees>
					servo1_mov(0);
    2348:	80 e0       	ldi	r24, 0x00	; 0
    234a:	90 e0       	ldi	r25, 0x00	; 0
    234c:	0e 94 c9 09 	call	0x1392	; 0x1392 <servo1_mov>
    2350:	8f ef       	ldi	r24, 0xFF	; 255
    2352:	9f ef       	ldi	r25, 0xFF	; 255
    2354:	ac e2       	ldi	r26, 0x2C	; 44
    2356:	81 50       	subi	r24, 0x01	; 1
    2358:	90 40       	sbci	r25, 0x00	; 0
    235a:	a0 40       	sbci	r26, 0x00	; 0
    235c:	e1 f7       	brne	.-8      	; 0x2356 <__stack+0x157>
    235e:	00 c0       	rjmp	.+0      	; 0x2360 <__stack+0x161>
    2360:	00 00       	nop
					_delay_ms(1000);
					color_sensor();
    2362:	0e 94 43 16 	call	0x2c86	; 0x2c86 <color_sensor>
					color[color_index]=color_identified;
    2366:	e0 91 52 02 	lds	r30, 0x0252
    236a:	f0 91 53 02 	lds	r31, 0x0253
    236e:	ed 5c       	subi	r30, 0xCD	; 205
    2370:	fa 4f       	sbci	r31, 0xFA	; 250
    2372:	80 91 54 02 	lds	r24, 0x0254
    2376:	80 83       	st	Z, r24
					servo1_mov(80);
    2378:	80 e5       	ldi	r24, 0x50	; 80
    237a:	90 e0       	ldi	r25, 0x00	; 0
    237c:	0e 94 c9 09 	call	0x1392	; 0x1392 <servo1_mov>
    2380:	8f ef       	ldi	r24, 0xFF	; 255
    2382:	9f e7       	ldi	r25, 0x7F	; 127
    2384:	a4 e0       	ldi	r26, 0x04	; 4
    2386:	81 50       	subi	r24, 0x01	; 1
    2388:	90 40       	sbci	r25, 0x00	; 0
    238a:	a0 40       	sbci	r26, 0x00	; 0
    238c:	e1 f7       	brne	.-8      	; 0x2386 <__stack+0x187>
    238e:	00 c0       	rjmp	.+0      	; 0x2390 <__stack+0x191>
    2390:	00 00       	nop
    2392:	c3 ea       	ldi	r28, 0xA3	; 163
    2394:	d2 e0       	ldi	r29, 0x02	; 2
    2396:	0f e0       	ldi	r16, 0x0F	; 15
    2398:	10 e0       	ldi	r17, 0x00	; 0
					_delay_ms(100);
					int a=0;             //summing variable
    239a:	cc 24       	eor	r12, r12
    239c:	dd 24       	eor	r13, r13
					for(i=0;i<4;i++)
					{
						if(color[color_index]==color_deposited[i])
    239e:	0f 2e       	mov	r0, r31
    23a0:	f3 e3       	ldi	r31, 0x33	; 51
    23a2:	af 2e       	mov	r10, r31
    23a4:	f5 e0       	ldi	r31, 0x05	; 5
    23a6:	bf 2e       	mov	r11, r31
    23a8:	f0 2d       	mov	r31, r0
							             
* Example Call:				node_behave(); 
*
*/

void node_behave(void) 
    23aa:	7e 01       	movw	r14, r28
					servo1_mov(80);
					_delay_ms(100);
					int a=0;             //summing variable
					for(i=0;i<4;i++)
					{
						if(color[color_index]==color_deposited[i])
    23ac:	80 91 52 02 	lds	r24, 0x0252
    23b0:	90 91 53 02 	lds	r25, 0x0253
    23b4:	8a 0d       	add	r24, r10
    23b6:	9b 1d       	adc	r25, r11
    23b8:	dc 01       	movw	r26, r24
    23ba:	9c 91       	ld	r25, X
    23bc:	88 81       	ld	r24, Y
    23be:	98 17       	cp	r25, r24
    23c0:	61 f4       	brne	.+24     	; 0x23da <__stack+0x1db>
						{
							color_found++;
    23c2:	80 91 5b 02 	lds	r24, 0x025B
    23c6:	90 91 5c 02 	lds	r25, 0x025C
    23ca:	01 96       	adiw	r24, 0x01	; 1
    23cc:	90 93 5c 02 	sts	0x025C, r25
    23d0:	80 93 5b 02 	sts	0x025B, r24
							path_find(15+i);
    23d4:	c8 01       	movw	r24, r16
    23d6:	0e 94 e3 05 	call	0xbc6	; 0xbc6 <path_find>
    23da:	21 96       	adiw	r28, 0x01	; 1
						}
						if(color_deposited[i]!='\0')
    23dc:	f7 01       	movw	r30, r14
    23de:	80 81       	ld	r24, Z
    23e0:	88 23       	and	r24, r24
    23e2:	19 f0       	breq	.+6      	; 0x23ea <__stack+0x1eb>
						a++;
    23e4:	08 94       	sec
    23e6:	c1 1c       	adc	r12, r1
    23e8:	d1 1c       	adc	r13, r1
    23ea:	0f 5f       	subi	r16, 0xFF	; 255
    23ec:	1f 4f       	sbci	r17, 0xFF	; 255
					color_sensor();
					color[color_index]=color_identified;
					servo1_mov(80);
					_delay_ms(100);
					int a=0;             //summing variable
					for(i=0;i<4;i++)
    23ee:	03 31       	cpi	r16, 0x13	; 19
    23f0:	11 05       	cpc	r17, r1
    23f2:	d9 f6       	brne	.-74     	; 0x23aa <__stack+0x1ab>
							path_find(15+i);
						}
						if(color_deposited[i]!='\0')
						a++;
					}
					if(a>2)
    23f4:	f3 e0       	ldi	r31, 0x03	; 3
    23f6:	cf 16       	cp	r12, r31
    23f8:	d1 04       	cpc	r13, r1
    23fa:	4c f0       	brlt	.+18     	; 0x240e <__stack+0x20f>
					color_found++;
    23fc:	80 91 5b 02 	lds	r24, 0x025B
    2400:	90 91 5c 02 	lds	r25, 0x025C
    2404:	01 96       	adiw	r24, 0x01	; 1
    2406:	90 93 5c 02 	sts	0x025C, r25
    240a:	80 93 5b 02 	sts	0x025B, r24
					if(path[path_index]=='\0')
    240e:	e0 91 59 02 	lds	r30, 0x0259
    2412:	f0 91 5a 02 	lds	r31, 0x025A
    2416:	e1 59       	subi	r30, 0x91	; 145
    2418:	fd 4f       	sbci	r31, 0xFD	; 253
    241a:	80 81       	ld	r24, Z
    241c:	88 23       	and	r24, r24
    241e:	79 f5       	brne	.+94     	; 0x247e <__stack+0x27f>
					{
						if(deposition_zone_B==1 && color_deposited[1]=='\0')
    2420:	80 91 39 02 	lds	r24, 0x0239
    2424:	90 91 3a 02 	lds	r25, 0x023A
    2428:	81 30       	cpi	r24, 0x01	; 1
    242a:	91 05       	cpc	r25, r1
    242c:	49 f4       	brne	.+18     	; 0x2440 <__stack+0x241>
    242e:	80 91 a4 02 	lds	r24, 0x02A4
    2432:	88 23       	and	r24, r24
    2434:	29 f4       	brne	.+10     	; 0x2440 <__stack+0x241>
						path_find(16);
    2436:	80 e1       	ldi	r24, 0x10	; 16
    2438:	90 e0       	ldi	r25, 0x00	; 0
    243a:	0e 94 e3 05 	call	0xbc6	; 0xbc6 <path_find>
    243e:	1f c0       	rjmp	.+62     	; 0x247e <__stack+0x27f>
						else if(deposition_zone_A==1 && color_deposited[0]=='\0')
    2440:	80 91 3b 02 	lds	r24, 0x023B
    2444:	90 91 3c 02 	lds	r25, 0x023C
    2448:	81 30       	cpi	r24, 0x01	; 1
    244a:	91 05       	cpc	r25, r1
    244c:	49 f4       	brne	.+18     	; 0x2460 <__stack+0x261>
    244e:	80 91 a3 02 	lds	r24, 0x02A3
    2452:	88 23       	and	r24, r24
    2454:	29 f4       	brne	.+10     	; 0x2460 <__stack+0x261>
						path_find(15);
    2456:	8f e0       	ldi	r24, 0x0F	; 15
    2458:	90 e0       	ldi	r25, 0x00	; 0
    245a:	0e 94 e3 05 	call	0xbc6	; 0xbc6 <path_find>
    245e:	0f c0       	rjmp	.+30     	; 0x247e <__stack+0x27f>
						else if(deposition_zone_C==1 && color_deposited[2]=='\0')
    2460:	80 91 37 02 	lds	r24, 0x0237
    2464:	90 91 38 02 	lds	r25, 0x0238
    2468:	81 30       	cpi	r24, 0x01	; 1
    246a:	91 05       	cpc	r25, r1
    246c:	41 f4       	brne	.+16     	; 0x247e <__stack+0x27f>
    246e:	80 91 a5 02 	lds	r24, 0x02A5
    2472:	88 23       	and	r24, r24
    2474:	21 f4       	brne	.+8      	; 0x247e <__stack+0x27f>
						path_find(17);
    2476:	81 e1       	ldi	r24, 0x11	; 17
    2478:	90 e0       	ldi	r25, 0x00	; 0
    247a:	0e 94 e3 05 	call	0xbc6	; 0xbc6 <path_find>
					}
					path_index++;
    247e:	80 91 59 02 	lds	r24, 0x0259
    2482:	90 91 5a 02 	lds	r25, 0x025A
    2486:	01 96       	adiw	r24, 0x01	; 1
    2488:	90 93 5a 02 	sts	0x025A, r25
    248c:	80 93 59 02 	sts	0x0259, r24
					color_index++;
    2490:	80 91 52 02 	lds	r24, 0x0252
    2494:	90 91 53 02 	lds	r25, 0x0253
    2498:	01 96       	adiw	r24, 0x01	; 1
    249a:	90 93 53 02 	sts	0x0253, r25
    249e:	80 93 52 02 	sts	0x0252, r24
				}
					IP--;
    24a2:	80 91 35 02 	lds	r24, 0x0235
    24a6:	90 91 36 02 	lds	r25, 0x0236
    24aa:	01 97       	sbiw	r24, 0x01	; 1
    24ac:	90 93 36 02 	sts	0x0236, r25
    24b0:	80 93 35 02 	sts	0x0235, r24
    24b4:	51 c0       	rjmp	.+162    	; 0x2558 <__stack+0x359>
			}
			else
			{
				color_found++;
    24b6:	80 91 5b 02 	lds	r24, 0x025B
    24ba:	90 91 5c 02 	lds	r25, 0x025C
    24be:	01 96       	adiw	r24, 0x01	; 1
    24c0:	90 93 5c 02 	sts	0x025C, r25
    24c4:	80 93 5b 02 	sts	0x025B, r24
				servo1_mov(0);
    24c8:	80 e0       	ldi	r24, 0x00	; 0
    24ca:	90 e0       	ldi	r25, 0x00	; 0
    24cc:	0e 94 c9 09 	call	0x1392	; 0x1392 <servo1_mov>
    24d0:	8f ef       	ldi	r24, 0xFF	; 255
    24d2:	9f ef       	ldi	r25, 0xFF	; 255
    24d4:	ac e2       	ldi	r26, 0x2C	; 44
    24d6:	81 50       	subi	r24, 0x01	; 1
    24d8:	90 40       	sbci	r25, 0x00	; 0
    24da:	a0 40       	sbci	r26, 0x00	; 0
    24dc:	e1 f7       	brne	.-8      	; 0x24d6 <__stack+0x2d7>
    24de:	00 c0       	rjmp	.+0      	; 0x24e0 <__stack+0x2e1>
    24e0:	00 00       	nop
				_delay_ms(1000);
				pick_waste();
    24e2:	0e 94 48 0a 	call	0x1490	; 0x1490 <pick_waste>
				servo1_mov(80);
    24e6:	80 e5       	ldi	r24, 0x50	; 80
    24e8:	90 e0       	ldi	r25, 0x00	; 0
    24ea:	0e 94 c9 09 	call	0x1392	; 0x1392 <servo1_mov>
    24ee:	8f ef       	ldi	r24, 0xFF	; 255
    24f0:	9f ef       	ldi	r25, 0xFF	; 255
    24f2:	ac e2       	ldi	r26, 0x2C	; 44
    24f4:	81 50       	subi	r24, 0x01	; 1
    24f6:	90 40       	sbci	r25, 0x00	; 0
    24f8:	a0 40       	sbci	r26, 0x00	; 0
    24fa:	e1 f7       	brne	.-8      	; 0x24f4 <__stack+0x2f5>
    24fc:	00 c0       	rjmp	.+0      	; 0x24fe <__stack+0x2ff>
    24fe:	00 00       	nop
				_delay_ms(1000);
				if(deposition_zone_B==1)
    2500:	80 91 39 02 	lds	r24, 0x0239
    2504:	90 91 3a 02 	lds	r25, 0x023A
    2508:	81 30       	cpi	r24, 0x01	; 1
    250a:	91 05       	cpc	r25, r1
    250c:	29 f4       	brne	.+10     	; 0x2518 <__stack+0x319>
				path_find(16);
    250e:	80 e1       	ldi	r24, 0x10	; 16
    2510:	90 e0       	ldi	r25, 0x00	; 0
    2512:	0e 94 e3 05 	call	0xbc6	; 0xbc6 <path_find>
    2516:	17 c0       	rjmp	.+46     	; 0x2546 <__stack+0x347>
				else if(deposition_zone_A==1)
    2518:	80 91 3b 02 	lds	r24, 0x023B
    251c:	90 91 3c 02 	lds	r25, 0x023C
    2520:	81 30       	cpi	r24, 0x01	; 1
    2522:	91 05       	cpc	r25, r1
    2524:	29 f4       	brne	.+10     	; 0x2530 <__stack+0x331>
				path_find(15);
    2526:	8f e0       	ldi	r24, 0x0F	; 15
    2528:	90 e0       	ldi	r25, 0x00	; 0
    252a:	0e 94 e3 05 	call	0xbc6	; 0xbc6 <path_find>
    252e:	0b c0       	rjmp	.+22     	; 0x2546 <__stack+0x347>
				else if(deposition_zone_C==1)
    2530:	80 91 37 02 	lds	r24, 0x0237
    2534:	90 91 38 02 	lds	r25, 0x0238
    2538:	81 30       	cpi	r24, 0x01	; 1
    253a:	91 05       	cpc	r25, r1
    253c:	21 f4       	brne	.+8      	; 0x2546 <__stack+0x347>
				path_find(17);
    253e:	81 e1       	ldi	r24, 0x11	; 17
    2540:	90 e0       	ldi	r25, 0x00	; 0
    2542:	0e 94 e3 05 	call	0xbc6	; 0xbc6 <path_find>
				color_index++;
    2546:	80 91 52 02 	lds	r24, 0x0252
    254a:	90 91 53 02 	lds	r25, 0x0253
    254e:	01 96       	adiw	r24, 0x01	; 1
    2550:	90 93 53 02 	sts	0x0253, r25
    2554:	80 93 52 02 	sts	0x0252, r24
			}

		}
				if(node_number==4)
    2558:	80 91 5f 02 	lds	r24, 0x025F
    255c:	90 91 60 02 	lds	r25, 0x0260
    2560:	84 30       	cpi	r24, 0x04	; 4
    2562:	91 05       	cpc	r25, r1
    2564:	09 f0       	breq	.+2      	; 0x2568 <__stack+0x369>
    2566:	4b c0       	rjmp	.+150    	; 0x25fe <__stack+0x3ff>
		{
			distance('b',4,'o');
    2568:	82 e6       	ldi	r24, 0x62	; 98
    256a:	40 e0       	ldi	r20, 0x00	; 0
    256c:	50 e0       	ldi	r21, 0x00	; 0
    256e:	60 e8       	ldi	r22, 0x80	; 128
    2570:	70 e4       	ldi	r23, 0x40	; 64
    2572:	2f e6       	ldi	r18, 0x6F	; 111
    2574:	0e 94 8a 07 	call	0xf14	; 0xf14 <distance>
			servo1_mov(66);
    2578:	82 e4       	ldi	r24, 0x42	; 66
    257a:	90 e0       	ldi	r25, 0x00	; 0
    257c:	0e 94 c9 09 	call	0x1392	; 0x1392 <servo1_mov>
    2580:	8f ef       	ldi	r24, 0xFF	; 255
    2582:	9f ef       	ldi	r25, 0xFF	; 255
    2584:	ac e2       	ldi	r26, 0x2C	; 44
    2586:	81 50       	subi	r24, 0x01	; 1
    2588:	90 40       	sbci	r25, 0x00	; 0
    258a:	a0 40       	sbci	r26, 0x00	; 0
    258c:	e1 f7       	brne	.-8      	; 0x2586 <__stack+0x387>
    258e:	00 c0       	rjmp	.+0      	; 0x2590 <__stack+0x391>
    2590:	00 00       	nop
			_delay_ms(1000);
			servo2_mov(45);
    2592:	8d e2       	ldi	r24, 0x2D	; 45
    2594:	90 e0       	ldi	r25, 0x00	; 0
    2596:	0e 94 13 0a 	call	0x1426	; 0x1426 <servo2_mov>
    259a:	8f ef       	ldi	r24, 0xFF	; 255
    259c:	9f e7       	ldi	r25, 0x7F	; 127
    259e:	a6 e1       	ldi	r26, 0x16	; 22
    25a0:	81 50       	subi	r24, 0x01	; 1
    25a2:	90 40       	sbci	r25, 0x00	; 0
    25a4:	a0 40       	sbci	r26, 0x00	; 0
    25a6:	e1 f7       	brne	.-8      	; 0x25a0 <__stack+0x3a1>
    25a8:	00 c0       	rjmp	.+0      	; 0x25aa <__stack+0x3ab>
    25aa:	00 00       	nop
			_delay_ms(500);
			servo1_mov(90);
    25ac:	8a e5       	ldi	r24, 0x5A	; 90
    25ae:	90 e0       	ldi	r25, 0x00	; 0
    25b0:	0e 94 c9 09 	call	0x1392	; 0x1392 <servo1_mov>
			left();
    25b4:	0e 94 14 08 	call	0x1028	; 0x1028 <left>
			navigation_in_degrees=navigation_in_degrees+180;
    25b8:	80 91 3d 02 	lds	r24, 0x023D
    25bc:	90 91 3e 02 	lds	r25, 0x023E
    25c0:	8c 54       	subi	r24, 0x4C	; 76
    25c2:	9f 4f       	sbci	r25, 0xFF	; 255
    25c4:	90 93 3e 02 	sts	0x023E, r25
    25c8:	80 93 3d 02 	sts	0x023D, r24
			angle_rotate(180);
    25cc:	84 eb       	ldi	r24, 0xB4	; 180
    25ce:	90 e0       	ldi	r25, 0x00	; 0
    25d0:	0e 94 24 08 	call	0x1048	; 0x1048 <angle_rotate>
			path_find(0);
    25d4:	80 e0       	ldi	r24, 0x00	; 0
    25d6:	90 e0       	ldi	r25, 0x00	; 0
    25d8:	0e 94 e3 05 	call	0xbc6	; 0xbc6 <path_find>
			path_index++;
    25dc:	80 91 59 02 	lds	r24, 0x0259
    25e0:	90 91 5a 02 	lds	r25, 0x025A
    25e4:	01 96       	adiw	r24, 0x01	; 1
    25e6:	90 93 5a 02 	sts	0x025A, r25
    25ea:	80 93 59 02 	sts	0x0259, r24
			distance('b',4,'o');
    25ee:	82 e6       	ldi	r24, 0x62	; 98
    25f0:	40 e0       	ldi	r20, 0x00	; 0
    25f2:	50 e0       	ldi	r21, 0x00	; 0
    25f4:	60 e8       	ldi	r22, 0x80	; 128
    25f6:	70 e4       	ldi	r23, 0x40	; 64
    25f8:	2f e6       	ldi	r18, 0x6F	; 111
    25fa:	0e 94 8a 07 	call	0xf14	; 0xf14 <distance>

		}
		if(node_number==14)
    25fe:	80 91 5f 02 	lds	r24, 0x025F
    2602:	90 91 60 02 	lds	r25, 0x0260
    2606:	8e 30       	cpi	r24, 0x0E	; 14
    2608:	91 05       	cpc	r25, r1
    260a:	09 f0       	breq	.+2      	; 0x260e <__stack+0x40f>
    260c:	4b c0       	rjmp	.+150    	; 0x26a4 <__stack+0x4a5>
		{
			distance('b',4,'o');
    260e:	82 e6       	ldi	r24, 0x62	; 98
    2610:	40 e0       	ldi	r20, 0x00	; 0
    2612:	50 e0       	ldi	r21, 0x00	; 0
    2614:	60 e8       	ldi	r22, 0x80	; 128
    2616:	70 e4       	ldi	r23, 0x40	; 64
    2618:	2f e6       	ldi	r18, 0x6F	; 111
    261a:	0e 94 8a 07 	call	0xf14	; 0xf14 <distance>
			servo1_mov(66);
    261e:	82 e4       	ldi	r24, 0x42	; 66
    2620:	90 e0       	ldi	r25, 0x00	; 0
    2622:	0e 94 c9 09 	call	0x1392	; 0x1392 <servo1_mov>
    2626:	8f ef       	ldi	r24, 0xFF	; 255
    2628:	9f ef       	ldi	r25, 0xFF	; 255
    262a:	ac e2       	ldi	r26, 0x2C	; 44
    262c:	81 50       	subi	r24, 0x01	; 1
    262e:	90 40       	sbci	r25, 0x00	; 0
    2630:	a0 40       	sbci	r26, 0x00	; 0
    2632:	e1 f7       	brne	.-8      	; 0x262c <__stack+0x42d>
    2634:	00 c0       	rjmp	.+0      	; 0x2636 <__stack+0x437>
    2636:	00 00       	nop
			_delay_ms(1000);
			servo2_mov(45);
    2638:	8d e2       	ldi	r24, 0x2D	; 45
    263a:	90 e0       	ldi	r25, 0x00	; 0
    263c:	0e 94 13 0a 	call	0x1426	; 0x1426 <servo2_mov>
    2640:	8f ef       	ldi	r24, 0xFF	; 255
    2642:	9f e7       	ldi	r25, 0x7F	; 127
    2644:	a6 e1       	ldi	r26, 0x16	; 22
    2646:	81 50       	subi	r24, 0x01	; 1
    2648:	90 40       	sbci	r25, 0x00	; 0
    264a:	a0 40       	sbci	r26, 0x00	; 0
    264c:	e1 f7       	brne	.-8      	; 0x2646 <__stack+0x447>
    264e:	00 c0       	rjmp	.+0      	; 0x2650 <__stack+0x451>
    2650:	00 00       	nop
			_delay_ms(500);
			servo1_mov(90);
    2652:	8a e5       	ldi	r24, 0x5A	; 90
    2654:	90 e0       	ldi	r25, 0x00	; 0
    2656:	0e 94 c9 09 	call	0x1392	; 0x1392 <servo1_mov>
			left();
    265a:	0e 94 14 08 	call	0x1028	; 0x1028 <left>
			navigation_in_degrees=navigation_in_degrees+180;
    265e:	80 91 3d 02 	lds	r24, 0x023D
    2662:	90 91 3e 02 	lds	r25, 0x023E
    2666:	8c 54       	subi	r24, 0x4C	; 76
    2668:	9f 4f       	sbci	r25, 0xFF	; 255
    266a:	90 93 3e 02 	sts	0x023E, r25
    266e:	80 93 3d 02 	sts	0x023D, r24
			angle_rotate(180);
    2672:	84 eb       	ldi	r24, 0xB4	; 180
    2674:	90 e0       	ldi	r25, 0x00	; 0
    2676:	0e 94 24 08 	call	0x1048	; 0x1048 <angle_rotate>
			path_find(10);
    267a:	8a e0       	ldi	r24, 0x0A	; 10
    267c:	90 e0       	ldi	r25, 0x00	; 0
    267e:	0e 94 e3 05 	call	0xbc6	; 0xbc6 <path_find>
			path_index++;
    2682:	80 91 59 02 	lds	r24, 0x0259
    2686:	90 91 5a 02 	lds	r25, 0x025A
    268a:	01 96       	adiw	r24, 0x01	; 1
    268c:	90 93 5a 02 	sts	0x025A, r25
    2690:	80 93 59 02 	sts	0x0259, r24
			distance('b',4,'o');
    2694:	82 e6       	ldi	r24, 0x62	; 98
    2696:	40 e0       	ldi	r20, 0x00	; 0
    2698:	50 e0       	ldi	r21, 0x00	; 0
    269a:	60 e8       	ldi	r22, 0x80	; 128
    269c:	70 e4       	ldi	r23, 0x40	; 64
    269e:	2f e6       	ldi	r18, 0x6F	; 111
    26a0:	0e 94 8a 07 	call	0xf14	; 0xf14 <distance>
		}
		if(node_number==0)
    26a4:	80 91 5f 02 	lds	r24, 0x025F
    26a8:	90 91 60 02 	lds	r25, 0x0260
    26ac:	00 97       	sbiw	r24, 0x00	; 0
    26ae:	09 f0       	breq	.+2      	; 0x26b2 <__stack+0x4b3>
    26b0:	91 c0       	rjmp	.+290    	; 0x27d4 <__stack+0x5d5>
		{
			if(*navigation_pointer!='W')
    26b2:	e0 91 ab 02 	lds	r30, 0x02AB
    26b6:	f0 91 ac 02 	lds	r31, 0x02AC
    26ba:	80 81       	ld	r24, Z
    26bc:	87 35       	cpi	r24, 0x57	; 87
    26be:	09 f4       	brne	.+2      	; 0x26c2 <__stack+0x4c3>
    26c0:	52 c0       	rjmp	.+164    	; 0x2766 <__stack+0x567>
			{
				distance('f',11,'o');
    26c2:	86 e6       	ldi	r24, 0x66	; 102
    26c4:	40 e0       	ldi	r20, 0x00	; 0
    26c6:	50 e0       	ldi	r21, 0x00	; 0
    26c8:	60 e3       	ldi	r22, 0x30	; 48
    26ca:	71 e4       	ldi	r23, 0x41	; 65
    26cc:	2f e6       	ldi	r18, 0x6F	; 111
    26ce:	0e 94 8a 07 	call	0xf14	; 0xf14 <distance>
				if((*navigation_pointer-'W'==-9) || (*navigation_pointer-'W')==4 || (*navigation_pointer-'W')==14) //-9,4,14 are ASCII values for 270 degree while rotating in rightwards
    26d2:	e0 91 ab 02 	lds	r30, 0x02AB
    26d6:	f0 91 ac 02 	lds	r31, 0x02AC
    26da:	20 81       	ld	r18, Z
    26dc:	2e 34       	cpi	r18, 0x4E	; 78
    26de:	21 f0       	breq	.+8      	; 0x26e8 <__stack+0x4e9>
    26e0:	2b 35       	cpi	r18, 0x5B	; 91
    26e2:	11 f0       	breq	.+4      	; 0x26e8 <__stack+0x4e9>
    26e4:	25 36       	cpi	r18, 0x65	; 101
    26e6:	61 f4       	brne	.+24     	; 0x2700 <__stack+0x501>
				while(*navigation_pointer!='W')
				left_degrees(90);
    26e8:	8a e5       	ldi	r24, 0x5A	; 90
    26ea:	90 e0       	ldi	r25, 0x00	; 0
    26ec:	0e 94 99 08 	call	0x1132	; 0x1132 <left_degrees>
		{
			if(*navigation_pointer!='W')
			{
				distance('f',11,'o');
				if((*navigation_pointer-'W'==-9) || (*navigation_pointer-'W')==4 || (*navigation_pointer-'W')==14) //-9,4,14 are ASCII values for 270 degree while rotating in rightwards
				while(*navigation_pointer!='W')
    26f0:	e0 91 ab 02 	lds	r30, 0x02AB
    26f4:	f0 91 ac 02 	lds	r31, 0x02AC
    26f8:	80 81       	ld	r24, Z
    26fa:	87 35       	cpi	r24, 0x57	; 87
    26fc:	a9 f7       	brne	.-22     	; 0x26e8 <__stack+0x4e9>
    26fe:	2b c0       	rjmp	.+86     	; 0x2756 <__stack+0x557>
				left_degrees(90);
				else if(abs(*navigation_pointer-'W')==5 || abs(*navigation_pointer-'W')==18)
    2700:	82 2f       	mov	r24, r18
    2702:	90 e0       	ldi	r25, 0x00	; 0
    2704:	87 55       	subi	r24, 0x57	; 87
    2706:	90 40       	sbci	r25, 0x00	; 0
    2708:	1a f4       	brpl	.+6      	; 0x2710 <__stack+0x511>
    270a:	90 95       	com	r25
    270c:	81 95       	neg	r24
    270e:	9f 4f       	sbci	r25, 0xFF	; 255
    2710:	85 30       	cpi	r24, 0x05	; 5
    2712:	91 05       	cpc	r25, r1
    2714:	19 f4       	brne	.+6      	; 0x271c <__stack+0x51d>
				while(*navigation_pointer!='W')
    2716:	27 35       	cpi	r18, 0x57	; 87
    2718:	39 f4       	brne	.+14     	; 0x2728 <__stack+0x529>
    271a:	1d c0       	rjmp	.+58     	; 0x2756 <__stack+0x557>
			{
				distance('f',11,'o');
				if((*navigation_pointer-'W'==-9) || (*navigation_pointer-'W')==4 || (*navigation_pointer-'W')==14) //-9,4,14 are ASCII values for 270 degree while rotating in rightwards
				while(*navigation_pointer!='W')
				left_degrees(90);
				else if(abs(*navigation_pointer-'W')==5 || abs(*navigation_pointer-'W')==18)
    271c:	82 31       	cpi	r24, 0x12	; 18
    271e:	91 05       	cpc	r25, r1
    2720:	d1 f3       	breq	.-12     	; 0x2716 <__stack+0x517>
				while(*navigation_pointer!='W')
				right_degrees(180);
				else
				while(*navigation_pointer!='W')
    2722:	27 35       	cpi	r18, 0x57	; 87
    2724:	69 f4       	brne	.+26     	; 0x2740 <__stack+0x541>
    2726:	17 c0       	rjmp	.+46     	; 0x2756 <__stack+0x557>
				if((*navigation_pointer-'W'==-9) || (*navigation_pointer-'W')==4 || (*navigation_pointer-'W')==14) //-9,4,14 are ASCII values for 270 degree while rotating in rightwards
				while(*navigation_pointer!='W')
				left_degrees(90);
				else if(abs(*navigation_pointer-'W')==5 || abs(*navigation_pointer-'W')==18)
				while(*navigation_pointer!='W')
				right_degrees(180);
    2728:	84 eb       	ldi	r24, 0xB4	; 180
    272a:	90 e0       	ldi	r25, 0x00	; 0
    272c:	0e 94 00 09 	call	0x1200	; 0x1200 <right_degrees>
				distance('f',11,'o');
				if((*navigation_pointer-'W'==-9) || (*navigation_pointer-'W')==4 || (*navigation_pointer-'W')==14) //-9,4,14 are ASCII values for 270 degree while rotating in rightwards
				while(*navigation_pointer!='W')
				left_degrees(90);
				else if(abs(*navigation_pointer-'W')==5 || abs(*navigation_pointer-'W')==18)
				while(*navigation_pointer!='W')
    2730:	e0 91 ab 02 	lds	r30, 0x02AB
    2734:	f0 91 ac 02 	lds	r31, 0x02AC
    2738:	80 81       	ld	r24, Z
    273a:	87 35       	cpi	r24, 0x57	; 87
    273c:	a9 f7       	brne	.-22     	; 0x2728 <__stack+0x529>
    273e:	0b c0       	rjmp	.+22     	; 0x2756 <__stack+0x557>
				right_degrees(180);
				else
				while(*navigation_pointer!='W')
				right_degrees(90);
    2740:	8a e5       	ldi	r24, 0x5A	; 90
    2742:	90 e0       	ldi	r25, 0x00	; 0
    2744:	0e 94 00 09 	call	0x1200	; 0x1200 <right_degrees>
				left_degrees(90);
				else if(abs(*navigation_pointer-'W')==5 || abs(*navigation_pointer-'W')==18)
				while(*navigation_pointer!='W')
				right_degrees(180);
				else
				while(*navigation_pointer!='W')
    2748:	e0 91 ab 02 	lds	r30, 0x02AB
    274c:	f0 91 ac 02 	lds	r31, 0x02AC
    2750:	80 81       	ld	r24, Z
    2752:	87 35       	cpi	r24, 0x57	; 87
    2754:	a9 f7       	brne	.-22     	; 0x2740 <__stack+0x541>
				right_degrees(90);
				distance('b',11,'o');
    2756:	82 e6       	ldi	r24, 0x62	; 98
    2758:	40 e0       	ldi	r20, 0x00	; 0
    275a:	50 e0       	ldi	r21, 0x00	; 0
    275c:	60 e3       	ldi	r22, 0x30	; 48
    275e:	71 e4       	ldi	r23, 0x41	; 65
    2760:	2f e6       	ldi	r18, 0x6F	; 111
    2762:	0e 94 8a 07 	call	0xf14	; 0xf14 <distance>
			}
			if(sharp(digital[11])>300)
    2766:	80 91 4e 05 	lds	r24, 0x054E
    276a:	90 91 4f 05 	lds	r25, 0x054F
    276e:	0e 94 5e 0b 	call	0x16bc	; 0x16bc <sharp>
    2772:	a1 e0       	ldi	r26, 0x01	; 1
    2774:	8d 32       	cpi	r24, 0x2D	; 45
    2776:	9a 07       	cpc	r25, r26
    2778:	2c f0       	brlt	.+10     	; 0x2784 <__stack+0x585>
			{
				bridge=Area;
    277a:	80 91 56 02 	lds	r24, 0x0256
    277e:	80 93 55 02 	sts	0x0255, r24
    2782:	12 c0       	rjmp	.+36     	; 0x27a8 <__stack+0x5a9>
			}
			else
			{
				bridge='I';
    2784:	89 e4       	ldi	r24, 0x49	; 73
    2786:	80 93 55 02 	sts	0x0255, r24
				if(weight_block_position_2==0)
    278a:	80 91 31 02 	lds	r24, 0x0231
    278e:	90 91 32 02 	lds	r25, 0x0232
    2792:	00 97       	sbiw	r24, 0x00	; 0
    2794:	29 f4       	brne	.+10     	; 0x27a0 <__stack+0x5a1>
				enq_end(1);
    2796:	81 e0       	ldi	r24, 0x01	; 1
    2798:	90 e0       	ldi	r25, 0x00	; 0
    279a:	0e 94 d8 06 	call	0xdb0	; 0xdb0 <enq_end>
    279e:	04 c0       	rjmp	.+8      	; 0x27a8 <__stack+0x5a9>
				else
				enq_end(3);
    27a0:	83 e0       	ldi	r24, 0x03	; 3
    27a2:	90 e0       	ldi	r25, 0x00	; 0
    27a4:	0e 94 d8 06 	call	0xdb0	; 0xdb0 <enq_end>
			}
			navigate();
    27a8:	0e 94 55 04 	call	0x8aa	; 0x8aa <navigate>
			if(servo_angle_1!=180)
    27ac:	80 91 41 02 	lds	r24, 0x0241
    27b0:	90 91 42 02 	lds	r25, 0x0242
    27b4:	84 3b       	cpi	r24, 0xB4	; 180
    27b6:	91 05       	cpc	r25, r1
    27b8:	69 f0       	breq	.+26     	; 0x27d4 <__stack+0x5d5>
			{
				servo1_mov(80);
    27ba:	80 e5       	ldi	r24, 0x50	; 80
    27bc:	90 e0       	ldi	r25, 0x00	; 0
    27be:	0e 94 c9 09 	call	0x1392	; 0x1392 <servo1_mov>
    27c2:	8f ef       	ldi	r24, 0xFF	; 255
    27c4:	9f ef       	ldi	r25, 0xFF	; 255
    27c6:	a3 e2       	ldi	r26, 0x23	; 35
    27c8:	81 50       	subi	r24, 0x01	; 1
    27ca:	90 40       	sbci	r25, 0x00	; 0
    27cc:	a0 40       	sbci	r26, 0x00	; 0
    27ce:	e1 f7       	brne	.-8      	; 0x27c8 <__stack+0x5c9>
    27d0:	00 c0       	rjmp	.+0      	; 0x27d2 <__stack+0x5d3>
    27d2:	00 00       	nop
				_delay_ms(800);
			}
		}
		if(node_number==10)
    27d4:	80 91 5f 02 	lds	r24, 0x025F
    27d8:	90 91 60 02 	lds	r25, 0x0260
    27dc:	8a 30       	cpi	r24, 0x0A	; 10
    27de:	91 05       	cpc	r25, r1
    27e0:	09 f0       	breq	.+2      	; 0x27e4 <__stack+0x5e5>
    27e2:	91 c0       	rjmp	.+290    	; 0x2906 <__stack+0x707>
		{
			if(*navigation_pointer!='E')
    27e4:	e0 91 ab 02 	lds	r30, 0x02AB
    27e8:	f0 91 ac 02 	lds	r31, 0x02AC
    27ec:	80 81       	ld	r24, Z
    27ee:	85 34       	cpi	r24, 0x45	; 69
    27f0:	09 f4       	brne	.+2      	; 0x27f4 <__stack+0x5f5>
    27f2:	52 c0       	rjmp	.+164    	; 0x2898 <__stack+0x699>
			{
				distance('f',11,'o');
    27f4:	86 e6       	ldi	r24, 0x66	; 102
    27f6:	40 e0       	ldi	r20, 0x00	; 0
    27f8:	50 e0       	ldi	r21, 0x00	; 0
    27fa:	60 e3       	ldi	r22, 0x30	; 48
    27fc:	71 e4       	ldi	r23, 0x41	; 65
    27fe:	2f e6       	ldi	r18, 0x6F	; 111
    2800:	0e 94 8a 07 	call	0xf14	; 0xf14 <distance>
				if((*navigation_pointer-'E'==-9) || (*navigation_pointer-'E')==4 || (*navigation_pointer-'E')==14) //-9,4,14 are ASCII values for 270 degree while rotating in rightwards
    2804:	e0 91 ab 02 	lds	r30, 0x02AB
    2808:	f0 91 ac 02 	lds	r31, 0x02AC
    280c:	20 81       	ld	r18, Z
    280e:	2c 33       	cpi	r18, 0x3C	; 60
    2810:	21 f0       	breq	.+8      	; 0x281a <__stack+0x61b>
    2812:	29 34       	cpi	r18, 0x49	; 73
    2814:	11 f0       	breq	.+4      	; 0x281a <__stack+0x61b>
    2816:	23 35       	cpi	r18, 0x53	; 83
    2818:	61 f4       	brne	.+24     	; 0x2832 <__stack+0x633>
				while(*navigation_pointer!='E')
				left_degrees(90);
    281a:	8a e5       	ldi	r24, 0x5A	; 90
    281c:	90 e0       	ldi	r25, 0x00	; 0
    281e:	0e 94 99 08 	call	0x1132	; 0x1132 <left_degrees>
		{
			if(*navigation_pointer!='E')
			{
				distance('f',11,'o');
				if((*navigation_pointer-'E'==-9) || (*navigation_pointer-'E')==4 || (*navigation_pointer-'E')==14) //-9,4,14 are ASCII values for 270 degree while rotating in rightwards
				while(*navigation_pointer!='E')
    2822:	e0 91 ab 02 	lds	r30, 0x02AB
    2826:	f0 91 ac 02 	lds	r31, 0x02AC
    282a:	80 81       	ld	r24, Z
    282c:	85 34       	cpi	r24, 0x45	; 69
    282e:	a9 f7       	brne	.-22     	; 0x281a <__stack+0x61b>
    2830:	2b c0       	rjmp	.+86     	; 0x2888 <__stack+0x689>
				left_degrees(90);
				else if(abs(*navigation_pointer-'E')==5 || abs(*navigation_pointer-'E')==18)
    2832:	82 2f       	mov	r24, r18
    2834:	90 e0       	ldi	r25, 0x00	; 0
    2836:	85 54       	subi	r24, 0x45	; 69
    2838:	90 40       	sbci	r25, 0x00	; 0
    283a:	1a f4       	brpl	.+6      	; 0x2842 <__stack+0x643>
    283c:	90 95       	com	r25
    283e:	81 95       	neg	r24
    2840:	9f 4f       	sbci	r25, 0xFF	; 255
    2842:	85 30       	cpi	r24, 0x05	; 5
    2844:	91 05       	cpc	r25, r1
    2846:	19 f4       	brne	.+6      	; 0x284e <__stack+0x64f>
				while(*navigation_pointer!='E')
    2848:	25 34       	cpi	r18, 0x45	; 69
    284a:	39 f4       	brne	.+14     	; 0x285a <__stack+0x65b>
    284c:	1d c0       	rjmp	.+58     	; 0x2888 <__stack+0x689>
			{
				distance('f',11,'o');
				if((*navigation_pointer-'E'==-9) || (*navigation_pointer-'E')==4 || (*navigation_pointer-'E')==14) //-9,4,14 are ASCII values for 270 degree while rotating in rightwards
				while(*navigation_pointer!='E')
				left_degrees(90);
				else if(abs(*navigation_pointer-'E')==5 || abs(*navigation_pointer-'E')==18)
    284e:	82 31       	cpi	r24, 0x12	; 18
    2850:	91 05       	cpc	r25, r1
    2852:	d1 f3       	breq	.-12     	; 0x2848 <__stack+0x649>
				while(*navigation_pointer!='E')
				right_degrees(180);
				else
				while(*navigation_pointer!='E')
    2854:	25 34       	cpi	r18, 0x45	; 69
    2856:	69 f4       	brne	.+26     	; 0x2872 <__stack+0x673>
    2858:	17 c0       	rjmp	.+46     	; 0x2888 <__stack+0x689>
				if((*navigation_pointer-'E'==-9) || (*navigation_pointer-'E')==4 || (*navigation_pointer-'E')==14) //-9,4,14 are ASCII values for 270 degree while rotating in rightwards
				while(*navigation_pointer!='E')
				left_degrees(90);
				else if(abs(*navigation_pointer-'E')==5 || abs(*navigation_pointer-'E')==18)
				while(*navigation_pointer!='E')
				right_degrees(180);
    285a:	84 eb       	ldi	r24, 0xB4	; 180
    285c:	90 e0       	ldi	r25, 0x00	; 0
    285e:	0e 94 00 09 	call	0x1200	; 0x1200 <right_degrees>
				distance('f',11,'o');
				if((*navigation_pointer-'E'==-9) || (*navigation_pointer-'E')==4 || (*navigation_pointer-'E')==14) //-9,4,14 are ASCII values for 270 degree while rotating in rightwards
				while(*navigation_pointer!='E')
				left_degrees(90);
				else if(abs(*navigation_pointer-'E')==5 || abs(*navigation_pointer-'E')==18)
				while(*navigation_pointer!='E')
    2862:	e0 91 ab 02 	lds	r30, 0x02AB
    2866:	f0 91 ac 02 	lds	r31, 0x02AC
    286a:	80 81       	ld	r24, Z
    286c:	85 34       	cpi	r24, 0x45	; 69
    286e:	a9 f7       	brne	.-22     	; 0x285a <__stack+0x65b>
    2870:	0b c0       	rjmp	.+22     	; 0x2888 <__stack+0x689>
				right_degrees(180);
				else
				while(*navigation_pointer!='E')
				right_degrees(90);
    2872:	8a e5       	ldi	r24, 0x5A	; 90
    2874:	90 e0       	ldi	r25, 0x00	; 0
    2876:	0e 94 00 09 	call	0x1200	; 0x1200 <right_degrees>
				left_degrees(90);
				else if(abs(*navigation_pointer-'E')==5 || abs(*navigation_pointer-'E')==18)
				while(*navigation_pointer!='E')
				right_degrees(180);
				else
				while(*navigation_pointer!='E')
    287a:	e0 91 ab 02 	lds	r30, 0x02AB
    287e:	f0 91 ac 02 	lds	r31, 0x02AC
    2882:	80 81       	ld	r24, Z
    2884:	85 34       	cpi	r24, 0x45	; 69
    2886:	a9 f7       	brne	.-22     	; 0x2872 <__stack+0x673>
				right_degrees(90);
				distance('b',12,'o');
    2888:	82 e6       	ldi	r24, 0x62	; 98
    288a:	40 e0       	ldi	r20, 0x00	; 0
    288c:	50 e0       	ldi	r21, 0x00	; 0
    288e:	60 e4       	ldi	r22, 0x40	; 64
    2890:	71 e4       	ldi	r23, 0x41	; 65
    2892:	2f e6       	ldi	r18, 0x6F	; 111
    2894:	0e 94 8a 07 	call	0xf14	; 0xf14 <distance>
			}
			if(sharp(digital[11])>300)
    2898:	80 91 4e 05 	lds	r24, 0x054E
    289c:	90 91 4f 05 	lds	r25, 0x054F
    28a0:	0e 94 5e 0b 	call	0x16bc	; 0x16bc <sharp>
    28a4:	a1 e0       	ldi	r26, 0x01	; 1
    28a6:	8d 32       	cpi	r24, 0x2D	; 45
    28a8:	9a 07       	cpc	r25, r26
    28aa:	2c f0       	brlt	.+10     	; 0x28b6 <__stack+0x6b7>
			bridge=Area;
    28ac:	80 91 56 02 	lds	r24, 0x0256
    28b0:	80 93 55 02 	sts	0x0255, r24
    28b4:	12 c0       	rjmp	.+36     	; 0x28da <__stack+0x6db>
			else
			{
				bridge='C';
    28b6:	83 e4       	ldi	r24, 0x43	; 67
    28b8:	80 93 55 02 	sts	0x0255, r24
				if(weight_block_position_3!=0)
    28bc:	80 91 2f 02 	lds	r24, 0x022F
    28c0:	90 91 30 02 	lds	r25, 0x0230
    28c4:	00 97       	sbiw	r24, 0x00	; 0
    28c6:	29 f0       	breq	.+10     	; 0x28d2 <__stack+0x6d3>
				enq_end(12);
    28c8:	8c e0       	ldi	r24, 0x0C	; 12
    28ca:	90 e0       	ldi	r25, 0x00	; 0
    28cc:	0e 94 d8 06 	call	0xdb0	; 0xdb0 <enq_end>
    28d0:	04 c0       	rjmp	.+8      	; 0x28da <__stack+0x6db>
				else
				enq_end(13);
    28d2:	8d e0       	ldi	r24, 0x0D	; 13
    28d4:	90 e0       	ldi	r25, 0x00	; 0
    28d6:	0e 94 d8 06 	call	0xdb0	; 0xdb0 <enq_end>
			}
			navigate();
    28da:	0e 94 55 04 	call	0x8aa	; 0x8aa <navigate>
			if(servo_angle_1!=180)
    28de:	80 91 41 02 	lds	r24, 0x0241
    28e2:	90 91 42 02 	lds	r25, 0x0242
    28e6:	84 3b       	cpi	r24, 0xB4	; 180
    28e8:	91 05       	cpc	r25, r1
    28ea:	69 f0       	breq	.+26     	; 0x2906 <__stack+0x707>
			{
				servo1_mov(80);
    28ec:	80 e5       	ldi	r24, 0x50	; 80
    28ee:	90 e0       	ldi	r25, 0x00	; 0
    28f0:	0e 94 c9 09 	call	0x1392	; 0x1392 <servo1_mov>
    28f4:	8f ef       	ldi	r24, 0xFF	; 255
    28f6:	9f ef       	ldi	r25, 0xFF	; 255
    28f8:	a3 e2       	ldi	r26, 0x23	; 35
    28fa:	81 50       	subi	r24, 0x01	; 1
    28fc:	90 40       	sbci	r25, 0x00	; 0
    28fe:	a0 40       	sbci	r26, 0x00	; 0
    2900:	e1 f7       	brne	.-8      	; 0x28fa <__stack+0x6fb>
    2902:	00 c0       	rjmp	.+0      	; 0x2904 <__stack+0x705>
    2904:	00 00       	nop
				_delay_ms(800);
			}
		}

		if(que_length!=0 && path[path_index]=='\0')
    2906:	80 91 57 02 	lds	r24, 0x0257
    290a:	90 91 58 02 	lds	r25, 0x0258
    290e:	00 97       	sbiw	r24, 0x00	; 0
    2910:	a1 f0       	breq	.+40     	; 0x293a <__stack+0x73b>
    2912:	e0 91 59 02 	lds	r30, 0x0259
    2916:	f0 91 5a 02 	lds	r31, 0x025A
    291a:	e1 59       	subi	r30, 0x91	; 145
    291c:	fd 4f       	sbci	r31, 0xFD	; 253
    291e:	80 81       	ld	r24, Z
    2920:	88 23       	and	r24, r24
    2922:	49 f5       	brne	.+82     	; 0x2976 <__stack+0x777>
		{
			path_find(end->num);
    2924:	e0 91 4a 02 	lds	r30, 0x024A
    2928:	f0 91 4b 02 	lds	r31, 0x024B
    292c:	84 81       	ldd	r24, Z+4	; 0x04
    292e:	95 81       	ldd	r25, Z+5	; 0x05
    2930:	0e 94 e3 05 	call	0xbc6	; 0xbc6 <path_find>
			dequeue();
    2934:	0e 94 1a 07 	call	0xe34	; 0xe34 <dequeue>
    2938:	1e c0       	rjmp	.+60     	; 0x2976 <__stack+0x777>
		}
		else if(path[path_index]=='\0')
    293a:	e0 91 59 02 	lds	r30, 0x0259
    293e:	f0 91 5a 02 	lds	r31, 0x025A
    2942:	e1 59       	subi	r30, 0x91	; 145
    2944:	fd 4f       	sbci	r31, 0xFD	; 253
    2946:	80 81       	ld	r24, Z
    2948:	88 23       	and	r24, r24
    294a:	a9 f4       	brne	.+42     	; 0x2976 <__stack+0x777>
		{
			buzzer(1);
    294c:	81 e0       	ldi	r24, 0x01	; 1
    294e:	90 e0       	ldi	r25, 0x00	; 0
    2950:	0e 94 37 07 	call	0xe6e	; 0xe6e <buzzer>
    2954:	8f ef       	ldi	r24, 0xFF	; 255
    2956:	9f ef       	ldi	r25, 0xFF	; 255
    2958:	a9 e5       	ldi	r26, 0x59	; 89
    295a:	81 50       	subi	r24, 0x01	; 1
    295c:	90 40       	sbci	r25, 0x00	; 0
    295e:	a0 40       	sbci	r26, 0x00	; 0
    2960:	e1 f7       	brne	.-8      	; 0x295a <__stack+0x75b>
    2962:	00 c0       	rjmp	.+0      	; 0x2964 <__stack+0x765>
    2964:	00 00       	nop
			_delay_ms(2000);
			buzzer(0);
    2966:	80 e0       	ldi	r24, 0x00	; 0
    2968:	90 e0       	ldi	r25, 0x00	; 0
    296a:	0e 94 37 07 	call	0xe6e	; 0xe6e <buzzer>
			exit(1);
    296e:	81 e0       	ldi	r24, 0x01	; 1
    2970:	90 e0       	ldi	r25, 0x00	; 0
    2972:	0e 94 9e 1c 	call	0x393c	; 0x393c <_exit>
		}
	}
}
    2976:	df 91       	pop	r29
    2978:	cf 91       	pop	r28
    297a:	1f 91       	pop	r17
    297c:	0f 91       	pop	r16
    297e:	ff 90       	pop	r15
    2980:	ef 90       	pop	r14
    2982:	df 90       	pop	r13
    2984:	cf 90       	pop	r12
    2986:	bf 90       	pop	r11
    2988:	af 90       	pop	r10
    298a:	08 95       	ret

0000298c <__vector_35>:
* Example Call:								NONE
*
*/

ISR(TIMER3_OVF_vect) // Timer 3overflow interrupt to get digital value
{
    298c:	1f 92       	push	r1
    298e:	0f 92       	push	r0
    2990:	0f b6       	in	r0, 0x3f	; 63
    2992:	0f 92       	push	r0
    2994:	0b b6       	in	r0, 0x3b	; 59
    2996:	0f 92       	push	r0
    2998:	11 24       	eor	r1, r1
    299a:	2f 93       	push	r18
    299c:	3f 93       	push	r19
    299e:	4f 93       	push	r20
    29a0:	5f 93       	push	r21
    29a2:	6f 93       	push	r22
    29a4:	7f 93       	push	r23
    29a6:	8f 93       	push	r24
    29a8:	9f 93       	push	r25
    29aa:	af 93       	push	r26
    29ac:	bf 93       	push	r27
    29ae:	ef 93       	push	r30
    29b0:	ff 93       	push	r31
	int i=0;
	for(i=1;i<4;i++)
	digital[i]=getdata(i);
    29b2:	81 e0       	ldi	r24, 0x01	; 1
    29b4:	90 e0       	ldi	r25, 0x00	; 0
    29b6:	0e 94 74 0a 	call	0x14e8	; 0x14e8 <getdata>
    29ba:	28 2f       	mov	r18, r24
    29bc:	39 2f       	mov	r19, r25
    29be:	30 93 3b 05 	sts	0x053B, r19
    29c2:	20 93 3a 05 	sts	0x053A, r18
    29c6:	82 e0       	ldi	r24, 0x02	; 2
    29c8:	90 e0       	ldi	r25, 0x00	; 0
    29ca:	0e 94 74 0a 	call	0x14e8	; 0x14e8 <getdata>
    29ce:	28 2f       	mov	r18, r24
    29d0:	39 2f       	mov	r19, r25
    29d2:	30 93 3d 05 	sts	0x053D, r19
    29d6:	20 93 3c 05 	sts	0x053C, r18
    29da:	83 e0       	ldi	r24, 0x03	; 3
    29dc:	90 e0       	ldi	r25, 0x00	; 0
    29de:	0e 94 74 0a 	call	0x14e8	; 0x14e8 <getdata>
    29e2:	28 2f       	mov	r18, r24
    29e4:	39 2f       	mov	r19, r25
    29e6:	30 93 3f 05 	sts	0x053F, r19
    29ea:	20 93 3e 05 	sts	0x053E, r18
	digital[11]=getdata(11);
    29ee:	8b e0       	ldi	r24, 0x0B	; 11
    29f0:	90 e0       	ldi	r25, 0x00	; 0
    29f2:	0e 94 74 0a 	call	0x14e8	; 0x14e8 <getdata>
    29f6:	28 2f       	mov	r18, r24
    29f8:	39 2f       	mov	r19, r25
    29fa:	30 93 4f 05 	sts	0x054F, r19
    29fe:	20 93 4e 05 	sts	0x054E, r18
	if(node_number<10)
    2a02:	80 91 5f 02 	lds	r24, 0x025F
    2a06:	90 91 60 02 	lds	r25, 0x0260
    2a0a:	8a 30       	cpi	r24, 0x0A	; 10
    2a0c:	91 05       	cpc	r25, r1
    2a0e:	24 f4       	brge	.+8      	; 0x2a18 <__vector_35+0x8c>
	Area='C';
    2a10:	83 e4       	ldi	r24, 0x43	; 67
    2a12:	80 93 56 02 	sts	0x0256, r24
    2a16:	03 c0       	rjmp	.+6      	; 0x2a1e <__vector_35+0x92>
	else
	Area='I';
    2a18:	89 e4       	ldi	r24, 0x49	; 73
    2a1a:	80 93 56 02 	sts	0x0256, r24
}
    2a1e:	ff 91       	pop	r31
    2a20:	ef 91       	pop	r30
    2a22:	bf 91       	pop	r27
    2a24:	af 91       	pop	r26
    2a26:	9f 91       	pop	r25
    2a28:	8f 91       	pop	r24
    2a2a:	7f 91       	pop	r23
    2a2c:	6f 91       	pop	r22
    2a2e:	5f 91       	pop	r21
    2a30:	4f 91       	pop	r20
    2a32:	3f 91       	pop	r19
    2a34:	2f 91       	pop	r18
    2a36:	0f 90       	pop	r0
    2a38:	0b be       	out	0x3b, r0	; 59
    2a3a:	0f 90       	pop	r0
    2a3c:	0f be       	out	0x3f, r0	; 63
    2a3e:	0f 90       	pop	r0
    2a40:	1f 90       	pop	r1
    2a42:	18 95       	reti

00002a44 <line_following>:
*
*/

void line_following(void)
{
	if (digital[2]>60 || (digital[1]>15 && digital[2]>15))
    2a44:	80 91 3c 05 	lds	r24, 0x053C
    2a48:	90 91 3d 05 	lds	r25, 0x053D
    2a4c:	8d 33       	cpi	r24, 0x3D	; 61
    2a4e:	91 05       	cpc	r25, r1
    2a50:	70 f4       	brcc	.+28     	; 0x2a6e <line_following+0x2a>
    2a52:	80 91 3a 05 	lds	r24, 0x053A
    2a56:	90 91 3b 05 	lds	r25, 0x053B
    2a5a:	80 31       	cpi	r24, 0x10	; 16
    2a5c:	91 05       	cpc	r25, r1
    2a5e:	60 f0       	brcs	.+24     	; 0x2a78 <line_following+0x34>
    2a60:	80 91 3c 05 	lds	r24, 0x053C
    2a64:	90 91 3d 05 	lds	r25, 0x053D
    2a68:	80 31       	cpi	r24, 0x10	; 16
    2a6a:	91 05       	cpc	r25, r1
    2a6c:	28 f0       	brcs	.+10     	; 0x2a78 <line_following+0x34>
	{
		stop();
    2a6e:	0e 94 10 08 	call	0x1020	; 0x1020 <stop>
		node_behave();
    2a72:	0e 94 a0 0b 	call	0x1740	; 0x1740 <node_behave>
*/

void line_following(void)
{
	if (digital[2]>60 || (digital[1]>15 && digital[2]>15))
	{
    2a76:	08 95       	ret
		stop();
		node_behave();
	}
	else if(digital[2]>15 && (digital[1]>15 || digital[3]>15))
    2a78:	80 91 3c 05 	lds	r24, 0x053C
    2a7c:	90 91 3d 05 	lds	r25, 0x053D
    2a80:	80 31       	cpi	r24, 0x10	; 16
    2a82:	91 05       	cpc	r25, r1
    2a84:	98 f0       	brcs	.+38     	; 0x2aac <line_following+0x68>
    2a86:	80 91 3a 05 	lds	r24, 0x053A
    2a8a:	90 91 3b 05 	lds	r25, 0x053B
    2a8e:	80 31       	cpi	r24, 0x10	; 16
    2a90:	91 05       	cpc	r25, r1
    2a92:	38 f4       	brcc	.+14     	; 0x2aa2 <line_following+0x5e>
    2a94:	80 91 3e 05 	lds	r24, 0x053E
    2a98:	90 91 3f 05 	lds	r25, 0x053F
    2a9c:	80 31       	cpi	r24, 0x10	; 16
    2a9e:	91 05       	cpc	r25, r1
    2aa0:	28 f0       	brcs	.+10     	; 0x2aac <line_following+0x68>
	{	stop();
    2aa2:	0e 94 10 08 	call	0x1020	; 0x1020 <stop>
		node_behave();
    2aa6:	0e 94 a0 0b 	call	0x1740	; 0x1740 <node_behave>
	{
		stop();
		node_behave();
	}
	else if(digital[2]>15 && (digital[1]>15 || digital[3]>15))
	{	stop();
    2aaa:	08 95       	ret
		node_behave();
	}
	else if(digital[1]>15 && digital[3]<15)
    2aac:	80 91 3a 05 	lds	r24, 0x053A
    2ab0:	90 91 3b 05 	lds	r25, 0x053B
    2ab4:	80 31       	cpi	r24, 0x10	; 16
    2ab6:	91 05       	cpc	r25, r1
    2ab8:	80 f0       	brcs	.+32     	; 0x2ada <line_following+0x96>
    2aba:	80 91 3e 05 	lds	r24, 0x053E
    2abe:	90 91 3f 05 	lds	r25, 0x053F
    2ac2:	8f 30       	cpi	r24, 0x0F	; 15
    2ac4:	91 05       	cpc	r25, r1
    2ac6:	48 f4       	brcc	.+18     	; 0x2ada <line_following+0x96>
	{
		sppeed(180,174);
    2ac8:	84 eb       	ldi	r24, 0xB4	; 180
    2aca:	90 e0       	ldi	r25, 0x00	; 0
    2acc:	6e ea       	ldi	r22, 0xAE	; 174
    2ace:	70 e0       	ldi	r23, 0x00	; 0
    2ad0:	0e 94 f7 00 	call	0x1ee	; 0x1ee <sppeed>
		right();
    2ad4:	0e 94 18 08 	call	0x1030	; 0x1030 <right>
    2ad8:	08 95       	ret
	}
	else if(digital[1]<15 && digital[3]>15)
    2ada:	80 91 3a 05 	lds	r24, 0x053A
    2ade:	90 91 3b 05 	lds	r25, 0x053B
    2ae2:	8f 30       	cpi	r24, 0x0F	; 15
    2ae4:	91 05       	cpc	r25, r1
    2ae6:	80 f4       	brcc	.+32     	; 0x2b08 <line_following+0xc4>
    2ae8:	80 91 3e 05 	lds	r24, 0x053E
    2aec:	90 91 3f 05 	lds	r25, 0x053F
    2af0:	80 31       	cpi	r24, 0x10	; 16
    2af2:	91 05       	cpc	r25, r1
    2af4:	48 f0       	brcs	.+18     	; 0x2b08 <line_following+0xc4>
	{
		sppeed(180,174);
    2af6:	84 eb       	ldi	r24, 0xB4	; 180
    2af8:	90 e0       	ldi	r25, 0x00	; 0
    2afa:	6e ea       	ldi	r22, 0xAE	; 174
    2afc:	70 e0       	ldi	r23, 0x00	; 0
    2afe:	0e 94 f7 00 	call	0x1ee	; 0x1ee <sppeed>
		left();
    2b02:	0e 94 14 08 	call	0x1028	; 0x1028 <left>
    2b06:	08 95       	ret
	}
	else
	{
		sppeed(255,249);
    2b08:	8f ef       	ldi	r24, 0xFF	; 255
    2b0a:	90 e0       	ldi	r25, 0x00	; 0
    2b0c:	69 ef       	ldi	r22, 0xF9	; 249
    2b0e:	70 e0       	ldi	r23, 0x00	; 0
    2b10:	0e 94 f7 00 	call	0x1ee	; 0x1ee <sppeed>
		motion('f');
    2b14:	86 e6       	ldi	r24, 0x66	; 102
    2b16:	0e 94 4b 07 	call	0xe96	; 0xe96 <motion>
    2b1a:	08 95       	ret

00002b1c <color_sensor_pin_config>:
*
*/

void color_sensor_pin_config(void)
{
	DDRD  = DDRD | 0xFE; //set PD0 as input for color sensor output
    2b1c:	8a b1       	in	r24, 0x0a	; 10
    2b1e:	8e 6f       	ori	r24, 0xFE	; 254
    2b20:	8a b9       	out	0x0a, r24	; 10
	PORTD = PORTD | 0x01;//Enable internal pull-up for PORTD 0 pin
    2b22:	58 9a       	sbi	0x0b, 0	; 11
}
    2b24:	08 95       	ret

00002b26 <clrport_init>:
*
*/

void clrport_init(void)
{
	color_sensor_pin_config();//color sensor pin configuration
    2b26:	0e 94 8e 15 	call	0x2b1c	; 0x2b1c <color_sensor_pin_config>
}
    2b2a:	08 95       	ret

00002b2c <color_sensor_pin_interrupt_init>:
*
*/

void color_sensor_pin_interrupt_init(void) //Interrupt 0 enable
{
	cli(); //Clears the global interrupt
    2b2c:	f8 94       	cli
	EICRA = EICRA | 0x02; // INT0 is set to trigger with falling edge
    2b2e:	e9 e6       	ldi	r30, 0x69	; 105
    2b30:	f0 e0       	ldi	r31, 0x00	; 0
    2b32:	80 81       	ld	r24, Z
    2b34:	82 60       	ori	r24, 0x02	; 2
    2b36:	80 83       	st	Z, r24
	EIMSK = EIMSK | 0x01; // Enable Interrupt INT0 for color sensor
    2b38:	e8 9a       	sbi	0x1d, 0	; 29
	sei(); // Enables the global interrupt
    2b3a:	78 94       	sei
}
    2b3c:	08 95       	ret

00002b3e <__vector_1>:
*
*/

//ISR for color sensor
ISR(INT0_vect)
{
    2b3e:	1f 92       	push	r1
    2b40:	0f 92       	push	r0
    2b42:	0f b6       	in	r0, 0x3f	; 63
    2b44:	0f 92       	push	r0
    2b46:	11 24       	eor	r1, r1
    2b48:	8f 93       	push	r24
    2b4a:	9f 93       	push	r25
    2b4c:	af 93       	push	r26
    2b4e:	bf 93       	push	r27
	pulse++; //increment on receiving pulse from the color sensor
    2b50:	80 91 4e 02 	lds	r24, 0x024E
    2b54:	90 91 4f 02 	lds	r25, 0x024F
    2b58:	a0 91 50 02 	lds	r26, 0x0250
    2b5c:	b0 91 51 02 	lds	r27, 0x0251
    2b60:	01 96       	adiw	r24, 0x01	; 1
    2b62:	a1 1d       	adc	r26, r1
    2b64:	b1 1d       	adc	r27, r1
    2b66:	80 93 4e 02 	sts	0x024E, r24
    2b6a:	90 93 4f 02 	sts	0x024F, r25
    2b6e:	a0 93 50 02 	sts	0x0250, r26
    2b72:	b0 93 51 02 	sts	0x0251, r27
}
    2b76:	bf 91       	pop	r27
    2b78:	af 91       	pop	r26
    2b7a:	9f 91       	pop	r25
    2b7c:	8f 91       	pop	r24
    2b7e:	0f 90       	pop	r0
    2b80:	0f be       	out	0x3f, r0	; 63
    2b82:	0f 90       	pop	r0
    2b84:	1f 90       	pop	r1
    2b86:	18 95       	reti

00002b88 <init_devices>:
*
*/

void init_devices(void)
{
	cli(); //Clears the global interrupt
    2b88:	f8 94       	cli
	clrport_init();  //Initializes all the ports
    2b8a:	0e 94 93 15 	call	0x2b26	; 0x2b26 <clrport_init>
	color_sensor_pin_interrupt_init();
    2b8e:	0e 94 96 15 	call	0x2b2c	; 0x2b2c <color_sensor_pin_interrupt_init>
	sei();   // Enables the global interrupt
    2b92:	78 94       	sei
}
    2b94:	08 95       	ret

00002b96 <filter_red>:

//Filter Selection
void filter_red(void)    //Used to select red filter
{
	//Filter Select - red filter
	PORTD = PORTD & 0xBF; //set S2 low
    2b96:	5e 98       	cbi	0x0b, 6	; 11
	PORTD = PORTD & 0x7F; //set S3 low
    2b98:	5f 98       	cbi	0x0b, 7	; 11
}
    2b9a:	08 95       	ret

00002b9c <filter_green>:
*/

void filter_green(void)	//Used to select green filter
{
	//Filter Select - green filter
	PORTD = PORTD | 0x40; //set S2 High
    2b9c:	5e 9a       	sbi	0x0b, 6	; 11
	PORTD = PORTD | 0x80; //set S3 High
    2b9e:	5f 9a       	sbi	0x0b, 7	; 11
}
    2ba0:	08 95       	ret

00002ba2 <filter_blue>:
*/

void filter_blue(void)	//Used to select blue filter
{
	//Filter Select - blue filter
	PORTD = PORTD & 0xBF; //set S2 low
    2ba2:	5e 98       	cbi	0x0b, 6	; 11
	PORTD = PORTD | 0x80; //set S3 High
    2ba4:	5f 9a       	sbi	0x0b, 7	; 11
}
    2ba6:	08 95       	ret

00002ba8 <color_sensor_scaling>:
//Color Sensing Scaling
void color_sensor_scaling()		//This function is used to select the scaled down version of the original frequency of the output generated by the color sensor, generally 20% scaling is preferable, though you can change the values as per your application by referring datasheet
{
	//Output Scaling 20% from data sheet
	//PORTD = PORTD & 0xEF;
	PORTD = PORTD | 0x10; //set S0 high
    2ba8:	5c 9a       	sbi	0x0b, 4	; 11
	//PORTD = PORTD & 0xDF; //set S1 low
	PORTD = PORTD | 0x20; //set S1 high
    2baa:	5d 9a       	sbi	0x0b, 5	; 11
}
    2bac:	08 95       	ret

00002bae <red_read>:
*/

void red_read(void) // function to select red filter and display the count generated by the sensor on LCD. The count will be more if the color is red. The count will be very less if its blue or green.
{
	//Red
	filter_red(); //select red filter
    2bae:	0e 94 cb 15 	call	0x2b96	; 0x2b96 <filter_red>
	pulse=0; //reset the count to 0
    2bb2:	10 92 4e 02 	sts	0x024E, r1
    2bb6:	10 92 4f 02 	sts	0x024F, r1
    2bba:	10 92 50 02 	sts	0x0250, r1
    2bbe:	10 92 51 02 	sts	0x0251, r1
    2bc2:	8f ef       	ldi	r24, 0xFF	; 255
    2bc4:	9f e7       	ldi	r25, 0x7F	; 127
    2bc6:	a4 e0       	ldi	r26, 0x04	; 4
    2bc8:	81 50       	subi	r24, 0x01	; 1
    2bca:	90 40       	sbci	r25, 0x00	; 0
    2bcc:	a0 40       	sbci	r26, 0x00	; 0
    2bce:	e1 f7       	brne	.-8      	; 0x2bc8 <red_read+0x1a>
    2bd0:	00 c0       	rjmp	.+0      	; 0x2bd2 <red_read+0x24>
    2bd2:	00 00       	nop
	_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	red = pulse;  //store the count in variable called red
    2bd4:	80 91 4e 02 	lds	r24, 0x024E
    2bd8:	90 91 4f 02 	lds	r25, 0x024F
    2bdc:	a0 91 50 02 	lds	r26, 0x0250
    2be0:	b0 91 51 02 	lds	r27, 0x0251
    2be4:	80 93 b7 02 	sts	0x02B7, r24
    2be8:	90 93 b8 02 	sts	0x02B8, r25
    2bec:	a0 93 b9 02 	sts	0x02B9, r26
    2bf0:	b0 93 ba 02 	sts	0x02BA, r27
}
    2bf4:	08 95       	ret

00002bf6 <green_read>:
*/

void green_read(void) // function to select green filter and display the count generated by the sensor on LCD. The count will be more if the color is green. The count will be very less if its blue or red.
{
	//Green
	filter_green(); //select green filter
    2bf6:	0e 94 ce 15 	call	0x2b9c	; 0x2b9c <filter_green>
	pulse=0; //reset the count to 0
    2bfa:	10 92 4e 02 	sts	0x024E, r1
    2bfe:	10 92 4f 02 	sts	0x024F, r1
    2c02:	10 92 50 02 	sts	0x0250, r1
    2c06:	10 92 51 02 	sts	0x0251, r1
    2c0a:	8f ef       	ldi	r24, 0xFF	; 255
    2c0c:	9f e7       	ldi	r25, 0x7F	; 127
    2c0e:	a4 e0       	ldi	r26, 0x04	; 4
    2c10:	81 50       	subi	r24, 0x01	; 1
    2c12:	90 40       	sbci	r25, 0x00	; 0
    2c14:	a0 40       	sbci	r26, 0x00	; 0
    2c16:	e1 f7       	brne	.-8      	; 0x2c10 <green_read+0x1a>
    2c18:	00 c0       	rjmp	.+0      	; 0x2c1a <green_read+0x24>
    2c1a:	00 00       	nop
	_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	green = pulse;  //store the count in variable called green
    2c1c:	80 91 4e 02 	lds	r24, 0x024E
    2c20:	90 91 4f 02 	lds	r25, 0x024F
    2c24:	a0 91 50 02 	lds	r26, 0x0250
    2c28:	b0 91 51 02 	lds	r27, 0x0251
    2c2c:	80 93 b2 02 	sts	0x02B2, r24
    2c30:	90 93 b3 02 	sts	0x02B3, r25
    2c34:	a0 93 b4 02 	sts	0x02B4, r26
    2c38:	b0 93 b5 02 	sts	0x02B5, r27
}
    2c3c:	08 95       	ret

00002c3e <blue_read>:
*/

void blue_read(void) // function to select blue filter and display the count generated by the sensor on LCD. The count will be more if the color is blue. The count will be very less if its red or green.
{
	//Blue
	filter_blue(); //select blue filter
    2c3e:	0e 94 d1 15 	call	0x2ba2	; 0x2ba2 <filter_blue>
	pulse=0; //reset the count to 0
    2c42:	10 92 4e 02 	sts	0x024E, r1
    2c46:	10 92 4f 02 	sts	0x024F, r1
    2c4a:	10 92 50 02 	sts	0x0250, r1
    2c4e:	10 92 51 02 	sts	0x0251, r1
    2c52:	8f ef       	ldi	r24, 0xFF	; 255
    2c54:	9f e7       	ldi	r25, 0x7F	; 127
    2c56:	a4 e0       	ldi	r26, 0x04	; 4
    2c58:	81 50       	subi	r24, 0x01	; 1
    2c5a:	90 40       	sbci	r25, 0x00	; 0
    2c5c:	a0 40       	sbci	r26, 0x00	; 0
    2c5e:	e1 f7       	brne	.-8      	; 0x2c58 <blue_read+0x1a>
    2c60:	00 c0       	rjmp	.+0      	; 0x2c62 <blue_read+0x24>
    2c62:	00 00       	nop
	_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	blue = pulse;  //store the count in variable called blue
    2c64:	80 91 4e 02 	lds	r24, 0x024E
    2c68:	90 91 4f 02 	lds	r25, 0x024F
    2c6c:	a0 91 50 02 	lds	r26, 0x0250
    2c70:	b0 91 51 02 	lds	r27, 0x0251
    2c74:	80 93 a6 02 	sts	0x02A6, r24
    2c78:	90 93 a7 02 	sts	0x02A7, r25
    2c7c:	a0 93 a8 02 	sts	0x02A8, r26
    2c80:	b0 93 a9 02 	sts	0x02A9, r27

}
    2c84:	08 95       	ret

00002c86 <color_sensor>:
*
*/

void color_sensor(void)
{
	red_read();
    2c86:	0e 94 d7 15 	call	0x2bae	; 0x2bae <red_read>
	blue_read();
    2c8a:	0e 94 1f 16 	call	0x2c3e	; 0x2c3e <blue_read>
	green_read();
    2c8e:	0e 94 fb 15 	call	0x2bf6	; 0x2bf6 <green_read>
	if(red<threshold_color_value && blue<threshold_color_value && green<threshold_color_value)
    2c92:	80 91 b7 02 	lds	r24, 0x02B7
    2c96:	90 91 b8 02 	lds	r25, 0x02B8
    2c9a:	a0 91 b9 02 	lds	r26, 0x02B9
    2c9e:	b0 91 ba 02 	lds	r27, 0x02BA
    2ca2:	84 31       	cpi	r24, 0x14	; 20
    2ca4:	25 e0       	ldi	r18, 0x05	; 5
    2ca6:	92 07       	cpc	r25, r18
    2ca8:	20 e0       	ldi	r18, 0x00	; 0
    2caa:	a2 07       	cpc	r26, r18
    2cac:	20 e0       	ldi	r18, 0x00	; 0
    2cae:	b2 07       	cpc	r27, r18
    2cb0:	18 f5       	brcc	.+70     	; 0x2cf8 <color_sensor+0x72>
    2cb2:	80 91 a6 02 	lds	r24, 0x02A6
    2cb6:	90 91 a7 02 	lds	r25, 0x02A7
    2cba:	a0 91 a8 02 	lds	r26, 0x02A8
    2cbe:	b0 91 a9 02 	lds	r27, 0x02A9
    2cc2:	84 31       	cpi	r24, 0x14	; 20
    2cc4:	25 e0       	ldi	r18, 0x05	; 5
    2cc6:	92 07       	cpc	r25, r18
    2cc8:	20 e0       	ldi	r18, 0x00	; 0
    2cca:	a2 07       	cpc	r26, r18
    2ccc:	20 e0       	ldi	r18, 0x00	; 0
    2cce:	b2 07       	cpc	r27, r18
    2cd0:	98 f4       	brcc	.+38     	; 0x2cf8 <color_sensor+0x72>
    2cd2:	80 91 b2 02 	lds	r24, 0x02B2
    2cd6:	90 91 b3 02 	lds	r25, 0x02B3
    2cda:	a0 91 b4 02 	lds	r26, 0x02B4
    2cde:	b0 91 b5 02 	lds	r27, 0x02B5
    2ce2:	84 31       	cpi	r24, 0x14	; 20
    2ce4:	25 e0       	ldi	r18, 0x05	; 5
    2ce6:	92 07       	cpc	r25, r18
    2ce8:	20 e0       	ldi	r18, 0x00	; 0
    2cea:	a2 07       	cpc	r26, r18
    2cec:	20 e0       	ldi	r18, 0x00	; 0
    2cee:	b2 07       	cpc	r27, r18
    2cf0:	18 f4       	brcc	.+6      	; 0x2cf8 <color_sensor+0x72>
	color_identified='\0';
    2cf2:	10 92 54 02 	sts	0x0254, r1
    2cf6:	89 c0       	rjmp	.+274    	; 0x2e0a <color_sensor+0x184>
	else
	{
		if(red>blue && red>green)
    2cf8:	40 91 b7 02 	lds	r20, 0x02B7
    2cfc:	50 91 b8 02 	lds	r21, 0x02B8
    2d00:	60 91 b9 02 	lds	r22, 0x02B9
    2d04:	70 91 ba 02 	lds	r23, 0x02BA
    2d08:	80 91 a6 02 	lds	r24, 0x02A6
    2d0c:	90 91 a7 02 	lds	r25, 0x02A7
    2d10:	a0 91 a8 02 	lds	r26, 0x02A8
    2d14:	b0 91 a9 02 	lds	r27, 0x02A9
    2d18:	84 17       	cp	r24, r20
    2d1a:	95 07       	cpc	r25, r21
    2d1c:	a6 07       	cpc	r26, r22
    2d1e:	b7 07       	cpc	r27, r23
    2d20:	c8 f4       	brcc	.+50     	; 0x2d54 <color_sensor+0xce>
    2d22:	40 91 b7 02 	lds	r20, 0x02B7
    2d26:	50 91 b8 02 	lds	r21, 0x02B8
    2d2a:	60 91 b9 02 	lds	r22, 0x02B9
    2d2e:	70 91 ba 02 	lds	r23, 0x02BA
    2d32:	80 91 b2 02 	lds	r24, 0x02B2
    2d36:	90 91 b3 02 	lds	r25, 0x02B3
    2d3a:	a0 91 b4 02 	lds	r26, 0x02B4
    2d3e:	b0 91 b5 02 	lds	r27, 0x02B5
    2d42:	84 17       	cp	r24, r20
    2d44:	95 07       	cpc	r25, r21
    2d46:	a6 07       	cpc	r26, r22
    2d48:	b7 07       	cpc	r27, r23
    2d4a:	20 f4       	brcc	.+8      	; 0x2d54 <color_sensor+0xce>
		color_identified='R';
    2d4c:	82 e5       	ldi	r24, 0x52	; 82
    2d4e:	80 93 54 02 	sts	0x0254, r24
    2d52:	5b c0       	rjmp	.+182    	; 0x2e0a <color_sensor+0x184>
		else if(blue>red && blue>green)
    2d54:	40 91 a6 02 	lds	r20, 0x02A6
    2d58:	50 91 a7 02 	lds	r21, 0x02A7
    2d5c:	60 91 a8 02 	lds	r22, 0x02A8
    2d60:	70 91 a9 02 	lds	r23, 0x02A9
    2d64:	80 91 b7 02 	lds	r24, 0x02B7
    2d68:	90 91 b8 02 	lds	r25, 0x02B8
    2d6c:	a0 91 b9 02 	lds	r26, 0x02B9
    2d70:	b0 91 ba 02 	lds	r27, 0x02BA
    2d74:	84 17       	cp	r24, r20
    2d76:	95 07       	cpc	r25, r21
    2d78:	a6 07       	cpc	r26, r22
    2d7a:	b7 07       	cpc	r27, r23
    2d7c:	c8 f4       	brcc	.+50     	; 0x2db0 <color_sensor+0x12a>
    2d7e:	40 91 a6 02 	lds	r20, 0x02A6
    2d82:	50 91 a7 02 	lds	r21, 0x02A7
    2d86:	60 91 a8 02 	lds	r22, 0x02A8
    2d8a:	70 91 a9 02 	lds	r23, 0x02A9
    2d8e:	80 91 b2 02 	lds	r24, 0x02B2
    2d92:	90 91 b3 02 	lds	r25, 0x02B3
    2d96:	a0 91 b4 02 	lds	r26, 0x02B4
    2d9a:	b0 91 b5 02 	lds	r27, 0x02B5
    2d9e:	84 17       	cp	r24, r20
    2da0:	95 07       	cpc	r25, r21
    2da2:	a6 07       	cpc	r26, r22
    2da4:	b7 07       	cpc	r27, r23
    2da6:	20 f4       	brcc	.+8      	; 0x2db0 <color_sensor+0x12a>
		color_identified='B';
    2da8:	82 e4       	ldi	r24, 0x42	; 66
    2daa:	80 93 54 02 	sts	0x0254, r24
    2dae:	2d c0       	rjmp	.+90     	; 0x2e0a <color_sensor+0x184>
		else if(green>red && green>blue)
    2db0:	40 91 b2 02 	lds	r20, 0x02B2
    2db4:	50 91 b3 02 	lds	r21, 0x02B3
    2db8:	60 91 b4 02 	lds	r22, 0x02B4
    2dbc:	70 91 b5 02 	lds	r23, 0x02B5
    2dc0:	80 91 b7 02 	lds	r24, 0x02B7
    2dc4:	90 91 b8 02 	lds	r25, 0x02B8
    2dc8:	a0 91 b9 02 	lds	r26, 0x02B9
    2dcc:	b0 91 ba 02 	lds	r27, 0x02BA
    2dd0:	84 17       	cp	r24, r20
    2dd2:	95 07       	cpc	r25, r21
    2dd4:	a6 07       	cpc	r26, r22
    2dd6:	b7 07       	cpc	r27, r23
    2dd8:	c0 f4       	brcc	.+48     	; 0x2e0a <color_sensor+0x184>
    2dda:	40 91 b2 02 	lds	r20, 0x02B2
    2dde:	50 91 b3 02 	lds	r21, 0x02B3
    2de2:	60 91 b4 02 	lds	r22, 0x02B4
    2de6:	70 91 b5 02 	lds	r23, 0x02B5
    2dea:	80 91 a6 02 	lds	r24, 0x02A6
    2dee:	90 91 a7 02 	lds	r25, 0x02A7
    2df2:	a0 91 a8 02 	lds	r26, 0x02A8
    2df6:	b0 91 a9 02 	lds	r27, 0x02A9
    2dfa:	84 17       	cp	r24, r20
    2dfc:	95 07       	cpc	r25, r21
    2dfe:	a6 07       	cpc	r26, r22
    2e00:	b7 07       	cpc	r27, r23
    2e02:	18 f4       	brcc	.+6      	; 0x2e0a <color_sensor+0x184>
		color_identified='G';
    2e04:	87 e4       	ldi	r24, 0x47	; 71
    2e06:	80 93 54 02 	sts	0x0254, r24
	}
	lcd_cursor(2,10);
    2e0a:	82 e0       	ldi	r24, 0x02	; 2
    2e0c:	6a e0       	ldi	r22, 0x0A	; 10
    2e0e:	0e 94 a8 03 	call	0x750	; 0x750 <lcd_cursor>
	lcd_wr_char(color_identified);
    2e12:	80 91 54 02 	lds	r24, 0x0254
    2e16:	0e 94 70 03 	call	0x6e0	; 0x6e0 <lcd_wr_char>
}
    2e1a:	08 95       	ret

00002e1c <main>:
*
*/

int main(void)
{
	struct_config();
    2e1c:	0e 94 02 05 	call	0xa04	; 0xa04 <struct_config>
	lcd_port_config();
    2e20:	0e 94 42 07 	call	0xe84	; 0xe84 <lcd_port_config>
	lcd_init();
    2e24:	0e 94 59 03 	call	0x6b2	; 0x6b2 <lcd_init>
	INT_position();
    2e28:	0e 94 95 09 	call	0x132a	; 0x132a <INT_position>
	sppeed_config();
    2e2c:	0e 94 64 07 	call	0xec8	; 0xec8 <sppeed_config>
	servo_config();
    2e30:	0e 94 a4 09 	call	0x1348	; 0x1348 <servo_config>
	ADC_config();
    2e34:	0e 94 56 0a 	call	0x14ac	; 0x14ac <ADC_config>
	init_devices();
    2e38:	0e 94 c4 15 	call	0x2b88	; 0x2b88 <init_devices>
	_init_devices();//for state collection
    2e3c:	0e 94 e3 02 	call	0x5c6	; 0x5c6 <_init_devices>
	color_sensor_scaling();
    2e40:	0e 94 d4 15 	call	0x2ba8	; 0x2ba8 <color_sensor_scaling>
	navigate();			//navigate the bot at starting
    2e44:	0e 94 55 04 	call	0x8aa	; 0x8aa <navigate>
	servo1_mov(80);		//move arm to its initial position
    2e48:	80 e5       	ldi	r24, 0x50	; 80
    2e4a:	90 e0       	ldi	r25, 0x00	; 0
    2e4c:	0e 94 c9 09 	call	0x1392	; 0x1392 <servo1_mov>
    2e50:	8f ef       	ldi	r24, 0xFF	; 255
    2e52:	9f e7       	ldi	r25, 0x7F	; 127
    2e54:	a6 e1       	ldi	r26, 0x16	; 22
    2e56:	81 50       	subi	r24, 0x01	; 1
    2e58:	90 40       	sbci	r25, 0x00	; 0
    2e5a:	a0 40       	sbci	r26, 0x00	; 0
    2e5c:	e1 f7       	brne	.-8      	; 0x2e56 <main+0x3a>
    2e5e:	00 c0       	rjmp	.+0      	; 0x2e60 <main+0x44>
    2e60:	00 00       	nop
	_delay_ms(500);
	servo2_mov(45);
    2e62:	8d e2       	ldi	r24, 0x2D	; 45
    2e64:	90 e0       	ldi	r25, 0x00	; 0
    2e66:	0e 94 13 0a 	call	0x1426	; 0x1426 <servo2_mov>
    2e6a:	8f ef       	ldi	r24, 0xFF	; 255
    2e6c:	9f e7       	ldi	r25, 0x7F	; 127
    2e6e:	a6 e1       	ldi	r26, 0x16	; 22
    2e70:	81 50       	subi	r24, 0x01	; 1
    2e72:	90 40       	sbci	r25, 0x00	; 0
    2e74:	a0 40       	sbci	r26, 0x00	; 0
    2e76:	e1 f7       	brne	.-8      	; 0x2e70 <main+0x54>
    2e78:	00 c0       	rjmp	.+0      	; 0x2e7a <main+0x5e>
    2e7a:	00 00       	nop
	_delay_ms(500);
	servo2_free();
    2e7c:	0e 94 41 0a 	call	0x1482	; 0x1482 <servo2_free>
	enqueue(6);     // main 6 tasks of the bot
    2e80:	86 e0       	ldi	r24, 0x06	; 6
    2e82:	90 e0       	ldi	r25, 0x00	; 0
    2e84:	0e 94 02 01 	call	0x204	; 0x204 <enqueue>
	enqueue(0);
    2e88:	80 e0       	ldi	r24, 0x00	; 0
    2e8a:	90 e0       	ldi	r25, 0x00	; 0
    2e8c:	0e 94 02 01 	call	0x204	; 0x204 <enqueue>
	enqueue(6);
    2e90:	86 e0       	ldi	r24, 0x06	; 6
    2e92:	90 e0       	ldi	r25, 0x00	; 0
    2e94:	0e 94 02 01 	call	0x204	; 0x204 <enqueue>
	enqueue(0);
    2e98:	80 e0       	ldi	r24, 0x00	; 0
    2e9a:	90 e0       	ldi	r25, 0x00	; 0
    2e9c:	0e 94 02 01 	call	0x204	; 0x204 <enqueue>
	enqueue(6);
    2ea0:	86 e0       	ldi	r24, 0x06	; 6
    2ea2:	90 e0       	ldi	r25, 0x00	; 0
    2ea4:	0e 94 02 01 	call	0x204	; 0x204 <enqueue>
	_init_devices();/********************initialization of state collection program***************/
    2ea8:	0e 94 e3 02 	call	0x5c6	; 0x5c6 <_init_devices>
	while(1)				// Bot is instructed to follow line continuously 
	{
		line_following();
    2eac:	0e 94 22 15 	call	0x2a44	; 0x2a44 <line_following>
		if(deposition_zone_A+deposition_zone_B+deposition_zone_C==0)		// When all the three wastes are deposited at the deposition zone the bot																	  
    2eb0:	80 91 3b 02 	lds	r24, 0x023B
    2eb4:	90 91 3c 02 	lds	r25, 0x023C
    2eb8:	20 91 39 02 	lds	r18, 0x0239
    2ebc:	30 91 3a 02 	lds	r19, 0x023A
    2ec0:	82 0f       	add	r24, r18
    2ec2:	93 1f       	adc	r25, r19
    2ec4:	20 91 37 02 	lds	r18, 0x0237
    2ec8:	30 91 38 02 	lds	r19, 0x0238
    2ecc:	82 0f       	add	r24, r18
    2ece:	93 1f       	adc	r25, r19
    2ed0:	00 97       	sbiw	r24, 0x00	; 0
    2ed2:	61 f7       	brne	.-40     	; 0x2eac <main+0x90>
		{																	// will beep the buzzer for 5 sec and then exits from the program.
			buzzer(1);
    2ed4:	81 e0       	ldi	r24, 0x01	; 1
    2ed6:	90 e0       	ldi	r25, 0x00	; 0
    2ed8:	0e 94 37 07 	call	0xe6e	; 0xe6e <buzzer>
    2edc:	8f ef       	ldi	r24, 0xFF	; 255
    2ede:	9f ef       	ldi	r25, 0xFF	; 255
    2ee0:	a0 ee       	ldi	r26, 0xE0	; 224
    2ee2:	81 50       	subi	r24, 0x01	; 1
    2ee4:	90 40       	sbci	r25, 0x00	; 0
    2ee6:	a0 40       	sbci	r26, 0x00	; 0
    2ee8:	e1 f7       	brne	.-8      	; 0x2ee2 <main+0xc6>
    2eea:	00 c0       	rjmp	.+0      	; 0x2eec <main+0xd0>
    2eec:	00 00       	nop
			_delay_ms(5000);
			buzzer(0);
    2eee:	80 e0       	ldi	r24, 0x00	; 0
    2ef0:	90 e0       	ldi	r25, 0x00	; 0
    2ef2:	0e 94 37 07 	call	0xe6e	; 0xe6e <buzzer>
    2ef6:	8f ef       	ldi	r24, 0xFF	; 255
    2ef8:	9f e7       	ldi	r25, 0x7F	; 127
    2efa:	a6 e1       	ldi	r26, 0x16	; 22
    2efc:	81 50       	subi	r24, 0x01	; 1
    2efe:	90 40       	sbci	r25, 0x00	; 0
    2f00:	a0 40       	sbci	r26, 0x00	; 0
    2f02:	e1 f7       	brne	.-8      	; 0x2efc <main+0xe0>
    2f04:	00 c0       	rjmp	.+0      	; 0x2f06 <main+0xea>
    2f06:	00 00       	nop
			_delay_ms(500);
			break;
		}
	}
}
    2f08:	80 e0       	ldi	r24, 0x00	; 0
    2f0a:	90 e0       	ldi	r25, 0x00	; 0
    2f0c:	08 95       	ret

00002f0e <__subsf3>:
    2f0e:	50 58       	subi	r21, 0x80	; 128

00002f10 <__addsf3>:
    2f10:	bb 27       	eor	r27, r27
    2f12:	aa 27       	eor	r26, r26
    2f14:	0e d0       	rcall	.+28     	; 0x2f32 <__addsf3x>
    2f16:	b1 c1       	rjmp	.+866    	; 0x327a <__fp_round>
    2f18:	a2 d1       	rcall	.+836    	; 0x325e <__fp_pscA>
    2f1a:	30 f0       	brcs	.+12     	; 0x2f28 <__addsf3+0x18>
    2f1c:	a7 d1       	rcall	.+846    	; 0x326c <__fp_pscB>
    2f1e:	20 f0       	brcs	.+8      	; 0x2f28 <__addsf3+0x18>
    2f20:	31 f4       	brne	.+12     	; 0x2f2e <__addsf3+0x1e>
    2f22:	9f 3f       	cpi	r25, 0xFF	; 255
    2f24:	11 f4       	brne	.+4      	; 0x2f2a <__addsf3+0x1a>
    2f26:	1e f4       	brtc	.+6      	; 0x2f2e <__addsf3+0x1e>
    2f28:	97 c1       	rjmp	.+814    	; 0x3258 <__fp_nan>
    2f2a:	0e f4       	brtc	.+2      	; 0x2f2e <__addsf3+0x1e>
    2f2c:	e0 95       	com	r30
    2f2e:	e7 fb       	bst	r30, 7
    2f30:	64 c1       	rjmp	.+712    	; 0x31fa <__fp_inf>

00002f32 <__addsf3x>:
    2f32:	e9 2f       	mov	r30, r25
    2f34:	b3 d1       	rcall	.+870    	; 0x329c <__fp_split3>
    2f36:	80 f3       	brcs	.-32     	; 0x2f18 <__addsf3+0x8>
    2f38:	ba 17       	cp	r27, r26
    2f3a:	62 07       	cpc	r22, r18
    2f3c:	73 07       	cpc	r23, r19
    2f3e:	84 07       	cpc	r24, r20
    2f40:	95 07       	cpc	r25, r21
    2f42:	18 f0       	brcs	.+6      	; 0x2f4a <__addsf3x+0x18>
    2f44:	71 f4       	brne	.+28     	; 0x2f62 <__addsf3x+0x30>
    2f46:	9e f5       	brtc	.+102    	; 0x2fae <__addsf3x+0x7c>
    2f48:	e2 c1       	rjmp	.+964    	; 0x330e <__fp_zero>
    2f4a:	0e f4       	brtc	.+2      	; 0x2f4e <__addsf3x+0x1c>
    2f4c:	e0 95       	com	r30
    2f4e:	0b 2e       	mov	r0, r27
    2f50:	ba 2f       	mov	r27, r26
    2f52:	a0 2d       	mov	r26, r0
    2f54:	0b 01       	movw	r0, r22
    2f56:	b9 01       	movw	r22, r18
    2f58:	90 01       	movw	r18, r0
    2f5a:	0c 01       	movw	r0, r24
    2f5c:	ca 01       	movw	r24, r20
    2f5e:	a0 01       	movw	r20, r0
    2f60:	11 24       	eor	r1, r1
    2f62:	ff 27       	eor	r31, r31
    2f64:	59 1b       	sub	r21, r25
    2f66:	99 f0       	breq	.+38     	; 0x2f8e <__addsf3x+0x5c>
    2f68:	59 3f       	cpi	r21, 0xF9	; 249
    2f6a:	50 f4       	brcc	.+20     	; 0x2f80 <__addsf3x+0x4e>
    2f6c:	50 3e       	cpi	r21, 0xE0	; 224
    2f6e:	68 f1       	brcs	.+90     	; 0x2fca <__addsf3x+0x98>
    2f70:	1a 16       	cp	r1, r26
    2f72:	f0 40       	sbci	r31, 0x00	; 0
    2f74:	a2 2f       	mov	r26, r18
    2f76:	23 2f       	mov	r18, r19
    2f78:	34 2f       	mov	r19, r20
    2f7a:	44 27       	eor	r20, r20
    2f7c:	58 5f       	subi	r21, 0xF8	; 248
    2f7e:	f3 cf       	rjmp	.-26     	; 0x2f66 <__addsf3x+0x34>
    2f80:	46 95       	lsr	r20
    2f82:	37 95       	ror	r19
    2f84:	27 95       	ror	r18
    2f86:	a7 95       	ror	r26
    2f88:	f0 40       	sbci	r31, 0x00	; 0
    2f8a:	53 95       	inc	r21
    2f8c:	c9 f7       	brne	.-14     	; 0x2f80 <__addsf3x+0x4e>
    2f8e:	7e f4       	brtc	.+30     	; 0x2fae <__addsf3x+0x7c>
    2f90:	1f 16       	cp	r1, r31
    2f92:	ba 0b       	sbc	r27, r26
    2f94:	62 0b       	sbc	r22, r18
    2f96:	73 0b       	sbc	r23, r19
    2f98:	84 0b       	sbc	r24, r20
    2f9a:	ba f0       	brmi	.+46     	; 0x2fca <__addsf3x+0x98>
    2f9c:	91 50       	subi	r25, 0x01	; 1
    2f9e:	a1 f0       	breq	.+40     	; 0x2fc8 <__addsf3x+0x96>
    2fa0:	ff 0f       	add	r31, r31
    2fa2:	bb 1f       	adc	r27, r27
    2fa4:	66 1f       	adc	r22, r22
    2fa6:	77 1f       	adc	r23, r23
    2fa8:	88 1f       	adc	r24, r24
    2faa:	c2 f7       	brpl	.-16     	; 0x2f9c <__addsf3x+0x6a>
    2fac:	0e c0       	rjmp	.+28     	; 0x2fca <__addsf3x+0x98>
    2fae:	ba 0f       	add	r27, r26
    2fb0:	62 1f       	adc	r22, r18
    2fb2:	73 1f       	adc	r23, r19
    2fb4:	84 1f       	adc	r24, r20
    2fb6:	48 f4       	brcc	.+18     	; 0x2fca <__addsf3x+0x98>
    2fb8:	87 95       	ror	r24
    2fba:	77 95       	ror	r23
    2fbc:	67 95       	ror	r22
    2fbe:	b7 95       	ror	r27
    2fc0:	f7 95       	ror	r31
    2fc2:	9e 3f       	cpi	r25, 0xFE	; 254
    2fc4:	08 f0       	brcs	.+2      	; 0x2fc8 <__addsf3x+0x96>
    2fc6:	b3 cf       	rjmp	.-154    	; 0x2f2e <__addsf3+0x1e>
    2fc8:	93 95       	inc	r25
    2fca:	88 0f       	add	r24, r24
    2fcc:	08 f0       	brcs	.+2      	; 0x2fd0 <__addsf3x+0x9e>
    2fce:	99 27       	eor	r25, r25
    2fd0:	ee 0f       	add	r30, r30
    2fd2:	97 95       	ror	r25
    2fd4:	87 95       	ror	r24
    2fd6:	08 95       	ret

00002fd8 <ceil>:
    2fd8:	83 d1       	rcall	.+774    	; 0x32e0 <__fp_trunc>
    2fda:	80 f0       	brcs	.+32     	; 0x2ffc <ceil+0x24>
    2fdc:	9f 37       	cpi	r25, 0x7F	; 127
    2fde:	40 f4       	brcc	.+16     	; 0x2ff0 <ceil+0x18>
    2fe0:	91 11       	cpse	r25, r1
    2fe2:	0e f4       	brtc	.+2      	; 0x2fe6 <ceil+0xe>
    2fe4:	95 c1       	rjmp	.+810    	; 0x3310 <__fp_szero>
    2fe6:	60 e0       	ldi	r22, 0x00	; 0
    2fe8:	70 e0       	ldi	r23, 0x00	; 0
    2fea:	80 e8       	ldi	r24, 0x80	; 128
    2fec:	9f e3       	ldi	r25, 0x3F	; 63
    2fee:	08 95       	ret
    2ff0:	26 f0       	brts	.+8      	; 0x2ffa <ceil+0x22>
    2ff2:	1b 16       	cp	r1, r27
    2ff4:	61 1d       	adc	r22, r1
    2ff6:	71 1d       	adc	r23, r1
    2ff8:	81 1d       	adc	r24, r1
    2ffa:	05 c1       	rjmp	.+522    	; 0x3206 <__fp_mintl>
    2ffc:	1f c1       	rjmp	.+574    	; 0x323c <__fp_mpack>

00002ffe <__cmpsf2>:
    2ffe:	d9 d0       	rcall	.+434    	; 0x31b2 <__fp_cmp>
    3000:	08 f4       	brcc	.+2      	; 0x3004 <__cmpsf2+0x6>
    3002:	81 e0       	ldi	r24, 0x01	; 1
    3004:	08 95       	ret

00003006 <__divsf3>:
    3006:	0c d0       	rcall	.+24     	; 0x3020 <__divsf3x>
    3008:	38 c1       	rjmp	.+624    	; 0x327a <__fp_round>
    300a:	30 d1       	rcall	.+608    	; 0x326c <__fp_pscB>
    300c:	40 f0       	brcs	.+16     	; 0x301e <__divsf3+0x18>
    300e:	27 d1       	rcall	.+590    	; 0x325e <__fp_pscA>
    3010:	30 f0       	brcs	.+12     	; 0x301e <__divsf3+0x18>
    3012:	21 f4       	brne	.+8      	; 0x301c <__divsf3+0x16>
    3014:	5f 3f       	cpi	r21, 0xFF	; 255
    3016:	19 f0       	breq	.+6      	; 0x301e <__divsf3+0x18>
    3018:	f0 c0       	rjmp	.+480    	; 0x31fa <__fp_inf>
    301a:	51 11       	cpse	r21, r1
    301c:	79 c1       	rjmp	.+754    	; 0x3310 <__fp_szero>
    301e:	1c c1       	rjmp	.+568    	; 0x3258 <__fp_nan>

00003020 <__divsf3x>:
    3020:	3d d1       	rcall	.+634    	; 0x329c <__fp_split3>
    3022:	98 f3       	brcs	.-26     	; 0x300a <__divsf3+0x4>

00003024 <__divsf3_pse>:
    3024:	99 23       	and	r25, r25
    3026:	c9 f3       	breq	.-14     	; 0x301a <__divsf3+0x14>
    3028:	55 23       	and	r21, r21
    302a:	b1 f3       	breq	.-20     	; 0x3018 <__divsf3+0x12>
    302c:	95 1b       	sub	r25, r21
    302e:	55 0b       	sbc	r21, r21
    3030:	bb 27       	eor	r27, r27
    3032:	aa 27       	eor	r26, r26
    3034:	62 17       	cp	r22, r18
    3036:	73 07       	cpc	r23, r19
    3038:	84 07       	cpc	r24, r20
    303a:	38 f0       	brcs	.+14     	; 0x304a <__divsf3_pse+0x26>
    303c:	9f 5f       	subi	r25, 0xFF	; 255
    303e:	5f 4f       	sbci	r21, 0xFF	; 255
    3040:	22 0f       	add	r18, r18
    3042:	33 1f       	adc	r19, r19
    3044:	44 1f       	adc	r20, r20
    3046:	aa 1f       	adc	r26, r26
    3048:	a9 f3       	breq	.-22     	; 0x3034 <__divsf3_pse+0x10>
    304a:	33 d0       	rcall	.+102    	; 0x30b2 <__divsf3_pse+0x8e>
    304c:	0e 2e       	mov	r0, r30
    304e:	3a f0       	brmi	.+14     	; 0x305e <__divsf3_pse+0x3a>
    3050:	e0 e8       	ldi	r30, 0x80	; 128
    3052:	30 d0       	rcall	.+96     	; 0x30b4 <__divsf3_pse+0x90>
    3054:	91 50       	subi	r25, 0x01	; 1
    3056:	50 40       	sbci	r21, 0x00	; 0
    3058:	e6 95       	lsr	r30
    305a:	00 1c       	adc	r0, r0
    305c:	ca f7       	brpl	.-14     	; 0x3050 <__divsf3_pse+0x2c>
    305e:	29 d0       	rcall	.+82     	; 0x30b2 <__divsf3_pse+0x8e>
    3060:	fe 2f       	mov	r31, r30
    3062:	27 d0       	rcall	.+78     	; 0x30b2 <__divsf3_pse+0x8e>
    3064:	66 0f       	add	r22, r22
    3066:	77 1f       	adc	r23, r23
    3068:	88 1f       	adc	r24, r24
    306a:	bb 1f       	adc	r27, r27
    306c:	26 17       	cp	r18, r22
    306e:	37 07       	cpc	r19, r23
    3070:	48 07       	cpc	r20, r24
    3072:	ab 07       	cpc	r26, r27
    3074:	b0 e8       	ldi	r27, 0x80	; 128
    3076:	09 f0       	breq	.+2      	; 0x307a <__divsf3_pse+0x56>
    3078:	bb 0b       	sbc	r27, r27
    307a:	80 2d       	mov	r24, r0
    307c:	bf 01       	movw	r22, r30
    307e:	ff 27       	eor	r31, r31
    3080:	93 58       	subi	r25, 0x83	; 131
    3082:	5f 4f       	sbci	r21, 0xFF	; 255
    3084:	2a f0       	brmi	.+10     	; 0x3090 <__divsf3_pse+0x6c>
    3086:	9e 3f       	cpi	r25, 0xFE	; 254
    3088:	51 05       	cpc	r21, r1
    308a:	68 f0       	brcs	.+26     	; 0x30a6 <__divsf3_pse+0x82>
    308c:	b6 c0       	rjmp	.+364    	; 0x31fa <__fp_inf>
    308e:	40 c1       	rjmp	.+640    	; 0x3310 <__fp_szero>
    3090:	5f 3f       	cpi	r21, 0xFF	; 255
    3092:	ec f3       	brlt	.-6      	; 0x308e <__divsf3_pse+0x6a>
    3094:	98 3e       	cpi	r25, 0xE8	; 232
    3096:	dc f3       	brlt	.-10     	; 0x308e <__divsf3_pse+0x6a>
    3098:	86 95       	lsr	r24
    309a:	77 95       	ror	r23
    309c:	67 95       	ror	r22
    309e:	b7 95       	ror	r27
    30a0:	f7 95       	ror	r31
    30a2:	9f 5f       	subi	r25, 0xFF	; 255
    30a4:	c9 f7       	brne	.-14     	; 0x3098 <__divsf3_pse+0x74>
    30a6:	88 0f       	add	r24, r24
    30a8:	91 1d       	adc	r25, r1
    30aa:	96 95       	lsr	r25
    30ac:	87 95       	ror	r24
    30ae:	97 f9       	bld	r25, 7
    30b0:	08 95       	ret
    30b2:	e1 e0       	ldi	r30, 0x01	; 1
    30b4:	66 0f       	add	r22, r22
    30b6:	77 1f       	adc	r23, r23
    30b8:	88 1f       	adc	r24, r24
    30ba:	bb 1f       	adc	r27, r27
    30bc:	62 17       	cp	r22, r18
    30be:	73 07       	cpc	r23, r19
    30c0:	84 07       	cpc	r24, r20
    30c2:	ba 07       	cpc	r27, r26
    30c4:	20 f0       	brcs	.+8      	; 0x30ce <__divsf3_pse+0xaa>
    30c6:	62 1b       	sub	r22, r18
    30c8:	73 0b       	sbc	r23, r19
    30ca:	84 0b       	sbc	r24, r20
    30cc:	ba 0b       	sbc	r27, r26
    30ce:	ee 1f       	adc	r30, r30
    30d0:	88 f7       	brcc	.-30     	; 0x30b4 <__divsf3_pse+0x90>
    30d2:	e0 95       	com	r30
    30d4:	08 95       	ret

000030d6 <__fixsfsi>:
    30d6:	04 d0       	rcall	.+8      	; 0x30e0 <__fixunssfsi>
    30d8:	68 94       	set
    30da:	b1 11       	cpse	r27, r1
    30dc:	19 c1       	rjmp	.+562    	; 0x3310 <__fp_szero>
    30de:	08 95       	ret

000030e0 <__fixunssfsi>:
    30e0:	e5 d0       	rcall	.+458    	; 0x32ac <__fp_splitA>
    30e2:	88 f0       	brcs	.+34     	; 0x3106 <__fixunssfsi+0x26>
    30e4:	9f 57       	subi	r25, 0x7F	; 127
    30e6:	90 f0       	brcs	.+36     	; 0x310c <__fixunssfsi+0x2c>
    30e8:	b9 2f       	mov	r27, r25
    30ea:	99 27       	eor	r25, r25
    30ec:	b7 51       	subi	r27, 0x17	; 23
    30ee:	a0 f0       	brcs	.+40     	; 0x3118 <__fixunssfsi+0x38>
    30f0:	d1 f0       	breq	.+52     	; 0x3126 <__fixunssfsi+0x46>
    30f2:	66 0f       	add	r22, r22
    30f4:	77 1f       	adc	r23, r23
    30f6:	88 1f       	adc	r24, r24
    30f8:	99 1f       	adc	r25, r25
    30fa:	1a f0       	brmi	.+6      	; 0x3102 <__fixunssfsi+0x22>
    30fc:	ba 95       	dec	r27
    30fe:	c9 f7       	brne	.-14     	; 0x30f2 <__fixunssfsi+0x12>
    3100:	12 c0       	rjmp	.+36     	; 0x3126 <__fixunssfsi+0x46>
    3102:	b1 30       	cpi	r27, 0x01	; 1
    3104:	81 f0       	breq	.+32     	; 0x3126 <__fixunssfsi+0x46>
    3106:	03 d1       	rcall	.+518    	; 0x330e <__fp_zero>
    3108:	b1 e0       	ldi	r27, 0x01	; 1
    310a:	08 95       	ret
    310c:	00 c1       	rjmp	.+512    	; 0x330e <__fp_zero>
    310e:	67 2f       	mov	r22, r23
    3110:	78 2f       	mov	r23, r24
    3112:	88 27       	eor	r24, r24
    3114:	b8 5f       	subi	r27, 0xF8	; 248
    3116:	39 f0       	breq	.+14     	; 0x3126 <__fixunssfsi+0x46>
    3118:	b9 3f       	cpi	r27, 0xF9	; 249
    311a:	cc f3       	brlt	.-14     	; 0x310e <__fixunssfsi+0x2e>
    311c:	86 95       	lsr	r24
    311e:	77 95       	ror	r23
    3120:	67 95       	ror	r22
    3122:	b3 95       	inc	r27
    3124:	d9 f7       	brne	.-10     	; 0x311c <__fixunssfsi+0x3c>
    3126:	3e f4       	brtc	.+14     	; 0x3136 <__fixunssfsi+0x56>
    3128:	90 95       	com	r25
    312a:	80 95       	com	r24
    312c:	70 95       	com	r23
    312e:	61 95       	neg	r22
    3130:	7f 4f       	sbci	r23, 0xFF	; 255
    3132:	8f 4f       	sbci	r24, 0xFF	; 255
    3134:	9f 4f       	sbci	r25, 0xFF	; 255
    3136:	08 95       	ret

00003138 <__floatunsisf>:
    3138:	e8 94       	clt
    313a:	09 c0       	rjmp	.+18     	; 0x314e <__floatsisf+0x12>

0000313c <__floatsisf>:
    313c:	97 fb       	bst	r25, 7
    313e:	3e f4       	brtc	.+14     	; 0x314e <__floatsisf+0x12>
    3140:	90 95       	com	r25
    3142:	80 95       	com	r24
    3144:	70 95       	com	r23
    3146:	61 95       	neg	r22
    3148:	7f 4f       	sbci	r23, 0xFF	; 255
    314a:	8f 4f       	sbci	r24, 0xFF	; 255
    314c:	9f 4f       	sbci	r25, 0xFF	; 255
    314e:	99 23       	and	r25, r25
    3150:	a9 f0       	breq	.+42     	; 0x317c <__floatsisf+0x40>
    3152:	f9 2f       	mov	r31, r25
    3154:	96 e9       	ldi	r25, 0x96	; 150
    3156:	bb 27       	eor	r27, r27
    3158:	93 95       	inc	r25
    315a:	f6 95       	lsr	r31
    315c:	87 95       	ror	r24
    315e:	77 95       	ror	r23
    3160:	67 95       	ror	r22
    3162:	b7 95       	ror	r27
    3164:	f1 11       	cpse	r31, r1
    3166:	f8 cf       	rjmp	.-16     	; 0x3158 <__floatsisf+0x1c>
    3168:	fa f4       	brpl	.+62     	; 0x31a8 <__floatsisf+0x6c>
    316a:	bb 0f       	add	r27, r27
    316c:	11 f4       	brne	.+4      	; 0x3172 <__floatsisf+0x36>
    316e:	60 ff       	sbrs	r22, 0
    3170:	1b c0       	rjmp	.+54     	; 0x31a8 <__floatsisf+0x6c>
    3172:	6f 5f       	subi	r22, 0xFF	; 255
    3174:	7f 4f       	sbci	r23, 0xFF	; 255
    3176:	8f 4f       	sbci	r24, 0xFF	; 255
    3178:	9f 4f       	sbci	r25, 0xFF	; 255
    317a:	16 c0       	rjmp	.+44     	; 0x31a8 <__floatsisf+0x6c>
    317c:	88 23       	and	r24, r24
    317e:	11 f0       	breq	.+4      	; 0x3184 <__floatsisf+0x48>
    3180:	96 e9       	ldi	r25, 0x96	; 150
    3182:	11 c0       	rjmp	.+34     	; 0x31a6 <__floatsisf+0x6a>
    3184:	77 23       	and	r23, r23
    3186:	21 f0       	breq	.+8      	; 0x3190 <__floatsisf+0x54>
    3188:	9e e8       	ldi	r25, 0x8E	; 142
    318a:	87 2f       	mov	r24, r23
    318c:	76 2f       	mov	r23, r22
    318e:	05 c0       	rjmp	.+10     	; 0x319a <__floatsisf+0x5e>
    3190:	66 23       	and	r22, r22
    3192:	71 f0       	breq	.+28     	; 0x31b0 <__floatsisf+0x74>
    3194:	96 e8       	ldi	r25, 0x86	; 134
    3196:	86 2f       	mov	r24, r22
    3198:	70 e0       	ldi	r23, 0x00	; 0
    319a:	60 e0       	ldi	r22, 0x00	; 0
    319c:	2a f0       	brmi	.+10     	; 0x31a8 <__floatsisf+0x6c>
    319e:	9a 95       	dec	r25
    31a0:	66 0f       	add	r22, r22
    31a2:	77 1f       	adc	r23, r23
    31a4:	88 1f       	adc	r24, r24
    31a6:	da f7       	brpl	.-10     	; 0x319e <__floatsisf+0x62>
    31a8:	88 0f       	add	r24, r24
    31aa:	96 95       	lsr	r25
    31ac:	87 95       	ror	r24
    31ae:	97 f9       	bld	r25, 7
    31b0:	08 95       	ret

000031b2 <__fp_cmp>:
    31b2:	99 0f       	add	r25, r25
    31b4:	00 08       	sbc	r0, r0
    31b6:	55 0f       	add	r21, r21
    31b8:	aa 0b       	sbc	r26, r26
    31ba:	e0 e8       	ldi	r30, 0x80	; 128
    31bc:	fe ef       	ldi	r31, 0xFE	; 254
    31be:	16 16       	cp	r1, r22
    31c0:	17 06       	cpc	r1, r23
    31c2:	e8 07       	cpc	r30, r24
    31c4:	f9 07       	cpc	r31, r25
    31c6:	c0 f0       	brcs	.+48     	; 0x31f8 <__fp_cmp+0x46>
    31c8:	12 16       	cp	r1, r18
    31ca:	13 06       	cpc	r1, r19
    31cc:	e4 07       	cpc	r30, r20
    31ce:	f5 07       	cpc	r31, r21
    31d0:	98 f0       	brcs	.+38     	; 0x31f8 <__fp_cmp+0x46>
    31d2:	62 1b       	sub	r22, r18
    31d4:	73 0b       	sbc	r23, r19
    31d6:	84 0b       	sbc	r24, r20
    31d8:	95 0b       	sbc	r25, r21
    31da:	39 f4       	brne	.+14     	; 0x31ea <__fp_cmp+0x38>
    31dc:	0a 26       	eor	r0, r26
    31de:	61 f0       	breq	.+24     	; 0x31f8 <__fp_cmp+0x46>
    31e0:	23 2b       	or	r18, r19
    31e2:	24 2b       	or	r18, r20
    31e4:	25 2b       	or	r18, r21
    31e6:	21 f4       	brne	.+8      	; 0x31f0 <__fp_cmp+0x3e>
    31e8:	08 95       	ret
    31ea:	0a 26       	eor	r0, r26
    31ec:	09 f4       	brne	.+2      	; 0x31f0 <__fp_cmp+0x3e>
    31ee:	a1 40       	sbci	r26, 0x01	; 1
    31f0:	a6 95       	lsr	r26
    31f2:	8f ef       	ldi	r24, 0xFF	; 255
    31f4:	81 1d       	adc	r24, r1
    31f6:	81 1d       	adc	r24, r1
    31f8:	08 95       	ret

000031fa <__fp_inf>:
    31fa:	97 f9       	bld	r25, 7
    31fc:	9f 67       	ori	r25, 0x7F	; 127
    31fe:	80 e8       	ldi	r24, 0x80	; 128
    3200:	70 e0       	ldi	r23, 0x00	; 0
    3202:	60 e0       	ldi	r22, 0x00	; 0
    3204:	08 95       	ret

00003206 <__fp_mintl>:
    3206:	88 23       	and	r24, r24
    3208:	71 f4       	brne	.+28     	; 0x3226 <__fp_mintl+0x20>
    320a:	77 23       	and	r23, r23
    320c:	21 f0       	breq	.+8      	; 0x3216 <__fp_mintl+0x10>
    320e:	98 50       	subi	r25, 0x08	; 8
    3210:	87 2b       	or	r24, r23
    3212:	76 2f       	mov	r23, r22
    3214:	07 c0       	rjmp	.+14     	; 0x3224 <__fp_mintl+0x1e>
    3216:	66 23       	and	r22, r22
    3218:	11 f4       	brne	.+4      	; 0x321e <__fp_mintl+0x18>
    321a:	99 27       	eor	r25, r25
    321c:	0d c0       	rjmp	.+26     	; 0x3238 <__fp_mintl+0x32>
    321e:	90 51       	subi	r25, 0x10	; 16
    3220:	86 2b       	or	r24, r22
    3222:	70 e0       	ldi	r23, 0x00	; 0
    3224:	60 e0       	ldi	r22, 0x00	; 0
    3226:	2a f0       	brmi	.+10     	; 0x3232 <__fp_mintl+0x2c>
    3228:	9a 95       	dec	r25
    322a:	66 0f       	add	r22, r22
    322c:	77 1f       	adc	r23, r23
    322e:	88 1f       	adc	r24, r24
    3230:	da f7       	brpl	.-10     	; 0x3228 <__fp_mintl+0x22>
    3232:	88 0f       	add	r24, r24
    3234:	96 95       	lsr	r25
    3236:	87 95       	ror	r24
    3238:	97 f9       	bld	r25, 7
    323a:	08 95       	ret

0000323c <__fp_mpack>:
    323c:	9f 3f       	cpi	r25, 0xFF	; 255
    323e:	31 f0       	breq	.+12     	; 0x324c <__fp_mpack_finite+0xc>

00003240 <__fp_mpack_finite>:
    3240:	91 50       	subi	r25, 0x01	; 1
    3242:	20 f4       	brcc	.+8      	; 0x324c <__fp_mpack_finite+0xc>
    3244:	87 95       	ror	r24
    3246:	77 95       	ror	r23
    3248:	67 95       	ror	r22
    324a:	b7 95       	ror	r27
    324c:	88 0f       	add	r24, r24
    324e:	91 1d       	adc	r25, r1
    3250:	96 95       	lsr	r25
    3252:	87 95       	ror	r24
    3254:	97 f9       	bld	r25, 7
    3256:	08 95       	ret

00003258 <__fp_nan>:
    3258:	9f ef       	ldi	r25, 0xFF	; 255
    325a:	80 ec       	ldi	r24, 0xC0	; 192
    325c:	08 95       	ret

0000325e <__fp_pscA>:
    325e:	00 24       	eor	r0, r0
    3260:	0a 94       	dec	r0
    3262:	16 16       	cp	r1, r22
    3264:	17 06       	cpc	r1, r23
    3266:	18 06       	cpc	r1, r24
    3268:	09 06       	cpc	r0, r25
    326a:	08 95       	ret

0000326c <__fp_pscB>:
    326c:	00 24       	eor	r0, r0
    326e:	0a 94       	dec	r0
    3270:	12 16       	cp	r1, r18
    3272:	13 06       	cpc	r1, r19
    3274:	14 06       	cpc	r1, r20
    3276:	05 06       	cpc	r0, r21
    3278:	08 95       	ret

0000327a <__fp_round>:
    327a:	09 2e       	mov	r0, r25
    327c:	03 94       	inc	r0
    327e:	00 0c       	add	r0, r0
    3280:	11 f4       	brne	.+4      	; 0x3286 <__fp_round+0xc>
    3282:	88 23       	and	r24, r24
    3284:	52 f0       	brmi	.+20     	; 0x329a <__fp_round+0x20>
    3286:	bb 0f       	add	r27, r27
    3288:	40 f4       	brcc	.+16     	; 0x329a <__fp_round+0x20>
    328a:	bf 2b       	or	r27, r31
    328c:	11 f4       	brne	.+4      	; 0x3292 <__fp_round+0x18>
    328e:	60 ff       	sbrs	r22, 0
    3290:	04 c0       	rjmp	.+8      	; 0x329a <__fp_round+0x20>
    3292:	6f 5f       	subi	r22, 0xFF	; 255
    3294:	7f 4f       	sbci	r23, 0xFF	; 255
    3296:	8f 4f       	sbci	r24, 0xFF	; 255
    3298:	9f 4f       	sbci	r25, 0xFF	; 255
    329a:	08 95       	ret

0000329c <__fp_split3>:
    329c:	57 fd       	sbrc	r21, 7
    329e:	90 58       	subi	r25, 0x80	; 128
    32a0:	44 0f       	add	r20, r20
    32a2:	55 1f       	adc	r21, r21
    32a4:	59 f0       	breq	.+22     	; 0x32bc <__fp_splitA+0x10>
    32a6:	5f 3f       	cpi	r21, 0xFF	; 255
    32a8:	71 f0       	breq	.+28     	; 0x32c6 <__fp_splitA+0x1a>
    32aa:	47 95       	ror	r20

000032ac <__fp_splitA>:
    32ac:	88 0f       	add	r24, r24
    32ae:	97 fb       	bst	r25, 7
    32b0:	99 1f       	adc	r25, r25
    32b2:	61 f0       	breq	.+24     	; 0x32cc <__fp_splitA+0x20>
    32b4:	9f 3f       	cpi	r25, 0xFF	; 255
    32b6:	79 f0       	breq	.+30     	; 0x32d6 <__fp_splitA+0x2a>
    32b8:	87 95       	ror	r24
    32ba:	08 95       	ret
    32bc:	12 16       	cp	r1, r18
    32be:	13 06       	cpc	r1, r19
    32c0:	14 06       	cpc	r1, r20
    32c2:	55 1f       	adc	r21, r21
    32c4:	f2 cf       	rjmp	.-28     	; 0x32aa <__fp_split3+0xe>
    32c6:	46 95       	lsr	r20
    32c8:	f1 df       	rcall	.-30     	; 0x32ac <__fp_splitA>
    32ca:	08 c0       	rjmp	.+16     	; 0x32dc <__fp_splitA+0x30>
    32cc:	16 16       	cp	r1, r22
    32ce:	17 06       	cpc	r1, r23
    32d0:	18 06       	cpc	r1, r24
    32d2:	99 1f       	adc	r25, r25
    32d4:	f1 cf       	rjmp	.-30     	; 0x32b8 <__fp_splitA+0xc>
    32d6:	86 95       	lsr	r24
    32d8:	71 05       	cpc	r23, r1
    32da:	61 05       	cpc	r22, r1
    32dc:	08 94       	sec
    32de:	08 95       	ret

000032e0 <__fp_trunc>:
    32e0:	e5 df       	rcall	.-54     	; 0x32ac <__fp_splitA>
    32e2:	a0 f0       	brcs	.+40     	; 0x330c <__fp_trunc+0x2c>
    32e4:	be e7       	ldi	r27, 0x7E	; 126
    32e6:	b9 17       	cp	r27, r25
    32e8:	88 f4       	brcc	.+34     	; 0x330c <__fp_trunc+0x2c>
    32ea:	bb 27       	eor	r27, r27
    32ec:	9f 38       	cpi	r25, 0x8F	; 143
    32ee:	60 f4       	brcc	.+24     	; 0x3308 <__fp_trunc+0x28>
    32f0:	16 16       	cp	r1, r22
    32f2:	b1 1d       	adc	r27, r1
    32f4:	67 2f       	mov	r22, r23
    32f6:	78 2f       	mov	r23, r24
    32f8:	88 27       	eor	r24, r24
    32fa:	98 5f       	subi	r25, 0xF8	; 248
    32fc:	f7 cf       	rjmp	.-18     	; 0x32ec <__fp_trunc+0xc>
    32fe:	86 95       	lsr	r24
    3300:	77 95       	ror	r23
    3302:	67 95       	ror	r22
    3304:	b1 1d       	adc	r27, r1
    3306:	93 95       	inc	r25
    3308:	96 39       	cpi	r25, 0x96	; 150
    330a:	c8 f3       	brcs	.-14     	; 0x32fe <__fp_trunc+0x1e>
    330c:	08 95       	ret

0000330e <__fp_zero>:
    330e:	e8 94       	clt

00003310 <__fp_szero>:
    3310:	bb 27       	eor	r27, r27
    3312:	66 27       	eor	r22, r22
    3314:	77 27       	eor	r23, r23
    3316:	cb 01       	movw	r24, r22
    3318:	97 f9       	bld	r25, 7
    331a:	08 95       	ret

0000331c <__mulsf3>:
    331c:	0b d0       	rcall	.+22     	; 0x3334 <__mulsf3x>
    331e:	ad cf       	rjmp	.-166    	; 0x327a <__fp_round>
    3320:	9e df       	rcall	.-196    	; 0x325e <__fp_pscA>
    3322:	28 f0       	brcs	.+10     	; 0x332e <__mulsf3+0x12>
    3324:	a3 df       	rcall	.-186    	; 0x326c <__fp_pscB>
    3326:	18 f0       	brcs	.+6      	; 0x332e <__mulsf3+0x12>
    3328:	95 23       	and	r25, r21
    332a:	09 f0       	breq	.+2      	; 0x332e <__mulsf3+0x12>
    332c:	66 cf       	rjmp	.-308    	; 0x31fa <__fp_inf>
    332e:	94 cf       	rjmp	.-216    	; 0x3258 <__fp_nan>
    3330:	11 24       	eor	r1, r1
    3332:	ee cf       	rjmp	.-36     	; 0x3310 <__fp_szero>

00003334 <__mulsf3x>:
    3334:	b3 df       	rcall	.-154    	; 0x329c <__fp_split3>
    3336:	a0 f3       	brcs	.-24     	; 0x3320 <__mulsf3+0x4>

00003338 <__mulsf3_pse>:
    3338:	95 9f       	mul	r25, r21
    333a:	d1 f3       	breq	.-12     	; 0x3330 <__mulsf3+0x14>
    333c:	95 0f       	add	r25, r21
    333e:	50 e0       	ldi	r21, 0x00	; 0
    3340:	55 1f       	adc	r21, r21
    3342:	62 9f       	mul	r22, r18
    3344:	f0 01       	movw	r30, r0
    3346:	72 9f       	mul	r23, r18
    3348:	bb 27       	eor	r27, r27
    334a:	f0 0d       	add	r31, r0
    334c:	b1 1d       	adc	r27, r1
    334e:	63 9f       	mul	r22, r19
    3350:	aa 27       	eor	r26, r26
    3352:	f0 0d       	add	r31, r0
    3354:	b1 1d       	adc	r27, r1
    3356:	aa 1f       	adc	r26, r26
    3358:	64 9f       	mul	r22, r20
    335a:	66 27       	eor	r22, r22
    335c:	b0 0d       	add	r27, r0
    335e:	a1 1d       	adc	r26, r1
    3360:	66 1f       	adc	r22, r22
    3362:	82 9f       	mul	r24, r18
    3364:	22 27       	eor	r18, r18
    3366:	b0 0d       	add	r27, r0
    3368:	a1 1d       	adc	r26, r1
    336a:	62 1f       	adc	r22, r18
    336c:	73 9f       	mul	r23, r19
    336e:	b0 0d       	add	r27, r0
    3370:	a1 1d       	adc	r26, r1
    3372:	62 1f       	adc	r22, r18
    3374:	83 9f       	mul	r24, r19
    3376:	a0 0d       	add	r26, r0
    3378:	61 1d       	adc	r22, r1
    337a:	22 1f       	adc	r18, r18
    337c:	74 9f       	mul	r23, r20
    337e:	33 27       	eor	r19, r19
    3380:	a0 0d       	add	r26, r0
    3382:	61 1d       	adc	r22, r1
    3384:	23 1f       	adc	r18, r19
    3386:	84 9f       	mul	r24, r20
    3388:	60 0d       	add	r22, r0
    338a:	21 1d       	adc	r18, r1
    338c:	82 2f       	mov	r24, r18
    338e:	76 2f       	mov	r23, r22
    3390:	6a 2f       	mov	r22, r26
    3392:	11 24       	eor	r1, r1
    3394:	9f 57       	subi	r25, 0x7F	; 127
    3396:	50 40       	sbci	r21, 0x00	; 0
    3398:	8a f0       	brmi	.+34     	; 0x33bc <__mulsf3_pse+0x84>
    339a:	e1 f0       	breq	.+56     	; 0x33d4 <__mulsf3_pse+0x9c>
    339c:	88 23       	and	r24, r24
    339e:	4a f0       	brmi	.+18     	; 0x33b2 <__mulsf3_pse+0x7a>
    33a0:	ee 0f       	add	r30, r30
    33a2:	ff 1f       	adc	r31, r31
    33a4:	bb 1f       	adc	r27, r27
    33a6:	66 1f       	adc	r22, r22
    33a8:	77 1f       	adc	r23, r23
    33aa:	88 1f       	adc	r24, r24
    33ac:	91 50       	subi	r25, 0x01	; 1
    33ae:	50 40       	sbci	r21, 0x00	; 0
    33b0:	a9 f7       	brne	.-22     	; 0x339c <__mulsf3_pse+0x64>
    33b2:	9e 3f       	cpi	r25, 0xFE	; 254
    33b4:	51 05       	cpc	r21, r1
    33b6:	70 f0       	brcs	.+28     	; 0x33d4 <__mulsf3_pse+0x9c>
    33b8:	20 cf       	rjmp	.-448    	; 0x31fa <__fp_inf>
    33ba:	aa cf       	rjmp	.-172    	; 0x3310 <__fp_szero>
    33bc:	5f 3f       	cpi	r21, 0xFF	; 255
    33be:	ec f3       	brlt	.-6      	; 0x33ba <__mulsf3_pse+0x82>
    33c0:	98 3e       	cpi	r25, 0xE8	; 232
    33c2:	dc f3       	brlt	.-10     	; 0x33ba <__mulsf3_pse+0x82>
    33c4:	86 95       	lsr	r24
    33c6:	77 95       	ror	r23
    33c8:	67 95       	ror	r22
    33ca:	b7 95       	ror	r27
    33cc:	f7 95       	ror	r31
    33ce:	e7 95       	ror	r30
    33d0:	9f 5f       	subi	r25, 0xFF	; 255
    33d2:	c1 f7       	brne	.-16     	; 0x33c4 <__mulsf3_pse+0x8c>
    33d4:	fe 2b       	or	r31, r30
    33d6:	88 0f       	add	r24, r24
    33d8:	91 1d       	adc	r25, r1
    33da:	96 95       	lsr	r25
    33dc:	87 95       	ror	r24
    33de:	97 f9       	bld	r25, 7
    33e0:	08 95       	ret

000033e2 <pow>:
    33e2:	fa 01       	movw	r30, r20
    33e4:	ee 0f       	add	r30, r30
    33e6:	ff 1f       	adc	r31, r31
    33e8:	30 96       	adiw	r30, 0x00	; 0
    33ea:	21 05       	cpc	r18, r1
    33ec:	31 05       	cpc	r19, r1
    33ee:	99 f1       	breq	.+102    	; 0x3456 <pow+0x74>
    33f0:	61 15       	cp	r22, r1
    33f2:	71 05       	cpc	r23, r1
    33f4:	61 f4       	brne	.+24     	; 0x340e <pow+0x2c>
    33f6:	80 38       	cpi	r24, 0x80	; 128
    33f8:	bf e3       	ldi	r27, 0x3F	; 63
    33fa:	9b 07       	cpc	r25, r27
    33fc:	49 f1       	breq	.+82     	; 0x3450 <pow+0x6e>
    33fe:	68 94       	set
    3400:	90 38       	cpi	r25, 0x80	; 128
    3402:	81 05       	cpc	r24, r1
    3404:	61 f0       	breq	.+24     	; 0x341e <pow+0x3c>
    3406:	80 38       	cpi	r24, 0x80	; 128
    3408:	bf ef       	ldi	r27, 0xFF	; 255
    340a:	9b 07       	cpc	r25, r27
    340c:	41 f0       	breq	.+16     	; 0x341e <pow+0x3c>
    340e:	99 23       	and	r25, r25
    3410:	42 f5       	brpl	.+80     	; 0x3462 <pow+0x80>
    3412:	ff 3f       	cpi	r31, 0xFF	; 255
    3414:	e1 05       	cpc	r30, r1
    3416:	31 05       	cpc	r19, r1
    3418:	21 05       	cpc	r18, r1
    341a:	11 f1       	breq	.+68     	; 0x3460 <pow+0x7e>
    341c:	e8 94       	clt
    341e:	08 94       	sec
    3420:	e7 95       	ror	r30
    3422:	d9 01       	movw	r26, r18
    3424:	aa 23       	and	r26, r26
    3426:	29 f4       	brne	.+10     	; 0x3432 <pow+0x50>
    3428:	ab 2f       	mov	r26, r27
    342a:	be 2f       	mov	r27, r30
    342c:	f8 5f       	subi	r31, 0xF8	; 248
    342e:	d0 f3       	brcs	.-12     	; 0x3424 <pow+0x42>
    3430:	10 c0       	rjmp	.+32     	; 0x3452 <pow+0x70>
    3432:	ff 5f       	subi	r31, 0xFF	; 255
    3434:	70 f4       	brcc	.+28     	; 0x3452 <pow+0x70>
    3436:	a6 95       	lsr	r26
    3438:	e0 f7       	brcc	.-8      	; 0x3432 <pow+0x50>
    343a:	f7 39       	cpi	r31, 0x97	; 151
    343c:	50 f0       	brcs	.+20     	; 0x3452 <pow+0x70>
    343e:	19 f0       	breq	.+6      	; 0x3446 <pow+0x64>
    3440:	ff 3a       	cpi	r31, 0xAF	; 175
    3442:	38 f4       	brcc	.+14     	; 0x3452 <pow+0x70>
    3444:	9f 77       	andi	r25, 0x7F	; 127
    3446:	9f 93       	push	r25
    3448:	0c d0       	rcall	.+24     	; 0x3462 <pow+0x80>
    344a:	0f 90       	pop	r0
    344c:	07 fc       	sbrc	r0, 7
    344e:	90 58       	subi	r25, 0x80	; 128
    3450:	08 95       	ret
    3452:	3e f0       	brts	.+14     	; 0x3462 <pow+0x80>
    3454:	01 cf       	rjmp	.-510    	; 0x3258 <__fp_nan>
    3456:	60 e0       	ldi	r22, 0x00	; 0
    3458:	70 e0       	ldi	r23, 0x00	; 0
    345a:	80 e8       	ldi	r24, 0x80	; 128
    345c:	9f e3       	ldi	r25, 0x3F	; 63
    345e:	08 95       	ret
    3460:	4f e7       	ldi	r20, 0x7F	; 127
    3462:	9f 77       	andi	r25, 0x7F	; 127
    3464:	5f 93       	push	r21
    3466:	4f 93       	push	r20
    3468:	3f 93       	push	r19
    346a:	2f 93       	push	r18
    346c:	9e d0       	rcall	.+316    	; 0x35aa <log>
    346e:	2f 91       	pop	r18
    3470:	3f 91       	pop	r19
    3472:	4f 91       	pop	r20
    3474:	5f 91       	pop	r21
    3476:	52 df       	rcall	.-348    	; 0x331c <__mulsf3>
    3478:	05 c0       	rjmp	.+10     	; 0x3484 <exp>
    347a:	19 f4       	brne	.+6      	; 0x3482 <pow+0xa0>
    347c:	0e f0       	brts	.+2      	; 0x3480 <pow+0x9e>
    347e:	bd ce       	rjmp	.-646    	; 0x31fa <__fp_inf>
    3480:	46 cf       	rjmp	.-372    	; 0x330e <__fp_zero>
    3482:	ea ce       	rjmp	.-556    	; 0x3258 <__fp_nan>

00003484 <exp>:
    3484:	13 df       	rcall	.-474    	; 0x32ac <__fp_splitA>
    3486:	c8 f3       	brcs	.-14     	; 0x347a <pow+0x98>
    3488:	96 38       	cpi	r25, 0x86	; 134
    348a:	c0 f7       	brcc	.-16     	; 0x347c <pow+0x9a>
    348c:	07 f8       	bld	r0, 7
    348e:	0f 92       	push	r0
    3490:	e8 94       	clt
    3492:	2b e3       	ldi	r18, 0x3B	; 59
    3494:	3a ea       	ldi	r19, 0xAA	; 170
    3496:	48 eb       	ldi	r20, 0xB8	; 184
    3498:	5f e7       	ldi	r21, 0x7F	; 127
    349a:	4e df       	rcall	.-356    	; 0x3338 <__mulsf3_pse>
    349c:	0f 92       	push	r0
    349e:	0f 92       	push	r0
    34a0:	0f 92       	push	r0
    34a2:	4d b7       	in	r20, 0x3d	; 61
    34a4:	5e b7       	in	r21, 0x3e	; 62
    34a6:	0f 92       	push	r0
    34a8:	c0 d0       	rcall	.+384    	; 0x362a <modf>
    34aa:	e4 ee       	ldi	r30, 0xE4	; 228
    34ac:	f0 e0       	ldi	r31, 0x00	; 0
    34ae:	16 d0       	rcall	.+44     	; 0x34dc <__fp_powser>
    34b0:	4f 91       	pop	r20
    34b2:	5f 91       	pop	r21
    34b4:	ef 91       	pop	r30
    34b6:	ff 91       	pop	r31
    34b8:	e5 95       	asr	r30
    34ba:	ee 1f       	adc	r30, r30
    34bc:	ff 1f       	adc	r31, r31
    34be:	49 f0       	breq	.+18     	; 0x34d2 <exp+0x4e>
    34c0:	fe 57       	subi	r31, 0x7E	; 126
    34c2:	e0 68       	ori	r30, 0x80	; 128
    34c4:	44 27       	eor	r20, r20
    34c6:	ee 0f       	add	r30, r30
    34c8:	44 1f       	adc	r20, r20
    34ca:	fa 95       	dec	r31
    34cc:	e1 f7       	brne	.-8      	; 0x34c6 <exp+0x42>
    34ce:	41 95       	neg	r20
    34d0:	55 0b       	sbc	r21, r21
    34d2:	32 d0       	rcall	.+100    	; 0x3538 <ldexp>
    34d4:	0f 90       	pop	r0
    34d6:	07 fe       	sbrs	r0, 7
    34d8:	26 c0       	rjmp	.+76     	; 0x3526 <inverse>
    34da:	08 95       	ret

000034dc <__fp_powser>:
    34dc:	df 93       	push	r29
    34de:	cf 93       	push	r28
    34e0:	1f 93       	push	r17
    34e2:	0f 93       	push	r16
    34e4:	ff 92       	push	r15
    34e6:	ef 92       	push	r14
    34e8:	df 92       	push	r13
    34ea:	7b 01       	movw	r14, r22
    34ec:	8c 01       	movw	r16, r24
    34ee:	68 94       	set
    34f0:	05 c0       	rjmp	.+10     	; 0x34fc <__fp_powser+0x20>
    34f2:	da 2e       	mov	r13, r26
    34f4:	ef 01       	movw	r28, r30
    34f6:	1e df       	rcall	.-452    	; 0x3334 <__mulsf3x>
    34f8:	fe 01       	movw	r30, r28
    34fa:	e8 94       	clt
    34fc:	a5 91       	lpm	r26, Z+
    34fe:	25 91       	lpm	r18, Z+
    3500:	35 91       	lpm	r19, Z+
    3502:	45 91       	lpm	r20, Z+
    3504:	55 91       	lpm	r21, Z+
    3506:	ae f3       	brts	.-22     	; 0x34f2 <__fp_powser+0x16>
    3508:	ef 01       	movw	r28, r30
    350a:	13 dd       	rcall	.-1498   	; 0x2f32 <__addsf3x>
    350c:	fe 01       	movw	r30, r28
    350e:	97 01       	movw	r18, r14
    3510:	a8 01       	movw	r20, r16
    3512:	da 94       	dec	r13
    3514:	79 f7       	brne	.-34     	; 0x34f4 <__fp_powser+0x18>
    3516:	df 90       	pop	r13
    3518:	ef 90       	pop	r14
    351a:	ff 90       	pop	r15
    351c:	0f 91       	pop	r16
    351e:	1f 91       	pop	r17
    3520:	cf 91       	pop	r28
    3522:	df 91       	pop	r29
    3524:	08 95       	ret

00003526 <inverse>:
    3526:	9b 01       	movw	r18, r22
    3528:	ac 01       	movw	r20, r24
    352a:	60 e0       	ldi	r22, 0x00	; 0
    352c:	70 e0       	ldi	r23, 0x00	; 0
    352e:	80 e8       	ldi	r24, 0x80	; 128
    3530:	9f e3       	ldi	r25, 0x3F	; 63
    3532:	69 cd       	rjmp	.-1326   	; 0x3006 <__divsf3>
    3534:	62 ce       	rjmp	.-828    	; 0x31fa <__fp_inf>
    3536:	82 ce       	rjmp	.-764    	; 0x323c <__fp_mpack>

00003538 <ldexp>:
    3538:	b9 de       	rcall	.-654    	; 0x32ac <__fp_splitA>
    353a:	e8 f3       	brcs	.-6      	; 0x3536 <inverse+0x10>
    353c:	99 23       	and	r25, r25
    353e:	d9 f3       	breq	.-10     	; 0x3536 <inverse+0x10>
    3540:	94 0f       	add	r25, r20
    3542:	51 1d       	adc	r21, r1
    3544:	bb f3       	brvs	.-18     	; 0x3534 <inverse+0xe>
    3546:	91 50       	subi	r25, 0x01	; 1
    3548:	50 40       	sbci	r21, 0x00	; 0
    354a:	94 f0       	brlt	.+36     	; 0x3570 <ldexp+0x38>
    354c:	59 f0       	breq	.+22     	; 0x3564 <ldexp+0x2c>
    354e:	88 23       	and	r24, r24
    3550:	32 f0       	brmi	.+12     	; 0x355e <ldexp+0x26>
    3552:	66 0f       	add	r22, r22
    3554:	77 1f       	adc	r23, r23
    3556:	88 1f       	adc	r24, r24
    3558:	91 50       	subi	r25, 0x01	; 1
    355a:	50 40       	sbci	r21, 0x00	; 0
    355c:	c1 f7       	brne	.-16     	; 0x354e <ldexp+0x16>
    355e:	9e 3f       	cpi	r25, 0xFE	; 254
    3560:	51 05       	cpc	r21, r1
    3562:	44 f7       	brge	.-48     	; 0x3534 <inverse+0xe>
    3564:	88 0f       	add	r24, r24
    3566:	91 1d       	adc	r25, r1
    3568:	96 95       	lsr	r25
    356a:	87 95       	ror	r24
    356c:	97 f9       	bld	r25, 7
    356e:	08 95       	ret
    3570:	5f 3f       	cpi	r21, 0xFF	; 255
    3572:	ac f0       	brlt	.+42     	; 0x359e <ldexp+0x66>
    3574:	98 3e       	cpi	r25, 0xE8	; 232
    3576:	9c f0       	brlt	.+38     	; 0x359e <ldexp+0x66>
    3578:	bb 27       	eor	r27, r27
    357a:	86 95       	lsr	r24
    357c:	77 95       	ror	r23
    357e:	67 95       	ror	r22
    3580:	b7 95       	ror	r27
    3582:	08 f4       	brcc	.+2      	; 0x3586 <ldexp+0x4e>
    3584:	b1 60       	ori	r27, 0x01	; 1
    3586:	93 95       	inc	r25
    3588:	c1 f7       	brne	.-16     	; 0x357a <ldexp+0x42>
    358a:	bb 0f       	add	r27, r27
    358c:	58 f7       	brcc	.-42     	; 0x3564 <ldexp+0x2c>
    358e:	11 f4       	brne	.+4      	; 0x3594 <ldexp+0x5c>
    3590:	60 ff       	sbrs	r22, 0
    3592:	e8 cf       	rjmp	.-48     	; 0x3564 <ldexp+0x2c>
    3594:	6f 5f       	subi	r22, 0xFF	; 255
    3596:	7f 4f       	sbci	r23, 0xFF	; 255
    3598:	8f 4f       	sbci	r24, 0xFF	; 255
    359a:	9f 4f       	sbci	r25, 0xFF	; 255
    359c:	e3 cf       	rjmp	.-58     	; 0x3564 <ldexp+0x2c>
    359e:	b8 ce       	rjmp	.-656    	; 0x3310 <__fp_szero>
    35a0:	0e f0       	brts	.+2      	; 0x35a4 <ldexp+0x6c>
    35a2:	4c ce       	rjmp	.-872    	; 0x323c <__fp_mpack>
    35a4:	59 ce       	rjmp	.-846    	; 0x3258 <__fp_nan>
    35a6:	68 94       	set
    35a8:	28 ce       	rjmp	.-944    	; 0x31fa <__fp_inf>

000035aa <log>:
    35aa:	80 de       	rcall	.-768    	; 0x32ac <__fp_splitA>
    35ac:	c8 f3       	brcs	.-14     	; 0x35a0 <ldexp+0x68>
    35ae:	99 23       	and	r25, r25
    35b0:	d1 f3       	breq	.-12     	; 0x35a6 <ldexp+0x6e>
    35b2:	c6 f3       	brts	.-16     	; 0x35a4 <ldexp+0x6c>
    35b4:	df 93       	push	r29
    35b6:	cf 93       	push	r28
    35b8:	1f 93       	push	r17
    35ba:	0f 93       	push	r16
    35bc:	ff 92       	push	r15
    35be:	c9 2f       	mov	r28, r25
    35c0:	dd 27       	eor	r29, r29
    35c2:	88 23       	and	r24, r24
    35c4:	2a f0       	brmi	.+10     	; 0x35d0 <log+0x26>
    35c6:	21 97       	sbiw	r28, 0x01	; 1
    35c8:	66 0f       	add	r22, r22
    35ca:	77 1f       	adc	r23, r23
    35cc:	88 1f       	adc	r24, r24
    35ce:	da f7       	brpl	.-10     	; 0x35c6 <log+0x1c>
    35d0:	20 e0       	ldi	r18, 0x00	; 0
    35d2:	30 e0       	ldi	r19, 0x00	; 0
    35d4:	40 e8       	ldi	r20, 0x80	; 128
    35d6:	5f eb       	ldi	r21, 0xBF	; 191
    35d8:	9f e3       	ldi	r25, 0x3F	; 63
    35da:	88 39       	cpi	r24, 0x98	; 152
    35dc:	20 f0       	brcs	.+8      	; 0x35e6 <log+0x3c>
    35de:	80 3e       	cpi	r24, 0xE0	; 224
    35e0:	30 f0       	brcs	.+12     	; 0x35ee <log+0x44>
    35e2:	21 96       	adiw	r28, 0x01	; 1
    35e4:	8f 77       	andi	r24, 0x7F	; 127
    35e6:	94 dc       	rcall	.-1752   	; 0x2f10 <__addsf3>
    35e8:	ec e0       	ldi	r30, 0x0C	; 12
    35ea:	f1 e0       	ldi	r31, 0x01	; 1
    35ec:	03 c0       	rjmp	.+6      	; 0x35f4 <log+0x4a>
    35ee:	90 dc       	rcall	.-1760   	; 0x2f10 <__addsf3>
    35f0:	e9 e3       	ldi	r30, 0x39	; 57
    35f2:	f1 e0       	ldi	r31, 0x01	; 1
    35f4:	73 df       	rcall	.-282    	; 0x34dc <__fp_powser>
    35f6:	8b 01       	movw	r16, r22
    35f8:	be 01       	movw	r22, r28
    35fa:	ec 01       	movw	r28, r24
    35fc:	fb 2e       	mov	r15, r27
    35fe:	6f 57       	subi	r22, 0x7F	; 127
    3600:	71 09       	sbc	r23, r1
    3602:	75 95       	asr	r23
    3604:	77 1f       	adc	r23, r23
    3606:	88 0b       	sbc	r24, r24
    3608:	99 0b       	sbc	r25, r25
    360a:	98 dd       	rcall	.-1232   	; 0x313c <__floatsisf>
    360c:	28 e1       	ldi	r18, 0x18	; 24
    360e:	32 e7       	ldi	r19, 0x72	; 114
    3610:	41 e3       	ldi	r20, 0x31	; 49
    3612:	5f e3       	ldi	r21, 0x3F	; 63
    3614:	8f de       	rcall	.-738    	; 0x3334 <__mulsf3x>
    3616:	af 2d       	mov	r26, r15
    3618:	98 01       	movw	r18, r16
    361a:	ae 01       	movw	r20, r28
    361c:	ff 90       	pop	r15
    361e:	0f 91       	pop	r16
    3620:	1f 91       	pop	r17
    3622:	cf 91       	pop	r28
    3624:	df 91       	pop	r29
    3626:	85 dc       	rcall	.-1782   	; 0x2f32 <__addsf3x>
    3628:	28 ce       	rjmp	.-944    	; 0x327a <__fp_round>

0000362a <modf>:
    362a:	fa 01       	movw	r30, r20
    362c:	dc 01       	movw	r26, r24
    362e:	aa 0f       	add	r26, r26
    3630:	bb 1f       	adc	r27, r27
    3632:	9b 01       	movw	r18, r22
    3634:	ac 01       	movw	r20, r24
    3636:	bf 57       	subi	r27, 0x7F	; 127
    3638:	28 f4       	brcc	.+10     	; 0x3644 <modf+0x1a>
    363a:	22 27       	eor	r18, r18
    363c:	33 27       	eor	r19, r19
    363e:	44 27       	eor	r20, r20
    3640:	50 78       	andi	r21, 0x80	; 128
    3642:	1f c0       	rjmp	.+62     	; 0x3682 <modf+0x58>
    3644:	b7 51       	subi	r27, 0x17	; 23
    3646:	88 f4       	brcc	.+34     	; 0x366a <modf+0x40>
    3648:	ab 2f       	mov	r26, r27
    364a:	00 24       	eor	r0, r0
    364c:	46 95       	lsr	r20
    364e:	37 95       	ror	r19
    3650:	27 95       	ror	r18
    3652:	01 1c       	adc	r0, r1
    3654:	a3 95       	inc	r26
    3656:	d2 f3       	brmi	.-12     	; 0x364c <modf+0x22>
    3658:	00 20       	and	r0, r0
    365a:	69 f0       	breq	.+26     	; 0x3676 <modf+0x4c>
    365c:	22 0f       	add	r18, r18
    365e:	33 1f       	adc	r19, r19
    3660:	44 1f       	adc	r20, r20
    3662:	b3 95       	inc	r27
    3664:	da f3       	brmi	.-10     	; 0x365c <modf+0x32>
    3666:	0d d0       	rcall	.+26     	; 0x3682 <modf+0x58>
    3668:	52 cc       	rjmp	.-1884   	; 0x2f0e <__subsf3>
    366a:	61 30       	cpi	r22, 0x01	; 1
    366c:	71 05       	cpc	r23, r1
    366e:	a0 e8       	ldi	r26, 0x80	; 128
    3670:	8a 07       	cpc	r24, r26
    3672:	b9 46       	sbci	r27, 0x69	; 105
    3674:	30 f4       	brcc	.+12     	; 0x3682 <modf+0x58>
    3676:	9b 01       	movw	r18, r22
    3678:	ac 01       	movw	r20, r24
    367a:	66 27       	eor	r22, r22
    367c:	77 27       	eor	r23, r23
    367e:	88 27       	eor	r24, r24
    3680:	90 78       	andi	r25, 0x80	; 128
    3682:	30 96       	adiw	r30, 0x00	; 0
    3684:	21 f0       	breq	.+8      	; 0x368e <modf+0x64>
    3686:	20 83       	st	Z, r18
    3688:	31 83       	std	Z+1, r19	; 0x01
    368a:	42 83       	std	Z+2, r20	; 0x02
    368c:	53 83       	std	Z+3, r21	; 0x03
    368e:	08 95       	ret

00003690 <__udivmodhi4>:
    3690:	aa 1b       	sub	r26, r26
    3692:	bb 1b       	sub	r27, r27
    3694:	51 e1       	ldi	r21, 0x11	; 17
    3696:	07 c0       	rjmp	.+14     	; 0x36a6 <__udivmodhi4_ep>

00003698 <__udivmodhi4_loop>:
    3698:	aa 1f       	adc	r26, r26
    369a:	bb 1f       	adc	r27, r27
    369c:	a6 17       	cp	r26, r22
    369e:	b7 07       	cpc	r27, r23
    36a0:	10 f0       	brcs	.+4      	; 0x36a6 <__udivmodhi4_ep>
    36a2:	a6 1b       	sub	r26, r22
    36a4:	b7 0b       	sbc	r27, r23

000036a6 <__udivmodhi4_ep>:
    36a6:	88 1f       	adc	r24, r24
    36a8:	99 1f       	adc	r25, r25
    36aa:	5a 95       	dec	r21
    36ac:	a9 f7       	brne	.-22     	; 0x3698 <__udivmodhi4_loop>
    36ae:	80 95       	com	r24
    36b0:	90 95       	com	r25
    36b2:	bc 01       	movw	r22, r24
    36b4:	cd 01       	movw	r24, r26
    36b6:	08 95       	ret

000036b8 <__divmodhi4>:
    36b8:	97 fb       	bst	r25, 7
    36ba:	09 2e       	mov	r0, r25
    36bc:	07 26       	eor	r0, r23
    36be:	0a d0       	rcall	.+20     	; 0x36d4 <__divmodhi4_neg1>
    36c0:	77 fd       	sbrc	r23, 7
    36c2:	04 d0       	rcall	.+8      	; 0x36cc <__divmodhi4_neg2>
    36c4:	e5 df       	rcall	.-54     	; 0x3690 <__udivmodhi4>
    36c6:	06 d0       	rcall	.+12     	; 0x36d4 <__divmodhi4_neg1>
    36c8:	00 20       	and	r0, r0
    36ca:	1a f4       	brpl	.+6      	; 0x36d2 <__divmodhi4_exit>

000036cc <__divmodhi4_neg2>:
    36cc:	70 95       	com	r23
    36ce:	61 95       	neg	r22
    36d0:	7f 4f       	sbci	r23, 0xFF	; 255

000036d2 <__divmodhi4_exit>:
    36d2:	08 95       	ret

000036d4 <__divmodhi4_neg1>:
    36d4:	f6 f7       	brtc	.-4      	; 0x36d2 <__divmodhi4_exit>
    36d6:	90 95       	com	r25
    36d8:	81 95       	neg	r24
    36da:	9f 4f       	sbci	r25, 0xFF	; 255
    36dc:	08 95       	ret

000036de <malloc>:
    36de:	cf 93       	push	r28
    36e0:	df 93       	push	r29
    36e2:	ac 01       	movw	r20, r24
    36e4:	82 30       	cpi	r24, 0x02	; 2
    36e6:	91 05       	cpc	r25, r1
    36e8:	10 f4       	brcc	.+4      	; 0x36ee <malloc+0x10>
    36ea:	42 e0       	ldi	r20, 0x02	; 2
    36ec:	50 e0       	ldi	r21, 0x00	; 0
    36ee:	e0 91 64 05 	lds	r30, 0x0564
    36f2:	f0 91 65 05 	lds	r31, 0x0565
    36f6:	20 e0       	ldi	r18, 0x00	; 0
    36f8:	30 e0       	ldi	r19, 0x00	; 0
    36fa:	a0 e0       	ldi	r26, 0x00	; 0
    36fc:	b0 e0       	ldi	r27, 0x00	; 0
    36fe:	24 c0       	rjmp	.+72     	; 0x3748 <malloc+0x6a>
    3700:	80 81       	ld	r24, Z
    3702:	91 81       	ldd	r25, Z+1	; 0x01
    3704:	84 17       	cp	r24, r20
    3706:	95 07       	cpc	r25, r21
    3708:	d0 f0       	brcs	.+52     	; 0x373e <malloc+0x60>
    370a:	84 17       	cp	r24, r20
    370c:	95 07       	cpc	r25, r21
    370e:	71 f4       	brne	.+28     	; 0x372c <malloc+0x4e>
    3710:	82 81       	ldd	r24, Z+2	; 0x02
    3712:	93 81       	ldd	r25, Z+3	; 0x03
    3714:	10 97       	sbiw	r26, 0x00	; 0
    3716:	29 f0       	breq	.+10     	; 0x3722 <malloc+0x44>
    3718:	13 96       	adiw	r26, 0x03	; 3
    371a:	9c 93       	st	X, r25
    371c:	8e 93       	st	-X, r24
    371e:	12 97       	sbiw	r26, 0x02	; 2
    3720:	2c c0       	rjmp	.+88     	; 0x377a <malloc+0x9c>
    3722:	90 93 65 05 	sts	0x0565, r25
    3726:	80 93 64 05 	sts	0x0564, r24
    372a:	27 c0       	rjmp	.+78     	; 0x377a <malloc+0x9c>
    372c:	21 15       	cp	r18, r1
    372e:	31 05       	cpc	r19, r1
    3730:	19 f0       	breq	.+6      	; 0x3738 <malloc+0x5a>
    3732:	82 17       	cp	r24, r18
    3734:	93 07       	cpc	r25, r19
    3736:	18 f4       	brcc	.+6      	; 0x373e <malloc+0x60>
    3738:	9c 01       	movw	r18, r24
    373a:	bd 01       	movw	r22, r26
    373c:	ef 01       	movw	r28, r30
    373e:	92 81       	ldd	r25, Z+2	; 0x02
    3740:	83 81       	ldd	r24, Z+3	; 0x03
    3742:	df 01       	movw	r26, r30
    3744:	e9 2f       	mov	r30, r25
    3746:	f8 2f       	mov	r31, r24
    3748:	30 97       	sbiw	r30, 0x00	; 0
    374a:	d1 f6       	brne	.-76     	; 0x3700 <malloc+0x22>
    374c:	21 15       	cp	r18, r1
    374e:	31 05       	cpc	r19, r1
    3750:	f9 f0       	breq	.+62     	; 0x3790 <malloc+0xb2>
    3752:	c9 01       	movw	r24, r18
    3754:	84 1b       	sub	r24, r20
    3756:	95 0b       	sbc	r25, r21
    3758:	84 30       	cpi	r24, 0x04	; 4
    375a:	91 05       	cpc	r25, r1
    375c:	80 f4       	brcc	.+32     	; 0x377e <malloc+0xa0>
    375e:	8a 81       	ldd	r24, Y+2	; 0x02
    3760:	9b 81       	ldd	r25, Y+3	; 0x03
    3762:	61 15       	cp	r22, r1
    3764:	71 05       	cpc	r23, r1
    3766:	21 f0       	breq	.+8      	; 0x3770 <malloc+0x92>
    3768:	fb 01       	movw	r30, r22
    376a:	93 83       	std	Z+3, r25	; 0x03
    376c:	82 83       	std	Z+2, r24	; 0x02
    376e:	04 c0       	rjmp	.+8      	; 0x3778 <malloc+0x9a>
    3770:	90 93 65 05 	sts	0x0565, r25
    3774:	80 93 64 05 	sts	0x0564, r24
    3778:	fe 01       	movw	r30, r28
    377a:	32 96       	adiw	r30, 0x02	; 2
    377c:	42 c0       	rjmp	.+132    	; 0x3802 <malloc+0x124>
    377e:	fe 01       	movw	r30, r28
    3780:	e8 0f       	add	r30, r24
    3782:	f9 1f       	adc	r31, r25
    3784:	41 93       	st	Z+, r20
    3786:	51 93       	st	Z+, r21
    3788:	02 97       	sbiw	r24, 0x02	; 2
    378a:	99 83       	std	Y+1, r25	; 0x01
    378c:	88 83       	st	Y, r24
    378e:	39 c0       	rjmp	.+114    	; 0x3802 <malloc+0x124>
    3790:	80 91 62 05 	lds	r24, 0x0562
    3794:	90 91 63 05 	lds	r25, 0x0563
    3798:	00 97       	sbiw	r24, 0x00	; 0
    379a:	41 f4       	brne	.+16     	; 0x37ac <malloc+0xce>
    379c:	80 91 45 02 	lds	r24, 0x0245
    37a0:	90 91 46 02 	lds	r25, 0x0246
    37a4:	90 93 63 05 	sts	0x0563, r25
    37a8:	80 93 62 05 	sts	0x0562, r24
    37ac:	20 91 43 02 	lds	r18, 0x0243
    37b0:	30 91 44 02 	lds	r19, 0x0244
    37b4:	21 15       	cp	r18, r1
    37b6:	31 05       	cpc	r19, r1
    37b8:	41 f4       	brne	.+16     	; 0x37ca <malloc+0xec>
    37ba:	2d b7       	in	r18, 0x3d	; 61
    37bc:	3e b7       	in	r19, 0x3e	; 62
    37be:	80 91 47 02 	lds	r24, 0x0247
    37c2:	90 91 48 02 	lds	r25, 0x0248
    37c6:	28 1b       	sub	r18, r24
    37c8:	39 0b       	sbc	r19, r25
    37ca:	e0 91 62 05 	lds	r30, 0x0562
    37ce:	f0 91 63 05 	lds	r31, 0x0563
    37d2:	e2 17       	cp	r30, r18
    37d4:	f3 07       	cpc	r31, r19
    37d6:	98 f4       	brcc	.+38     	; 0x37fe <malloc+0x120>
    37d8:	2e 1b       	sub	r18, r30
    37da:	3f 0b       	sbc	r19, r31
    37dc:	24 17       	cp	r18, r20
    37de:	35 07       	cpc	r19, r21
    37e0:	70 f0       	brcs	.+28     	; 0x37fe <malloc+0x120>
    37e2:	ca 01       	movw	r24, r20
    37e4:	02 96       	adiw	r24, 0x02	; 2
    37e6:	28 17       	cp	r18, r24
    37e8:	39 07       	cpc	r19, r25
    37ea:	48 f0       	brcs	.+18     	; 0x37fe <malloc+0x120>
    37ec:	8e 0f       	add	r24, r30
    37ee:	9f 1f       	adc	r25, r31
    37f0:	90 93 63 05 	sts	0x0563, r25
    37f4:	80 93 62 05 	sts	0x0562, r24
    37f8:	41 93       	st	Z+, r20
    37fa:	51 93       	st	Z+, r21
    37fc:	02 c0       	rjmp	.+4      	; 0x3802 <malloc+0x124>
    37fe:	e0 e0       	ldi	r30, 0x00	; 0
    3800:	f0 e0       	ldi	r31, 0x00	; 0
    3802:	cf 01       	movw	r24, r30
    3804:	df 91       	pop	r29
    3806:	cf 91       	pop	r28
    3808:	08 95       	ret

0000380a <free>:
    380a:	0f 93       	push	r16
    380c:	1f 93       	push	r17
    380e:	cf 93       	push	r28
    3810:	df 93       	push	r29
    3812:	9c 01       	movw	r18, r24
    3814:	00 97       	sbiw	r24, 0x00	; 0
    3816:	09 f4       	brne	.+2      	; 0x381a <free+0x10>
    3818:	8c c0       	rjmp	.+280    	; 0x3932 <free+0x128>
    381a:	dc 01       	movw	r26, r24
    381c:	12 97       	sbiw	r26, 0x02	; 2
    381e:	13 96       	adiw	r26, 0x03	; 3
    3820:	1c 92       	st	X, r1
    3822:	1e 92       	st	-X, r1
    3824:	12 97       	sbiw	r26, 0x02	; 2
    3826:	60 91 64 05 	lds	r22, 0x0564
    382a:	70 91 65 05 	lds	r23, 0x0565
    382e:	61 15       	cp	r22, r1
    3830:	71 05       	cpc	r23, r1
    3832:	89 f4       	brne	.+34     	; 0x3856 <free+0x4c>
    3834:	8d 91       	ld	r24, X+
    3836:	9c 91       	ld	r25, X
    3838:	11 97       	sbiw	r26, 0x01	; 1
    383a:	82 0f       	add	r24, r18
    383c:	93 1f       	adc	r25, r19
    383e:	20 91 62 05 	lds	r18, 0x0562
    3842:	30 91 63 05 	lds	r19, 0x0563
    3846:	28 17       	cp	r18, r24
    3848:	39 07       	cpc	r19, r25
    384a:	69 f5       	brne	.+90     	; 0x38a6 <free+0x9c>
    384c:	b0 93 63 05 	sts	0x0563, r27
    3850:	a0 93 62 05 	sts	0x0562, r26
    3854:	6e c0       	rjmp	.+220    	; 0x3932 <free+0x128>
    3856:	fb 01       	movw	r30, r22
    3858:	40 e0       	ldi	r20, 0x00	; 0
    385a:	50 e0       	ldi	r21, 0x00	; 0
    385c:	01 c0       	rjmp	.+2      	; 0x3860 <free+0x56>
    385e:	fc 01       	movw	r30, r24
    3860:	ea 17       	cp	r30, r26
    3862:	fb 07       	cpc	r31, r27
    3864:	30 f4       	brcc	.+12     	; 0x3872 <free+0x68>
    3866:	82 81       	ldd	r24, Z+2	; 0x02
    3868:	93 81       	ldd	r25, Z+3	; 0x03
    386a:	af 01       	movw	r20, r30
    386c:	00 97       	sbiw	r24, 0x00	; 0
    386e:	b9 f7       	brne	.-18     	; 0x385e <free+0x54>
    3870:	1f c0       	rjmp	.+62     	; 0x38b0 <free+0xa6>
    3872:	e9 01       	movw	r28, r18
    3874:	22 97       	sbiw	r28, 0x02	; 2
    3876:	fb 83       	std	Y+3, r31	; 0x03
    3878:	ea 83       	std	Y+2, r30	; 0x02
    387a:	08 81       	ld	r16, Y
    387c:	19 81       	ldd	r17, Y+1	; 0x01
    387e:	c9 01       	movw	r24, r18
    3880:	80 0f       	add	r24, r16
    3882:	91 1f       	adc	r25, r17
    3884:	8e 17       	cp	r24, r30
    3886:	9f 07       	cpc	r25, r31
    3888:	59 f4       	brne	.+22     	; 0x38a0 <free+0x96>
    388a:	80 81       	ld	r24, Z
    388c:	91 81       	ldd	r25, Z+1	; 0x01
    388e:	80 0f       	add	r24, r16
    3890:	91 1f       	adc	r25, r17
    3892:	02 96       	adiw	r24, 0x02	; 2
    3894:	99 83       	std	Y+1, r25	; 0x01
    3896:	88 83       	st	Y, r24
    3898:	82 81       	ldd	r24, Z+2	; 0x02
    389a:	93 81       	ldd	r25, Z+3	; 0x03
    389c:	9b 83       	std	Y+3, r25	; 0x03
    389e:	8a 83       	std	Y+2, r24	; 0x02
    38a0:	41 15       	cp	r20, r1
    38a2:	51 05       	cpc	r21, r1
    38a4:	29 f4       	brne	.+10     	; 0x38b0 <free+0xa6>
    38a6:	b0 93 65 05 	sts	0x0565, r27
    38aa:	a0 93 64 05 	sts	0x0564, r26
    38ae:	41 c0       	rjmp	.+130    	; 0x3932 <free+0x128>
    38b0:	fa 01       	movw	r30, r20
    38b2:	b3 83       	std	Z+3, r27	; 0x03
    38b4:	a2 83       	std	Z+2, r26	; 0x02
    38b6:	c1 91       	ld	r28, Z+
    38b8:	d1 91       	ld	r29, Z+
    38ba:	ec 0f       	add	r30, r28
    38bc:	fd 1f       	adc	r31, r29
    38be:	ae 17       	cp	r26, r30
    38c0:	bf 07       	cpc	r27, r31
    38c2:	81 f4       	brne	.+32     	; 0x38e4 <free+0xda>
    38c4:	f9 01       	movw	r30, r18
    38c6:	92 91       	ld	r25, -Z
    38c8:	82 91       	ld	r24, -Z
    38ca:	8c 0f       	add	r24, r28
    38cc:	9d 1f       	adc	r25, r29
    38ce:	02 96       	adiw	r24, 0x02	; 2
    38d0:	da 01       	movw	r26, r20
    38d2:	11 96       	adiw	r26, 0x01	; 1
    38d4:	9c 93       	st	X, r25
    38d6:	8e 93       	st	-X, r24
    38d8:	82 81       	ldd	r24, Z+2	; 0x02
    38da:	93 81       	ldd	r25, Z+3	; 0x03
    38dc:	13 96       	adiw	r26, 0x03	; 3
    38de:	9c 93       	st	X, r25
    38e0:	8e 93       	st	-X, r24
    38e2:	12 97       	sbiw	r26, 0x02	; 2
    38e4:	e0 e0       	ldi	r30, 0x00	; 0
    38e6:	f0 e0       	ldi	r31, 0x00	; 0
    38e8:	02 c0       	rjmp	.+4      	; 0x38ee <free+0xe4>
    38ea:	fb 01       	movw	r30, r22
    38ec:	bc 01       	movw	r22, r24
    38ee:	db 01       	movw	r26, r22
    38f0:	12 96       	adiw	r26, 0x02	; 2
    38f2:	8d 91       	ld	r24, X+
    38f4:	9c 91       	ld	r25, X
    38f6:	13 97       	sbiw	r26, 0x03	; 3
    38f8:	00 97       	sbiw	r24, 0x00	; 0
    38fa:	b9 f7       	brne	.-18     	; 0x38ea <free+0xe0>
    38fc:	cb 01       	movw	r24, r22
    38fe:	02 96       	adiw	r24, 0x02	; 2
    3900:	2d 91       	ld	r18, X+
    3902:	3c 91       	ld	r19, X
    3904:	11 97       	sbiw	r26, 0x01	; 1
    3906:	82 0f       	add	r24, r18
    3908:	93 1f       	adc	r25, r19
    390a:	20 91 62 05 	lds	r18, 0x0562
    390e:	30 91 63 05 	lds	r19, 0x0563
    3912:	28 17       	cp	r18, r24
    3914:	39 07       	cpc	r19, r25
    3916:	69 f4       	brne	.+26     	; 0x3932 <free+0x128>
    3918:	30 97       	sbiw	r30, 0x00	; 0
    391a:	29 f4       	brne	.+10     	; 0x3926 <free+0x11c>
    391c:	10 92 65 05 	sts	0x0565, r1
    3920:	10 92 64 05 	sts	0x0564, r1
    3924:	02 c0       	rjmp	.+4      	; 0x392a <free+0x120>
    3926:	13 82       	std	Z+3, r1	; 0x03
    3928:	12 82       	std	Z+2, r1	; 0x02
    392a:	70 93 63 05 	sts	0x0563, r23
    392e:	60 93 62 05 	sts	0x0562, r22
    3932:	df 91       	pop	r29
    3934:	cf 91       	pop	r28
    3936:	1f 91       	pop	r17
    3938:	0f 91       	pop	r16
    393a:	08 95       	ret

0000393c <_exit>:
    393c:	f8 94       	cli

0000393e <__stop_program>:
    393e:	ff cf       	rjmp	.-2      	; 0x393e <__stop_program>
