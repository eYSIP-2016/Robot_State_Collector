
State_collection_eYRC_HD_1684.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000004a  00800200  0000396c  00003a00  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000396c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000031e  0080024a  0080024a  00003a4a  2**0
                  ALLOC
  3 .stab         00003a38  00000000  00000000  00003a4c  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000b91  00000000  00000000  00007484  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000000e8  00000000  00000000  00008018  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00002cfc  00000000  00000000  00008100  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000055f  00000000  00000000  0000adfc  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001078  00000000  00000000  0000b35b  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000082c  00000000  00000000  0000c3d4  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000085a  00000000  00000000  0000cc00  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000025c3  00000000  00000000  0000d45a  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000048  00000000  00000000  0000fa1d  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 b3 00 	jmp	0x166	; 0x166 <__ctors_end>
       4:	0c 94 b5 15 	jmp	0x2b6a	; 0x2b6a <__vector_1>
       8:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
       c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      10:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      14:	0c 94 0e 0b 	jmp	0x161c	; 0x161c <__vector_5>
      18:	0c 94 a8 0a 	jmp	0x1550	; 0x1550 <__vector_6>
      1c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      20:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      24:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      28:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      2c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      30:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      34:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      38:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      3c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      40:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      44:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      48:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      4c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      50:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      54:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      58:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      5c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      60:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      64:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      68:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      6c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      70:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      74:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      78:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      7c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      80:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      84:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      88:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      8c:	0c 94 dc 14 	jmp	0x29b8	; 0x29b8 <__vector_35>
      90:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      94:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      98:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      9c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      a0:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      a4:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      a8:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      ac:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      b0:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      b4:	0c 94 62 02 	jmp	0x4c4	; 0x4c4 <__vector_45>
      b8:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      bc:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      c0:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      c4:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      c8:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      cc:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      d0:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      d4:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      d8:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      dc:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      e0:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      e4:	07 63       	ori	r16, 0x37	; 55
      e6:	42 36       	cpi	r20, 0x62	; 98
      e8:	b7 9b       	sbis	0x16, 7	; 22
      ea:	d8 a7       	lds	r29, 0x78
      ec:	1a 39       	cpi	r17, 0x9A	; 154
      ee:	68 56       	subi	r22, 0x68	; 104
      f0:	18 ae       	sts	0xb8, r17
      f2:	ba ab       	sts	0x5a, r27
      f4:	55 8c       	ldd	r5, Z+29	; 0x1d
      f6:	1d 3c       	cpi	r17, 0xCD	; 205
      f8:	b7 cc       	rjmp	.-1682   	; 0xfffffa68 <__eeprom_end+0xff7efa68>
      fa:	57 63       	ori	r21, 0x37	; 55
      fc:	bd 6d       	ori	r27, 0xDD	; 221
      fe:	ed fd       	.word	0xfded	; ????
     100:	75 3e       	cpi	r23, 0xE5	; 229
     102:	f6 17       	cp	r31, r22
     104:	72 31       	cpi	r23, 0x12	; 18
     106:	bf 00       	.word	0x00bf	; ????
     108:	00 00       	nop
     10a:	80 3f       	cpi	r24, 0xF0	; 240
     10c:	08 00       	.word	0x0008	; ????
     10e:	00 00       	nop
     110:	be 92       	st	-X, r11
     112:	24 49       	sbci	r18, 0x94	; 148
     114:	12 3e       	cpi	r17, 0xE2	; 226
     116:	ab aa       	sts	0x9b, r26
     118:	aa 2a       	or	r10, r26
     11a:	be cd       	rjmp	.-1156   	; 0xfffffc98 <__eeprom_end+0xff7efc98>
     11c:	cc cc       	rjmp	.-1640   	; 0xfffffab6 <__eeprom_end+0xff7efab6>
     11e:	4c 3e       	cpi	r20, 0xEC	; 236
     120:	00 00       	nop
     122:	00 80       	ld	r0, Z
     124:	be ab       	sts	0x5e, r27
     126:	aa aa       	sts	0x9a, r26
     128:	aa 3e       	cpi	r26, 0xEA	; 234
     12a:	00 00       	nop
     12c:	00 00       	nop
     12e:	bf 00       	.word	0x00bf	; ????
     130:	00 00       	nop
     132:	80 3f       	cpi	r24, 0xF0	; 240
     134:	00 00       	nop
     136:	00 00       	nop
     138:	00 08       	sbc	r0, r0
     13a:	41 78       	andi	r20, 0x81	; 129
     13c:	d3 bb       	out	0x13, r29	; 19
     13e:	43 87       	std	Z+11, r20	; 0x0b
     140:	d1 13       	cpse	r29, r17
     142:	3d 19       	sub	r19, r13
     144:	0e 3c       	cpi	r16, 0xCE	; 206
     146:	c3 bd       	out	0x23, r28	; 35
     148:	42 82       	std	Z+2, r4	; 0x02
     14a:	ad 2b       	or	r26, r29
     14c:	3e 68       	ori	r19, 0x8E	; 142
     14e:	ec 82       	std	Y+4, r14	; 0x04
     150:	76 be       	out	0x36, r7	; 54
     152:	d9 8f       	std	Y+25, r29	; 0x19
     154:	e1 a9       	sts	0x41, r30
     156:	3e 4c       	sbci	r19, 0xCE	; 206
     158:	80 ef       	ldi	r24, 0xF0	; 240
     15a:	ff be       	out	0x3f, r15	; 63
     15c:	01 c4       	rjmp	.+2050   	; 0x960 <navigate+0x8a>
     15e:	ff 7f       	andi	r31, 0xFF	; 255
     160:	3f 00       	.word	0x003f	; ????
     162:	00 00       	nop
	...

00000166 <__ctors_end>:
     166:	11 24       	eor	r1, r1
     168:	1f be       	out	0x3f, r1	; 63
     16a:	cf ef       	ldi	r28, 0xFF	; 255
     16c:	d1 e2       	ldi	r29, 0x21	; 33
     16e:	de bf       	out	0x3e, r29	; 62
     170:	cd bf       	out	0x3d, r28	; 61
     172:	00 e0       	ldi	r16, 0x00	; 0
     174:	0c bf       	out	0x3c, r16	; 60

00000176 <__do_copy_data>:
     176:	12 e0       	ldi	r17, 0x02	; 2
     178:	a0 e0       	ldi	r26, 0x00	; 0
     17a:	b2 e0       	ldi	r27, 0x02	; 2
     17c:	ec e6       	ldi	r30, 0x6C	; 108
     17e:	f9 e3       	ldi	r31, 0x39	; 57
     180:	00 e0       	ldi	r16, 0x00	; 0
     182:	0b bf       	out	0x3b, r16	; 59
     184:	02 c0       	rjmp	.+4      	; 0x18a <__do_copy_data+0x14>
     186:	07 90       	elpm	r0, Z+
     188:	0d 92       	st	X+, r0
     18a:	aa 34       	cpi	r26, 0x4A	; 74
     18c:	b1 07       	cpc	r27, r17
     18e:	d9 f7       	brne	.-10     	; 0x186 <__do_copy_data+0x10>

00000190 <__do_clear_bss>:
     190:	15 e0       	ldi	r17, 0x05	; 5
     192:	aa e4       	ldi	r26, 0x4A	; 74
     194:	b2 e0       	ldi	r27, 0x02	; 2
     196:	01 c0       	rjmp	.+2      	; 0x19a <.do_clear_bss_start>

00000198 <.do_clear_bss_loop>:
     198:	1d 92       	st	X+, r1

0000019a <.do_clear_bss_start>:
     19a:	a8 36       	cpi	r26, 0x68	; 104
     19c:	b1 07       	cpc	r27, r17
     19e:	e1 f7       	brne	.-8      	; 0x198 <.do_clear_bss_loop>
     1a0:	0e 94 24 17 	call	0x2e48	; 0x2e48 <main>
     1a4:	0c 94 b4 1c 	jmp	0x3968	; 0x3968 <_exit>

000001a8 <__bad_interrupt>:
     1a8:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000001ac <def>:
*/

void def(void)
{
	int i=0,j=0;
	for(i=0;i<=maximum_number_of_nodes;i++)	//i: will iterate from 0 to the maximum nodes (maximum_number_of_nodes is the constant for the maximum number of nodes in the arena )
     1ac:	20 e0       	ldi	r18, 0x00	; 0
     1ae:	30 e0       	ldi	r19, 0x00	; 0
* Logic:			All the nodes of the arena are accessed and given null value (more specifically null character)
* Example Call:		def();
*
*/

void def(void)
     1b0:	40 e0       	ldi	r20, 0x00	; 0
     1b2:	50 e0       	ldi	r21, 0x00	; 0
     1b4:	0a c0       	rjmp	.+20     	; 0x1ca <def+0x1e>
{
	int i=0,j=0;
	for(i=0;i<=maximum_number_of_nodes;i++)	//i: will iterate from 0 to the maximum nodes (maximum_number_of_nodes is the constant for the maximum number of nodes in the arena )
	for(j=0;j<=maximum_number_of_nodes;j++)	//j: will iterate from 0 to the maximum nodes (maximum_number_of_nodes is the constant for the maximum number of nodes in the arena )
	graph[i][j]='\0';
     1b6:	11 92       	st	Z+, r1

void def(void)
{
	int i=0,j=0;
	for(i=0;i<=maximum_number_of_nodes;i++)	//i: will iterate from 0 to the maximum nodes (maximum_number_of_nodes is the constant for the maximum number of nodes in the arena )
	for(j=0;j<=maximum_number_of_nodes;j++)	//j: will iterate from 0 to the maximum nodes (maximum_number_of_nodes is the constant for the maximum number of nodes in the arena )
     1b8:	01 96       	adiw	r24, 0x01	; 1
     1ba:	8a 31       	cpi	r24, 0x1A	; 26
     1bc:	91 05       	cpc	r25, r1
     1be:	d9 f7       	brne	.-10     	; 0x1b6 <def+0xa>
*/

void def(void)
{
	int i=0,j=0;
	for(i=0;i<=maximum_number_of_nodes;i++)	//i: will iterate from 0 to the maximum nodes (maximum_number_of_nodes is the constant for the maximum number of nodes in the arena )
     1c0:	2f 5f       	subi	r18, 0xFF	; 255
     1c2:	3f 4f       	sbci	r19, 0xFF	; 255
     1c4:	2a 31       	cpi	r18, 0x1A	; 26
     1c6:	31 05       	cpc	r19, r1
     1c8:	89 f0       	breq	.+34     	; 0x1ec <def+0x40>
* Logic:			All the nodes of the arena are accessed and given null value (more specifically null character)
* Example Call:		def();
*
*/

void def(void)
     1ca:	f9 01       	movw	r30, r18
     1cc:	ee 0f       	add	r30, r30
     1ce:	ff 1f       	adc	r31, r31
     1d0:	e2 0f       	add	r30, r18
     1d2:	f3 1f       	adc	r31, r19
     1d4:	ee 0f       	add	r30, r30
     1d6:	ff 1f       	adc	r31, r31
     1d8:	ee 0f       	add	r30, r30
     1da:	ff 1f       	adc	r31, r31
     1dc:	ee 0f       	add	r30, r30
     1de:	ff 1f       	adc	r31, r31
     1e0:	e2 0f       	add	r30, r18
     1e2:	f3 1f       	adc	r31, r19
     1e4:	e3 54       	subi	r30, 0x43	; 67
     1e6:	fd 4f       	sbci	r31, 0xFD	; 253
     1e8:	ca 01       	movw	r24, r20
     1ea:	e5 cf       	rjmp	.-54     	; 0x1b6 <def+0xa>
     1ec:	08 95       	ret

000001ee <sppeed>:
*
*/

void sppeed(unsigned int l,unsigned int r) 
{
	cli();
     1ee:	f8 94       	cli
	OCR5A=l;		// OCR5A = for left motor
     1f0:	90 93 29 01 	sts	0x0129, r25
     1f4:	80 93 28 01 	sts	0x0128, r24
	OCR5B=r;		// OCR5B = for right motor
     1f8:	70 93 2b 01 	sts	0x012B, r23
     1fc:	60 93 2a 01 	sts	0x012A, r22
	sei();
     200:	78 94       	sei
}
     202:	08 95       	ret

00000204 <enqueue>:
* Example Call:			enqueue(10);
*
*/

void enqueue(int node_added)
{
     204:	0f 93       	push	r16
     206:	1f 93       	push	r17
     208:	cf 93       	push	r28
     20a:	df 93       	push	r29
     20c:	8c 01       	movw	r16, r24
	struct queue *newnode;
	if(root==NULL)
     20e:	c0 91 4c 02 	lds	r28, 0x024C
     212:	d0 91 4d 02 	lds	r29, 0x024D
     216:	20 97       	sbiw	r28, 0x00	; 0
     218:	a9 f4       	brne	.+42     	; 0x244 <enqueue+0x40>
	{
		root=(struct queue*)malloc(sizeof(struct queue));
     21a:	86 e0       	ldi	r24, 0x06	; 6
     21c:	90 e0       	ldi	r25, 0x00	; 0
     21e:	0e 94 85 1b 	call	0x370a	; 0x370a <malloc>
     222:	e8 2f       	mov	r30, r24
     224:	f9 2f       	mov	r31, r25
     226:	f0 93 4d 02 	sts	0x024D, r31
     22a:	e0 93 4c 02 	sts	0x024C, r30
		root->num=node_added;
     22e:	15 83       	std	Z+5, r17	; 0x05
     230:	04 83       	std	Z+4, r16	; 0x04
		root->next=NULL;
     232:	11 82       	std	Z+1, r1	; 0x01
     234:	10 82       	st	Z, r1
		root->prev=NULL;
     236:	13 82       	std	Z+3, r1	; 0x03
     238:	12 82       	std	Z+2, r1	; 0x02
		end=root;
     23a:	f0 93 4b 02 	sts	0x024B, r31
     23e:	e0 93 4a 02 	sts	0x024A, r30
     242:	19 c0       	rjmp	.+50     	; 0x276 <enqueue+0x72>
	}
	else
	{
		newnode=(struct queue*)malloc(sizeof(struct queue));
     244:	86 e0       	ldi	r24, 0x06	; 6
     246:	90 e0       	ldi	r25, 0x00	; 0
     248:	0e 94 85 1b 	call	0x370a	; 0x370a <malloc>
     24c:	e8 2f       	mov	r30, r24
     24e:	f9 2f       	mov	r31, r25
		newnode->num=node_added;
     250:	15 83       	std	Z+5, r17	; 0x05
     252:	04 83       	std	Z+4, r16	; 0x04
		root->next=newnode;
     254:	f9 83       	std	Y+1, r31	; 0x01
     256:	e8 83       	st	Y, r30
		newnode->prev=root;
     258:	a0 91 4c 02 	lds	r26, 0x024C
     25c:	b0 91 4d 02 	lds	r27, 0x024D
     260:	b3 83       	std	Z+3, r27	; 0x03
     262:	a2 83       	std	Z+2, r26	; 0x02
		root=root->next;
     264:	8d 91       	ld	r24, X+
     266:	9c 91       	ld	r25, X
     268:	11 97       	sbiw	r26, 0x01	; 1
     26a:	90 93 4d 02 	sts	0x024D, r25
     26e:	80 93 4c 02 	sts	0x024C, r24
		newnode->next=NULL;
     272:	11 82       	std	Z+1, r1	; 0x01
     274:	10 82       	st	Z, r1
	}
	que_length++;			//que_length -> length of the queue
     276:	80 91 57 02 	lds	r24, 0x0257
     27a:	90 91 58 02 	lds	r25, 0x0258
     27e:	01 96       	adiw	r24, 0x01	; 1
     280:	90 93 58 02 	sts	0x0258, r25
     284:	80 93 57 02 	sts	0x0257, r24
}
     288:	df 91       	pop	r29
     28a:	cf 91       	pop	r28
     28c:	1f 91       	pop	r17
     28e:	0f 91       	pop	r16
     290:	08 95       	ret

00000292 <_adc_pinconfig>:
* Example Call:		_adc_pinconfig()
*
*/
void _adc_pinconfig (void)
{
	DDRF = DDRF & 0x01;  //set PORTF direction as input
     292:	80 b3       	in	r24, 0x10	; 16
     294:	81 70       	andi	r24, 0x01	; 1
     296:	80 bb       	out	0x10, r24	; 16
	PORTF = 0x00; //set PORTF pins floating
     298:	11 ba       	out	0x11, r1	; 17
	DDRK = DDRK & 0xC0;  //set PORTK direction as input
     29a:	e7 e0       	ldi	r30, 0x07	; 7
     29c:	f1 e0       	ldi	r31, 0x01	; 1
     29e:	80 81       	ld	r24, Z
     2a0:	80 7c       	andi	r24, 0xC0	; 192
     2a2:	80 83       	st	Z, r24
	PORTK = 0x00; //set PORTK pins floating
     2a4:	10 92 08 01 	sts	0x0108, r1
}
     2a8:	08 95       	ret

000002aa <_adc_init>:
* Example Call:		_adc_init()
*
*/
void _adc_init(void)
{
	ADCSRA = 0x00;
     2aa:	ea e7       	ldi	r30, 0x7A	; 122
     2ac:	f0 e0       	ldi	r31, 0x00	; 0
     2ae:	10 82       	st	Z, r1
	ADCSRB = 0x00;		//MUX5 = 0
     2b0:	10 92 7b 00 	sts	0x007B, r1
	ADMUX = 0x20;		//Vref=5V external --- ADLAR=1(result is left adjusted) --- MUX4:0 = 0000
     2b4:	80 e2       	ldi	r24, 0x20	; 32
     2b6:	80 93 7c 00 	sts	0x007C, r24
	ACSR = 0x80;        //Analog comparator disable to reduce power consumption
     2ba:	80 e8       	ldi	r24, 0x80	; 128
     2bc:	80 bf       	out	0x30, r24	; 48
	ADCSRA = 0x86;		//ADEN=1(ADC enable)  --- ADPS2:0 = 1 1 0
     2be:	86 e8       	ldi	r24, 0x86	; 134
     2c0:	80 83       	st	Z, r24
}
     2c2:	08 95       	ret

000002c4 <_conv_adc>:
*
*/
unsigned char _conv_adc(unsigned char ch)
{
	unsigned char a;     // digital value which stores the digital value of ADCH register
	if(ch>7)
     2c4:	88 30       	cpi	r24, 0x08	; 8
     2c6:	18 f0       	brcs	.+6      	; 0x2ce <_conv_adc+0xa>
	{
		ADCSRB = 0x08;
     2c8:	98 e0       	ldi	r25, 0x08	; 8
     2ca:	90 93 7b 00 	sts	0x007B, r25
	}
	ch = ch & 0x07;			  //Store only 3 LSB bits
     2ce:	87 70       	andi	r24, 0x07	; 7
	ADMUX= 0x20 | ch;		 //Select the ADC channel with left adjust select
     2d0:	80 62       	ori	r24, 0x20	; 32
     2d2:	80 93 7c 00 	sts	0x007C, r24
	ADCSRA = ADCSRA | 0x40;	 //Set start conversion bit
     2d6:	ea e7       	ldi	r30, 0x7A	; 122
     2d8:	f0 e0       	ldi	r31, 0x00	; 0
     2da:	80 81       	ld	r24, Z
     2dc:	80 64       	ori	r24, 0x40	; 64
     2de:	80 83       	st	Z, r24
	while((ADCSRA&0x10)==0); //Wait for ADC conversion to complete
     2e0:	80 81       	ld	r24, Z
     2e2:	84 ff       	sbrs	r24, 4
     2e4:	fd cf       	rjmp	.-6      	; 0x2e0 <_conv_adc+0x1c>
	a=ADCH;
     2e6:	80 91 79 00 	lds	r24, 0x0079
	ADCSRA = ADCSRA|0x10;   //clear ADIF (ADC Interrupt Flag) by writing 1 to it
     2ea:	ea e7       	ldi	r30, 0x7A	; 122
     2ec:	f0 e0       	ldi	r31, 0x00	; 0
     2ee:	90 81       	ld	r25, Z
     2f0:	90 61       	ori	r25, 0x10	; 16
     2f2:	90 83       	st	Z, r25
	ADCSRB = 0x00;
     2f4:	10 92 7b 00 	sts	0x007B, r1
	return a;
}
     2f8:	08 95       	ret

000002fa <converttomm_41sk>:
* Output:           Distance in mm
* Example Call:		converttomm_41sk(_conv_adc(9));
*
*/
unsigned int converttomm_41sk(unsigned int a)//conversion of sharp sensor values.
{
     2fa:	0f 93       	push	r16
     2fc:	1f 93       	push	r17
	double b;
	b=a;
     2fe:	bc 01       	movw	r22, r24
     300:	80 e0       	ldi	r24, 0x00	; 0
     302:	90 e0       	ldi	r25, 0x00	; 0
     304:	0e 94 b2 18 	call	0x3164	; 0x3164 <__floatunsisf>
	b = b*0.001240875;
     308:	46 2f       	mov	r20, r22
     30a:	57 2f       	mov	r21, r23
     30c:	68 2f       	mov	r22, r24
     30e:	79 2f       	mov	r23, r25
     310:	cb 01       	movw	r24, r22
     312:	ba 01       	movw	r22, r20
     314:	2b ed       	ldi	r18, 0xDB	; 219
     316:	34 ea       	ldi	r19, 0xA4	; 164
     318:	42 ea       	ldi	r20, 0xA2	; 162
     31a:	5a e3       	ldi	r21, 0x3A	; 58
     31c:	0e 94 a4 19 	call	0x3348	; 0x3348 <__mulsf3>
	b = b+0.005;
     320:	46 2f       	mov	r20, r22
     322:	57 2f       	mov	r21, r23
     324:	68 2f       	mov	r22, r24
     326:	79 2f       	mov	r23, r25
     328:	cb 01       	movw	r24, r22
     32a:	ba 01       	movw	r22, r20
     32c:	2a e0       	ldi	r18, 0x0A	; 10
     32e:	37 ed       	ldi	r19, 0xD7	; 215
     330:	43 ea       	ldi	r20, 0xA3	; 163
     332:	5b e3       	ldi	r21, 0x3B	; 59
     334:	0e 94 9e 17 	call	0x2f3c	; 0x2f3c <__addsf3>
     338:	b6 2f       	mov	r27, r22
     33a:	a7 2f       	mov	r26, r23
     33c:	38 2f       	mov	r19, r24
     33e:	29 2f       	mov	r18, r25
	b = 10/b;
     340:	60 e0       	ldi	r22, 0x00	; 0
     342:	70 e0       	ldi	r23, 0x00	; 0
     344:	80 e2       	ldi	r24, 0x20	; 32
     346:	91 e4       	ldi	r25, 0x41	; 65
     348:	42 2f       	mov	r20, r18
     34a:	0b 2f       	mov	r16, r27
     34c:	1a 2f       	mov	r17, r26
     34e:	23 2f       	mov	r18, r19
     350:	34 2f       	mov	r19, r20
     352:	a9 01       	movw	r20, r18
     354:	98 01       	movw	r18, r16
     356:	0e 94 19 18 	call	0x3032	; 0x3032 <__divsf3>
	b = b-24.2;
     35a:	46 2f       	mov	r20, r22
     35c:	57 2f       	mov	r21, r23
     35e:	68 2f       	mov	r22, r24
     360:	79 2f       	mov	r23, r25
     362:	cb 01       	movw	r24, r22
     364:	ba 01       	movw	r22, r20
     366:	2a e9       	ldi	r18, 0x9A	; 154
     368:	39 e9       	ldi	r19, 0x99	; 153
     36a:	41 ec       	ldi	r20, 0xC1	; 193
     36c:	51 e4       	ldi	r21, 0x41	; 65
     36e:	0e 94 9d 17 	call	0x2f3a	; 0x2f3a <__subsf3>
	b = (int)b;
     372:	0e 94 81 18 	call	0x3102	; 0x3102 <__fixsfsi>
     376:	88 27       	eor	r24, r24
     378:	77 fd       	sbrc	r23, 7
     37a:	80 95       	com	r24
     37c:	98 2f       	mov	r25, r24
     37e:	0e 94 b4 18 	call	0x3168	; 0x3168 <__floatsisf>
	return b;
     382:	0e 94 86 18 	call	0x310c	; 0x310c <__fixunssfsi>
}
     386:	86 2f       	mov	r24, r22
     388:	97 2f       	mov	r25, r23
     38a:	1f 91       	pop	r17
     38c:	0f 91       	pop	r16
     38e:	08 95       	ret

00000390 <_timer4_init>:
* Example Call:		NONE
*
*/
void _timer4_init(void)
{
	TCCR4B = 0x00; //stop
     390:	e1 ea       	ldi	r30, 0xA1	; 161
     392:	f0 e0       	ldi	r31, 0x00	; 0
     394:	10 82       	st	Z, r1
	OCR4AH = 0x00; //Output Compare Register (OCR)- Not used
     396:	10 92 a9 00 	sts	0x00A9, r1
	OCR4AL = 0x00; //Output compare Register (OCR)- Not used
     39a:	10 92 a8 00 	sts	0x00A8, r1
	OCR4BH = 0x00; //Output compare Register (OCR)- Not used
     39e:	10 92 ab 00 	sts	0x00AB, r1
	OCR4BL = 0x00; //Output compare Register (OCR)- Not used
     3a2:	10 92 aa 00 	sts	0x00AA, r1
	OCR4CH = 0x00; //Output compare Register (OCR)- Not used
     3a6:	10 92 ad 00 	sts	0x00AD, r1
	OCR4CL = 0x00; //Output compare Register (OCR)- Not used
     3aa:	10 92 ac 00 	sts	0x00AC, r1
	ICR4   = 0x7080; //Input Capture Register (ICR)  
     3ae:	80 e8       	ldi	r24, 0x80	; 128
     3b0:	90 e7       	ldi	r25, 0x70	; 112
     3b2:	90 93 a7 00 	sts	0x00A7, r25
     3b6:	80 93 a6 00 	sts	0x00A6, r24
	TCCR4C = 0x00;
     3ba:	10 92 a2 00 	sts	0x00A2, r1
	TCCR4A = 0b00000010;// Normal port operation........WGM41:40=1 0
     3be:	82 e0       	ldi	r24, 0x02	; 2
     3c0:	80 93 a0 00 	sts	0x00A0, r24
	TCCR4B = 0b00011100; //start Timer.......WGM43:42=1 1........CS42:40=1 0 0(clkI/O/256 (From prescaler)) 
     3c4:	8c e1       	ldi	r24, 0x1C	; 28
     3c6:	80 83       	st	Z, r24
}
     3c8:	08 95       	ret

000003ca <send>:

void send ( int n)
{
	int z = 0;
	int c = n;
	a[0] = 0;
     3ca:	10 92 5a 05 	sts	0x055A, r1
	a[1] = 0;
     3ce:	10 92 5b 05 	sts	0x055B, r1
	a[2] = 0;
     3d2:	10 92 5c 05 	sts	0x055C, r1
	while (c)
     3d6:	00 97       	sbiw	r24, 0x00	; 0
     3d8:	61 f0       	breq	.+24     	; 0x3f2 <send+0x28>
     3da:	ea e5       	ldi	r30, 0x5A	; 90
     3dc:	f5 e0       	ldi	r31, 0x05	; 5
	{ // loop till there's nothing left
		a[z++] = (char)(c % 10); // assign the last digit
     3de:	2a e0       	ldi	r18, 0x0A	; 10
     3e0:	30 e0       	ldi	r19, 0x00	; 0
     3e2:	b9 01       	movw	r22, r18
     3e4:	0e 94 72 1b 	call	0x36e4	; 0x36e4 <__divmodhi4>
     3e8:	81 93       	st	Z+, r24
		c /= 10; // "right shift" the number
     3ea:	86 2f       	mov	r24, r22
     3ec:	97 2f       	mov	r25, r23
	int z = 0;
	int c = n;
	a[0] = 0;
	a[1] = 0;
	a[2] = 0;
	while (c)
     3ee:	00 97       	sbiw	r24, 0x00	; 0
     3f0:	c1 f7       	brne	.-16     	; 0x3e2 <send+0x18>
	{ // loop till there's nothing left
		a[z++] = (char)(c % 10); // assign the last digit
		c /= 10; // "right shift" the number
	}
	
	UDR0 = a[2] + 48;   //sending the first digit
     3f2:	80 91 5c 05 	lds	r24, 0x055C
     3f6:	80 5d       	subi	r24, 0xD0	; 208
     3f8:	80 93 c6 00 	sts	0x00C6, r24
	while(!(UCSR0A & (1<<UDRE0)))   
     3fc:	e0 ec       	ldi	r30, 0xC0	; 192
     3fe:	f0 e0       	ldi	r31, 0x00	; 0
     400:	80 81       	ld	r24, Z
     402:	85 ff       	sbrs	r24, 5
     404:	fd cf       	rjmp	.-6      	; 0x400 <send+0x36>
	{
		//waiting for transmission to complete
	}
	UDR0 = a[1] + 48; //sending the second digit
     406:	80 91 5b 05 	lds	r24, 0x055B
     40a:	80 5d       	subi	r24, 0xD0	; 208
     40c:	80 93 c6 00 	sts	0x00C6, r24
	while(!(UCSR0A & (1<<UDRE0)))
     410:	e0 ec       	ldi	r30, 0xC0	; 192
     412:	f0 e0       	ldi	r31, 0x00	; 0
     414:	80 81       	ld	r24, Z
     416:	85 ff       	sbrs	r24, 5
     418:	fd cf       	rjmp	.-6      	; 0x414 <send+0x4a>
	{
		//waiting for transmission to complete
	}
	UDR0 = a[0] + 48; //sending the third digit
     41a:	80 91 5a 05 	lds	r24, 0x055A
     41e:	80 5d       	subi	r24, 0xD0	; 208
     420:	80 93 c6 00 	sts	0x00C6, r24
	while(!(UCSR0A & (1<<UDRE0)))
     424:	e0 ec       	ldi	r30, 0xC0	; 192
     426:	f0 e0       	ldi	r31, 0x00	; 0
     428:	80 81       	ld	r24, Z
     42a:	85 ff       	sbrs	r24, 5
     42c:	fd cf       	rjmp	.-6      	; 0x428 <send+0x5e>
	{
		//waiting for transmission to complete
	}
	UDR0 = 32;      //to give space between two integer
     42e:	80 e2       	ldi	r24, 0x20	; 32
     430:	80 93 c6 00 	sts	0x00C6, r24
	while(!(UCSR0A & (1<<UDRE0)))
     434:	e0 ec       	ldi	r30, 0xC0	; 192
     436:	f0 e0       	ldi	r31, 0x00	; 0
     438:	80 81       	ld	r24, Z
     43a:	85 ff       	sbrs	r24, 5
     43c:	fd cf       	rjmp	.-6      	; 0x438 <send+0x6e>
	{
		//waiting for transmission to complete
	}
}
     43e:	08 95       	ret

00000440 <getdigital>:
*
*/

void getdigital(void)
{
	 lwl= _conv_adc(3);  	//Getting data of Left WL Sensor
     440:	83 e0       	ldi	r24, 0x03	; 3
     442:	0e 94 62 01 	call	0x2c4	; 0x2c4 <_conv_adc>
     446:	80 93 6c 02 	sts	0x026C, r24
	 cwl = _conv_adc(2);	//Getting data of Center WL Sensor
     44a:	82 e0       	ldi	r24, 0x02	; 2
     44c:	0e 94 62 01 	call	0x2c4	; 0x2c4 <_conv_adc>
     450:	80 93 6b 02 	sts	0x026B, r24
	 rwl = _conv_adc(1);	//Getting data of Right WL Sensor
     454:	81 e0       	ldi	r24, 0x01	; 1
     456:	0e 94 62 01 	call	0x2c4	; 0x2c4 <_conv_adc>
     45a:	80 93 6a 02 	sts	0x026A, r24
	 sp1 = _conv_adc(9);     //Getting data of sharp sensor1.
     45e:	89 e0       	ldi	r24, 0x09	; 9
     460:	0e 94 62 01 	call	0x2c4	; 0x2c4 <_conv_adc>
     464:	80 93 b7 02 	sts	0x02B7, r24
	 sp2 = _conv_adc(10);    //Getting data of sharp sensor2.
     468:	8a e0       	ldi	r24, 0x0A	; 10
     46a:	0e 94 62 01 	call	0x2c4	; 0x2c4 <_conv_adc>
     46e:	80 93 bc 02 	sts	0x02BC, r24
	 sp3 = _conv_adc(11);    //Getting data of sharp sensor3.
     472:	8b e0       	ldi	r24, 0x0B	; 11
     474:	0e 94 62 01 	call	0x2c4	; 0x2c4 <_conv_adc>
     478:	80 93 34 05 	sts	0x0534, r24
	 sp4 = _conv_adc(12);    //Getting data of sharp sensor4.
     47c:	8c e0       	ldi	r24, 0x0C	; 12
     47e:	0e 94 62 01 	call	0x2c4	; 0x2c4 <_conv_adc>
     482:	80 93 5f 05 	sts	0x055F, r24
     sp5 = _conv_adc(13);    //Getting data of sharp sensor5.
     486:	8d e0       	ldi	r24, 0x0D	; 13
     488:	0e 94 62 01 	call	0x2c4	; 0x2c4 <_conv_adc>
     48c:	80 93 89 02 	sts	0x0289, r24
	 IR1 = _conv_adc(4);     //Getting value of IR proximity sensor1.
     490:	84 e0       	ldi	r24, 0x04	; 4
     492:	0e 94 62 01 	call	0x2c4	; 0x2c4 <_conv_adc>
     496:	80 93 2e 05 	sts	0x052E, r24
	 IR2 = _conv_adc(5);     //Getting value of IR proximity sensor2.
     49a:	85 e0       	ldi	r24, 0x05	; 5
     49c:	0e 94 62 01 	call	0x2c4	; 0x2c4 <_conv_adc>
     4a0:	80 93 ab 02 	sts	0x02AB, r24
	 IR3 = _conv_adc(6);     //Getting value of IR proximity sensor3.
     4a4:	86 e0       	ldi	r24, 0x06	; 6
     4a6:	0e 94 62 01 	call	0x2c4	; 0x2c4 <_conv_adc>
     4aa:	80 93 b0 02 	sts	0x02B0, r24
	 IR4 = _conv_adc(7);     //Getting value of IR proximity sensor4.
     4ae:	87 e0       	ldi	r24, 0x07	; 7
     4b0:	0e 94 62 01 	call	0x2c4	; 0x2c4 <_conv_adc>
     4b4:	80 93 33 05 	sts	0x0533, r24
     IR5 = _conv_adc(8);     //Getting value of IR proximity sensor5.
     4b8:	88 e0       	ldi	r24, 0x08	; 8
     4ba:	0e 94 62 01 	call	0x2c4	; 0x2c4 <_conv_adc>
     4be:	80 93 69 02 	sts	0x0269, r24

	 
	
}
     4c2:	08 95       	ret

000004c4 <__vector_45>:
* Logic:			               Timer 4 is configured as such that it gets overflow in  every 0.5 seconds so 
                                   that the sensor readings & wheel velocity are updated and sent continuously.
* Example Call:		               NONE
*/
ISR(TIMER4_OVF_vect)
{
     4c4:	1f 92       	push	r1
     4c6:	0f 92       	push	r0
     4c8:	0f b6       	in	r0, 0x3f	; 63
     4ca:	0f 92       	push	r0
     4cc:	0b b6       	in	r0, 0x3b	; 59
     4ce:	0f 92       	push	r0
     4d0:	11 24       	eor	r1, r1
     4d2:	2f 93       	push	r18
     4d4:	3f 93       	push	r19
     4d6:	4f 93       	push	r20
     4d8:	5f 93       	push	r21
     4da:	6f 93       	push	r22
     4dc:	7f 93       	push	r23
     4de:	8f 93       	push	r24
     4e0:	9f 93       	push	r25
     4e2:	af 93       	push	r26
     4e4:	bf 93       	push	r27
     4e6:	ef 93       	push	r30
     4e8:	ff 93       	push	r31
	     cli();                 //Clears the global interrupt
     4ea:	f8 94       	cli
		getdigital();           //stores digital value of sensors in different variables.
     4ec:	0e 94 20 02 	call	0x440	; 0x440 <getdigital>
		//sensor_data_interpretation();
		send(count);
     4f0:	80 91 6d 02 	lds	r24, 0x026D
     4f4:	90 91 6e 02 	lds	r25, 0x026E
     4f8:	0e 94 e5 01 	call	0x3ca	; 0x3ca <send>
		send(lwl);                  //send the value of left white line sensor
     4fc:	80 91 6c 02 	lds	r24, 0x026C
     500:	90 e0       	ldi	r25, 0x00	; 0
     502:	0e 94 e5 01 	call	0x3ca	; 0x3ca <send>
		send(cwl);                  //send the value of center white line sensor
     506:	80 91 6b 02 	lds	r24, 0x026B
     50a:	90 e0       	ldi	r25, 0x00	; 0
     50c:	0e 94 e5 01 	call	0x3ca	; 0x3ca <send>
		send(rwl);                  //send the value of right white line sensor
     510:	80 91 6a 02 	lds	r24, 0x026A
     514:	90 e0       	ldi	r25, 0x00	; 0
     516:	0e 94 e5 01 	call	0x3ca	; 0x3ca <send>
		send(converttomm_41sk(sp1));//send the value of sharp sensor 1
     51a:	80 91 b7 02 	lds	r24, 0x02B7
     51e:	90 e0       	ldi	r25, 0x00	; 0
     520:	0e 94 7d 01 	call	0x2fa	; 0x2fa <converttomm_41sk>
     524:	0e 94 e5 01 	call	0x3ca	; 0x3ca <send>
		send(converttomm_41sk(sp2));//send the value of sharp sensor 2
     528:	80 91 bc 02 	lds	r24, 0x02BC
     52c:	90 e0       	ldi	r25, 0x00	; 0
     52e:	0e 94 7d 01 	call	0x2fa	; 0x2fa <converttomm_41sk>
     532:	0e 94 e5 01 	call	0x3ca	; 0x3ca <send>
		send(converttomm_41sk(sp3));//send the value of sharp sensor 3 
     536:	80 91 34 05 	lds	r24, 0x0534
     53a:	90 e0       	ldi	r25, 0x00	; 0
     53c:	0e 94 7d 01 	call	0x2fa	; 0x2fa <converttomm_41sk>
     540:	0e 94 e5 01 	call	0x3ca	; 0x3ca <send>
		send(converttomm_41sk(sp4));//send the value of sharp sensor 4
     544:	80 91 5f 05 	lds	r24, 0x055F
     548:	90 e0       	ldi	r25, 0x00	; 0
     54a:	0e 94 7d 01 	call	0x2fa	; 0x2fa <converttomm_41sk>
     54e:	0e 94 e5 01 	call	0x3ca	; 0x3ca <send>
        send(converttomm_41sk(sp5));//send the value of sharp sensor 5
     552:	80 91 89 02 	lds	r24, 0x0289
     556:	90 e0       	ldi	r25, 0x00	; 0
     558:	0e 94 7d 01 	call	0x2fa	; 0x2fa <converttomm_41sk>
     55c:	0e 94 e5 01 	call	0x3ca	; 0x3ca <send>
		send(IR1);                  //send the value of proximity sensor1
     560:	80 91 2e 05 	lds	r24, 0x052E
     564:	90 e0       	ldi	r25, 0x00	; 0
     566:	0e 94 e5 01 	call	0x3ca	; 0x3ca <send>
		send(IR2);                  //send the value of proximity sensor2
     56a:	80 91 ab 02 	lds	r24, 0x02AB
     56e:	90 e0       	ldi	r25, 0x00	; 0
     570:	0e 94 e5 01 	call	0x3ca	; 0x3ca <send>
        send(IR3);                  //send the value of proximity sensor3
     574:	80 91 b0 02 	lds	r24, 0x02B0
     578:	90 e0       	ldi	r25, 0x00	; 0
     57a:	0e 94 e5 01 	call	0x3ca	; 0x3ca <send>
		send(IR4);                  //send the value of proximity sensor4
     57e:	80 91 33 05 	lds	r24, 0x0533
     582:	90 e0       	ldi	r25, 0x00	; 0
     584:	0e 94 e5 01 	call	0x3ca	; 0x3ca <send>
        send(IR5);                  //send the value of proximity sensor5
     588:	80 91 69 02 	lds	r24, 0x0269
     58c:	90 e0       	ldi	r25, 0x00	; 0
     58e:	0e 94 e5 01 	call	0x3ca	; 0x3ca <send>
		count++;                      //increase the value of count
     592:	80 91 6d 02 	lds	r24, 0x026D
     596:	90 91 6e 02 	lds	r25, 0x026E
     59a:	01 96       	adiw	r24, 0x01	; 1
     59c:	90 93 6e 02 	sts	0x026E, r25
     5a0:	80 93 6d 02 	sts	0x026D, r24
		sei();                        //enables the global interrupt      
     5a4:	78 94       	sei
}
     5a6:	ff 91       	pop	r31
     5a8:	ef 91       	pop	r30
     5aa:	bf 91       	pop	r27
     5ac:	af 91       	pop	r26
     5ae:	9f 91       	pop	r25
     5b0:	8f 91       	pop	r24
     5b2:	7f 91       	pop	r23
     5b4:	6f 91       	pop	r22
     5b6:	5f 91       	pop	r21
     5b8:	4f 91       	pop	r20
     5ba:	3f 91       	pop	r19
     5bc:	2f 91       	pop	r18
     5be:	0f 90       	pop	r0
     5c0:	0b be       	out	0x3b, r0	; 59
     5c2:	0f 90       	pop	r0
     5c4:	0f be       	out	0x3f, r0	; 63
     5c6:	0f 90       	pop	r0
     5c8:	1f 90       	pop	r1
     5ca:	18 95       	reti

000005cc <_uart0_init>:
* Example Call:		               _uart0_init();
*/

void _uart0_init(void)
{
	UCSR0B = 0x00; //disable while setting baud rate
     5cc:	e1 ec       	ldi	r30, 0xC1	; 193
     5ce:	f0 e0       	ldi	r31, 0x00	; 0
     5d0:	10 82       	st	Z, r1
	UCSR0A = 0x00;
     5d2:	10 92 c0 00 	sts	0x00C0, r1
	UCSR0C = 0x06;//asynchronous usart..........character size:8-bit
     5d6:	86 e0       	ldi	r24, 0x06	; 6
     5d8:	80 93 c2 00 	sts	0x00C2, r24
	//baud rate setting;9600
	UBRR0L = 0x5F; //set baud rate lo
     5dc:	8f e5       	ldi	r24, 0x5F	; 95
     5de:	80 93 c4 00 	sts	0x00C4, r24
	UBRR0H = 0x00; //set baud rate hi
     5e2:	10 92 c5 00 	sts	0x00C5, r1
	UCSR0B = 0x98;
     5e6:	88 e9       	ldi	r24, 0x98	; 152
     5e8:	80 83       	st	Z, r24
}
     5ea:	08 95       	ret

000005ec <_port_init>:
* Example Call:		               _port_init();
*/
void _port_init()
{

	_adc_pinconfig();
     5ec:	0e 94 49 01 	call	0x292	; 0x292 <_adc_pinconfig>
}	
     5f0:	08 95       	ret

000005f2 <_start_collection>:
	* Logic :            NONE
	* Example Call:		 _start_collection();
	*/
void _start_collection()
{
	cli();         //Clears the global interrupt
     5f2:	f8 94       	cli
	_port_init();  //Initializes all the ports
     5f4:	0e 94 f6 02 	call	0x5ec	; 0x5ec <_port_init>
	_timer4_init();
     5f8:	0e 94 c8 01 	call	0x390	; 0x390 <_timer4_init>
	_adc_init();
     5fc:	0e 94 55 01 	call	0x2aa	; 0x2aa <_adc_init>
	_uart0_init(); //Initialize UART0 for wireless serial communication
     600:	0e 94 e6 02 	call	0x5cc	; 0x5cc <_uart0_init>
	TIMSK4 = 0x01; //Timer/Counter 4 Overflow interrupt is enabled
     604:	81 e0       	ldi	r24, 0x01	; 1
     606:	80 93 72 00 	sts	0x0072, r24
	sei();         // Enables the global interrupt
     60a:	78 94       	sei
}
     60c:	08 95       	ret

0000060e <lcd_set_4bit>:
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     60e:	86 e6       	ldi	r24, 0x66	; 102
     610:	9e e0       	ldi	r25, 0x0E	; 14
     612:	01 97       	sbiw	r24, 0x01	; 1
     614:	f1 f7       	brne	.-4      	; 0x612 <lcd_set_4bit+0x4>
     616:	00 00       	nop
//Function to Reset LCD
void lcd_set_4bit()
{
	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
     618:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
     61a:	41 98       	cbi	0x08, 1	; 8
	lcd_port = 0x30;				//Sending 3
     61c:	80 e3       	ldi	r24, 0x30	; 48
     61e:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,EN);				//Set Enable Pin
     620:	42 9a       	sbi	0x08, 2	; 8
     622:	ef ef       	ldi	r30, 0xFF	; 255
     624:	f7 e4       	ldi	r31, 0x47	; 71
     626:	31 97       	sbiw	r30, 0x01	; 1
     628:	f1 f7       	brne	.-4      	; 0x626 <lcd_set_4bit+0x18>
     62a:	00 c0       	rjmp	.+0      	; 0x62c <lcd_set_4bit+0x1e>
     62c:	00 00       	nop
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
     62e:	42 98       	cbi	0x08, 2	; 8
     630:	e6 e6       	ldi	r30, 0x66	; 102
     632:	fe e0       	ldi	r31, 0x0E	; 14
     634:	31 97       	sbiw	r30, 0x01	; 1
     636:	f1 f7       	brne	.-4      	; 0x634 <lcd_set_4bit+0x26>
     638:	00 00       	nop

	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
     63a:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
     63c:	41 98       	cbi	0x08, 1	; 8
	lcd_port = 0x30;				//Sending 3
     63e:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,EN);				//Set Enable Pin
     640:	42 9a       	sbi	0x08, 2	; 8
     642:	ef ef       	ldi	r30, 0xFF	; 255
     644:	f7 e4       	ldi	r31, 0x47	; 71
     646:	31 97       	sbiw	r30, 0x01	; 1
     648:	f1 f7       	brne	.-4      	; 0x646 <lcd_set_4bit+0x38>
     64a:	00 c0       	rjmp	.+0      	; 0x64c <lcd_set_4bit+0x3e>
     64c:	00 00       	nop
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
     64e:	42 98       	cbi	0x08, 2	; 8
     650:	e6 e6       	ldi	r30, 0x66	; 102
     652:	fe e0       	ldi	r31, 0x0E	; 14
     654:	31 97       	sbiw	r30, 0x01	; 1
     656:	f1 f7       	brne	.-4      	; 0x654 <lcd_set_4bit+0x46>
     658:	00 00       	nop

	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
     65a:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
     65c:	41 98       	cbi	0x08, 1	; 8
	lcd_port = 0x30;				//Sending 3
     65e:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,EN);				//Set Enable Pin
     660:	42 9a       	sbi	0x08, 2	; 8
     662:	8f ef       	ldi	r24, 0xFF	; 255
     664:	97 e4       	ldi	r25, 0x47	; 71
     666:	01 97       	sbiw	r24, 0x01	; 1
     668:	f1 f7       	brne	.-4      	; 0x666 <lcd_set_4bit+0x58>
     66a:	00 c0       	rjmp	.+0      	; 0x66c <lcd_set_4bit+0x5e>
     66c:	00 00       	nop
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
     66e:	42 98       	cbi	0x08, 2	; 8
     670:	e6 e6       	ldi	r30, 0x66	; 102
     672:	fe e0       	ldi	r31, 0x0E	; 14
     674:	31 97       	sbiw	r30, 0x01	; 1
     676:	f1 f7       	brne	.-4      	; 0x674 <lcd_set_4bit+0x66>
     678:	00 00       	nop

	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
     67a:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
     67c:	41 98       	cbi	0x08, 1	; 8
	lcd_port = 0x20;				//Sending 2 to initialise LCD 4-bit mode
     67e:	80 e2       	ldi	r24, 0x20	; 32
     680:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,EN);				//Set Enable Pin
     682:	42 9a       	sbi	0x08, 2	; 8
     684:	8f ef       	ldi	r24, 0xFF	; 255
     686:	97 e4       	ldi	r25, 0x47	; 71
     688:	01 97       	sbiw	r24, 0x01	; 1
     68a:	f1 f7       	brne	.-4      	; 0x688 <lcd_set_4bit+0x7a>
     68c:	00 c0       	rjmp	.+0      	; 0x68e <lcd_set_4bit+0x80>
     68e:	00 00       	nop
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
     690:	42 98       	cbi	0x08, 2	; 8

	
}
     692:	08 95       	ret

00000694 <lcd_wr_command>:
void lcd_wr_command(unsigned char cmd)
{
	unsigned char temp;
	temp = cmd;
	temp = temp & 0xF0;
	lcd_port &= 0x0F;
     694:	98 b1       	in	r25, 0x08	; 8
     696:	9f 70       	andi	r25, 0x0F	; 15
     698:	98 b9       	out	0x08, r25	; 8
	lcd_port |= temp;
     69a:	98 b1       	in	r25, 0x08	; 8
//Function to Write Command on LCD
void lcd_wr_command(unsigned char cmd)
{
	unsigned char temp;
	temp = cmd;
	temp = temp & 0xF0;
     69c:	28 2f       	mov	r18, r24
     69e:	20 7f       	andi	r18, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= temp;
     6a0:	92 2b       	or	r25, r18
     6a2:	98 b9       	out	0x08, r25	; 8
	cbit(lcd_port,RS);
     6a4:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);
     6a6:	41 98       	cbi	0x08, 1	; 8
	sbit(lcd_port,EN);
     6a8:	42 9a       	sbi	0x08, 2	; 8
     6aa:	ef ef       	ldi	r30, 0xFF	; 255
     6ac:	f7 e4       	ldi	r31, 0x47	; 71
     6ae:	31 97       	sbiw	r30, 0x01	; 1
     6b0:	f1 f7       	brne	.-4      	; 0x6ae <lcd_wr_command+0x1a>
     6b2:	00 c0       	rjmp	.+0      	; 0x6b4 <lcd_wr_command+0x20>
     6b4:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
     6b6:	42 98       	cbi	0x08, 2	; 8
	
	cmd = cmd & 0x0F;
	cmd = cmd<<4;
	lcd_port &= 0x0F;
     6b8:	98 b1       	in	r25, 0x08	; 8
     6ba:	9f 70       	andi	r25, 0x0F	; 15
     6bc:	98 b9       	out	0x08, r25	; 8
	lcd_port |= cmd;
     6be:	98 b1       	in	r25, 0x08	; 8
	sbit(lcd_port,EN);
	_delay_ms(5);
	cbit(lcd_port,EN);
	
	cmd = cmd & 0x0F;
	cmd = cmd<<4;
     6c0:	82 95       	swap	r24
     6c2:	80 7f       	andi	r24, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= cmd;
     6c4:	89 2b       	or	r24, r25
     6c6:	88 b9       	out	0x08, r24	; 8
	cbit(lcd_port,RS);
     6c8:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);
     6ca:	41 98       	cbi	0x08, 1	; 8
	sbit(lcd_port,EN);
     6cc:	42 9a       	sbi	0x08, 2	; 8
     6ce:	8f ef       	ldi	r24, 0xFF	; 255
     6d0:	97 e4       	ldi	r25, 0x47	; 71
     6d2:	01 97       	sbiw	r24, 0x01	; 1
     6d4:	f1 f7       	brne	.-4      	; 0x6d2 <lcd_wr_command+0x3e>
     6d6:	00 c0       	rjmp	.+0      	; 0x6d8 <lcd_wr_command+0x44>
     6d8:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
     6da:	42 98       	cbi	0x08, 2	; 8
}
     6dc:	08 95       	ret

000006de <lcd_init>:
}

//Function to Initialize LCD
void lcd_init()
{
	lcd_set_4bit();
     6de:	0e 94 07 03 	call	0x60e	; 0x60e <lcd_set_4bit>
     6e2:	86 e6       	ldi	r24, 0x66	; 102
     6e4:	9e e0       	ldi	r25, 0x0E	; 14
     6e6:	01 97       	sbiw	r24, 0x01	; 1
     6e8:	f1 f7       	brne	.-4      	; 0x6e6 <lcd_init+0x8>
     6ea:	00 00       	nop
	_delay_ms(1);

	lcd_wr_command(0x28);			//LCD 4-bit mode and 2 lines.
     6ec:	88 e2       	ldi	r24, 0x28	; 40
     6ee:	0e 94 4a 03 	call	0x694	; 0x694 <lcd_wr_command>
	lcd_wr_command(0x01);
     6f2:	81 e0       	ldi	r24, 0x01	; 1
     6f4:	0e 94 4a 03 	call	0x694	; 0x694 <lcd_wr_command>
	lcd_wr_command(0x06);
     6f8:	86 e0       	ldi	r24, 0x06	; 6
     6fa:	0e 94 4a 03 	call	0x694	; 0x694 <lcd_wr_command>
	lcd_wr_command(0x0E);
     6fe:	8e e0       	ldi	r24, 0x0E	; 14
     700:	0e 94 4a 03 	call	0x694	; 0x694 <lcd_wr_command>
	lcd_wr_command(0x80);
     704:	80 e8       	ldi	r24, 0x80	; 128
     706:	0e 94 4a 03 	call	0x694	; 0x694 <lcd_wr_command>
		
}
     70a:	08 95       	ret

0000070c <lcd_wr_char>:
void lcd_wr_char(char letter)
{
	char temp;
	temp = letter;
	temp = (temp & 0xF0);
	lcd_port &= 0x0F;
     70c:	98 b1       	in	r25, 0x08	; 8
     70e:	9f 70       	andi	r25, 0x0F	; 15
     710:	98 b9       	out	0x08, r25	; 8
	lcd_port |= temp;
     712:	98 b1       	in	r25, 0x08	; 8
//Function to Write Data on LCD
void lcd_wr_char(char letter)
{
	char temp;
	temp = letter;
	temp = (temp & 0xF0);
     714:	28 2f       	mov	r18, r24
     716:	20 7f       	andi	r18, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= temp;
     718:	92 2b       	or	r25, r18
     71a:	98 b9       	out	0x08, r25	; 8
	sbit(lcd_port,RS);
     71c:	40 9a       	sbi	0x08, 0	; 8
	cbit(lcd_port,RW);
     71e:	41 98       	cbi	0x08, 1	; 8
	sbit(lcd_port,EN);
     720:	42 9a       	sbi	0x08, 2	; 8
     722:	ef ef       	ldi	r30, 0xFF	; 255
     724:	f7 e4       	ldi	r31, 0x47	; 71
     726:	31 97       	sbiw	r30, 0x01	; 1
     728:	f1 f7       	brne	.-4      	; 0x726 <lcd_wr_char+0x1a>
     72a:	00 c0       	rjmp	.+0      	; 0x72c <lcd_wr_char+0x20>
     72c:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
     72e:	42 98       	cbi	0x08, 2	; 8

	letter = letter & 0x0F;
	letter = letter<<4;
	lcd_port &= 0x0F;
     730:	98 b1       	in	r25, 0x08	; 8
     732:	9f 70       	andi	r25, 0x0F	; 15
     734:	98 b9       	out	0x08, r25	; 8
	lcd_port |= letter;
     736:	98 b1       	in	r25, 0x08	; 8
	sbit(lcd_port,EN);
	_delay_ms(5);
	cbit(lcd_port,EN);

	letter = letter & 0x0F;
	letter = letter<<4;
     738:	82 95       	swap	r24
     73a:	80 7f       	andi	r24, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= letter;
     73c:	89 2b       	or	r24, r25
     73e:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,RS);
     740:	40 9a       	sbi	0x08, 0	; 8
	cbit(lcd_port,RW);
     742:	41 98       	cbi	0x08, 1	; 8
	sbit(lcd_port,EN);
     744:	42 9a       	sbi	0x08, 2	; 8
     746:	8f ef       	ldi	r24, 0xFF	; 255
     748:	97 e4       	ldi	r25, 0x47	; 71
     74a:	01 97       	sbiw	r24, 0x01	; 1
     74c:	f1 f7       	brne	.-4      	; 0x74a <lcd_wr_char+0x3e>
     74e:	00 c0       	rjmp	.+0      	; 0x750 <lcd_wr_char+0x44>
     750:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
     752:	42 98       	cbi	0x08, 2	; 8
}
     754:	08 95       	ret

00000756 <lcd_home>:


//Function to bring cursor at home position
void lcd_home()
{
	lcd_wr_command(0x80);
     756:	80 e8       	ldi	r24, 0x80	; 128
     758:	0e 94 4a 03 	call	0x694	; 0x694 <lcd_wr_command>
}
     75c:	08 95       	ret

0000075e <lcd_string>:


//Function to Print String on LCD
void lcd_string(char *str)
{
     75e:	cf 93       	push	r28
     760:	df 93       	push	r29
     762:	ec 01       	movw	r28, r24
	while(*str != '\0')
     764:	88 81       	ld	r24, Y
     766:	88 23       	and	r24, r24
     768:	31 f0       	breq	.+12     	; 0x776 <lcd_string+0x18>
	lcd_wr_command(0x80);
}


//Function to Print String on LCD
void lcd_string(char *str)
     76a:	21 96       	adiw	r28, 0x01	; 1
{
	while(*str != '\0')
	{
		lcd_wr_char(*str);
     76c:	0e 94 86 03 	call	0x70c	; 0x70c <lcd_wr_char>


//Function to Print String on LCD
void lcd_string(char *str)
{
	while(*str != '\0')
     770:	89 91       	ld	r24, Y+
     772:	88 23       	and	r24, r24
     774:	d9 f7       	brne	.-10     	; 0x76c <lcd_string+0xe>
	{
		lcd_wr_char(*str);
		str++;
	}
}
     776:	df 91       	pop	r29
     778:	cf 91       	pop	r28
     77a:	08 95       	ret

0000077c <lcd_cursor>:

//Position the LCD cursor at "row", "column".

void lcd_cursor (char row, char column)
{
	switch (row) {
     77c:	82 30       	cpi	r24, 0x02	; 2
     77e:	79 f0       	breq	.+30     	; 0x79e <lcd_cursor+0x22>
     780:	83 30       	cpi	r24, 0x03	; 3
     782:	18 f4       	brcc	.+6      	; 0x78a <lcd_cursor+0xe>
     784:	81 30       	cpi	r24, 0x01	; 1
     786:	c9 f4       	brne	.+50     	; 0x7ba <lcd_cursor+0x3e>
     788:	05 c0       	rjmp	.+10     	; 0x794 <lcd_cursor+0x18>
     78a:	83 30       	cpi	r24, 0x03	; 3
     78c:	69 f0       	breq	.+26     	; 0x7a8 <lcd_cursor+0x2c>
     78e:	84 30       	cpi	r24, 0x04	; 4
     790:	a1 f4       	brne	.+40     	; 0x7ba <lcd_cursor+0x3e>
     792:	0f c0       	rjmp	.+30     	; 0x7b2 <lcd_cursor+0x36>
		case 1: lcd_wr_command (0x80 + column - 1); break;
     794:	86 2f       	mov	r24, r22
     796:	81 58       	subi	r24, 0x81	; 129
     798:	0e 94 4a 03 	call	0x694	; 0x694 <lcd_wr_command>
     79c:	08 95       	ret
		case 2: lcd_wr_command (0xc0 + column - 1); break;
     79e:	86 2f       	mov	r24, r22
     7a0:	81 54       	subi	r24, 0x41	; 65
     7a2:	0e 94 4a 03 	call	0x694	; 0x694 <lcd_wr_command>
     7a6:	08 95       	ret
		case 3: lcd_wr_command (0x94 + column - 1); break;
     7a8:	86 2f       	mov	r24, r22
     7aa:	8d 56       	subi	r24, 0x6D	; 109
     7ac:	0e 94 4a 03 	call	0x694	; 0x694 <lcd_wr_command>
     7b0:	08 95       	ret
		case 4: lcd_wr_command (0xd4 + column - 1); break;
     7b2:	86 2f       	mov	r24, r22
     7b4:	8d 52       	subi	r24, 0x2D	; 45
     7b6:	0e 94 4a 03 	call	0x694	; 0x694 <lcd_wr_command>
     7ba:	08 95       	ret

000007bc <lcd_print>:
	}
}

//Function To Print Any input value upto the desired digit on LCD
void lcd_print (char row, char coloumn, unsigned int value, int digits)
{
     7bc:	0f 93       	push	r16
     7be:	1f 93       	push	r17
     7c0:	cf 93       	push	r28
     7c2:	df 93       	push	r29
     7c4:	8a 01       	movw	r16, r20
     7c6:	e9 01       	movw	r28, r18
	unsigned char flag=0;
	if(row==0||coloumn==0)
     7c8:	88 23       	and	r24, r24
     7ca:	11 f0       	breq	.+4      	; 0x7d0 <lcd_print+0x14>
     7cc:	66 23       	and	r22, r22
     7ce:	19 f4       	brne	.+6      	; 0x7d6 <lcd_print+0x1a>
	{
		lcd_home();
     7d0:	0e 94 ab 03 	call	0x756	; 0x756 <lcd_home>
     7d4:	02 c0       	rjmp	.+4      	; 0x7da <lcd_print+0x1e>
	}
	else
	{
		lcd_cursor(row,coloumn);
     7d6:	0e 94 be 03 	call	0x77c	; 0x77c <lcd_cursor>
	}
	if(digits==5 || flag==1)
     7da:	c5 30       	cpi	r28, 0x05	; 5
     7dc:	d1 05       	cpc	r29, r1
     7de:	71 f4       	brne	.+28     	; 0x7fc <lcd_print+0x40>
	{
		million=value/10000+48;
     7e0:	c8 01       	movw	r24, r16
     7e2:	60 e1       	ldi	r22, 0x10	; 16
     7e4:	77 e2       	ldi	r23, 0x27	; 39
     7e6:	0e 94 5e 1b 	call	0x36bc	; 0x36bc <__udivmodhi4>
     7ea:	cb 01       	movw	r24, r22
     7ec:	c0 96       	adiw	r24, 0x30	; 48
     7ee:	90 93 af 02 	sts	0x02AF, r25
     7f2:	80 93 ae 02 	sts	0x02AE, r24
		lcd_wr_char(million);
     7f6:	0e 94 86 03 	call	0x70c	; 0x70c <lcd_wr_char>
     7fa:	03 c0       	rjmp	.+6      	; 0x802 <lcd_print+0x46>
		flag=1;
	}
	if(digits==4 || flag==1)
     7fc:	c4 30       	cpi	r28, 0x04	; 4
     7fe:	d1 05       	cpc	r29, r1
     800:	b9 f4       	brne	.+46     	; 0x830 <lcd_print+0x74>
	{
		temp = value/1000;
     802:	c8 01       	movw	r24, r16
     804:	68 ee       	ldi	r22, 0xE8	; 232
     806:	73 e0       	ldi	r23, 0x03	; 3
     808:	0e 94 5e 1b 	call	0x36bc	; 0x36bc <__udivmodhi4>
     80c:	cb 01       	movw	r24, r22
     80e:	70 93 b2 02 	sts	0x02B2, r23
     812:	60 93 b1 02 	sts	0x02B1, r22
		thousand = temp%10 + 48;
     816:	6a e0       	ldi	r22, 0x0A	; 10
     818:	70 e0       	ldi	r23, 0x00	; 0
     81a:	0e 94 5e 1b 	call	0x36bc	; 0x36bc <__udivmodhi4>
     81e:	c0 96       	adiw	r24, 0x30	; 48
     820:	90 93 63 05 	sts	0x0563, r25
     824:	80 93 62 05 	sts	0x0562, r24
		lcd_wr_char(thousand);
     828:	0e 94 86 03 	call	0x70c	; 0x70c <lcd_wr_char>
		flag=1;
     82c:	81 e0       	ldi	r24, 0x01	; 1
     82e:	01 c0       	rjmp	.+2      	; 0x832 <lcd_print+0x76>
}

//Function To Print Any input value upto the desired digit on LCD
void lcd_print (char row, char coloumn, unsigned int value, int digits)
{
	unsigned char flag=0;
     830:	80 e0       	ldi	r24, 0x00	; 0
		temp = value/1000;
		thousand = temp%10 + 48;
		lcd_wr_char(thousand);
		flag=1;
	}
	if(digits==3 || flag==1)
     832:	c3 30       	cpi	r28, 0x03	; 3
     834:	d1 05       	cpc	r29, r1
     836:	11 f0       	breq	.+4      	; 0x83c <lcd_print+0x80>
     838:	81 30       	cpi	r24, 0x01	; 1
     83a:	b1 f4       	brne	.+44     	; 0x868 <lcd_print+0xac>
	{
		temp = value/100;
     83c:	c8 01       	movw	r24, r16
     83e:	64 e6       	ldi	r22, 0x64	; 100
     840:	70 e0       	ldi	r23, 0x00	; 0
     842:	0e 94 5e 1b 	call	0x36bc	; 0x36bc <__udivmodhi4>
     846:	cb 01       	movw	r24, r22
     848:	70 93 b2 02 	sts	0x02B2, r23
     84c:	60 93 b1 02 	sts	0x02B1, r22
		hundred = temp%10 + 48;
     850:	6a e0       	ldi	r22, 0x0A	; 10
     852:	70 e0       	ldi	r23, 0x00	; 0
     854:	0e 94 5e 1b 	call	0x36bc	; 0x36bc <__udivmodhi4>
     858:	c0 96       	adiw	r24, 0x30	; 48
     85a:	90 93 39 05 	sts	0x0539, r25
     85e:	80 93 38 05 	sts	0x0538, r24
		lcd_wr_char(hundred);
     862:	0e 94 86 03 	call	0x70c	; 0x70c <lcd_wr_char>
		flag=1;
     866:	81 e0       	ldi	r24, 0x01	; 1
	}
	if(digits==2 || flag==1)
     868:	c2 30       	cpi	r28, 0x02	; 2
     86a:	d1 05       	cpc	r29, r1
     86c:	11 f0       	breq	.+4      	; 0x872 <lcd_print+0xb6>
     86e:	81 30       	cpi	r24, 0x01	; 1
     870:	b1 f4       	brne	.+44     	; 0x89e <lcd_print+0xe2>
	{
		temp = value/10;
     872:	2a e0       	ldi	r18, 0x0A	; 10
     874:	30 e0       	ldi	r19, 0x00	; 0
     876:	c8 01       	movw	r24, r16
     878:	b9 01       	movw	r22, r18
     87a:	0e 94 5e 1b 	call	0x36bc	; 0x36bc <__udivmodhi4>
     87e:	cb 01       	movw	r24, r22
     880:	70 93 b2 02 	sts	0x02B2, r23
     884:	60 93 b1 02 	sts	0x02B1, r22
		tens = temp%10 + 48;
     888:	b9 01       	movw	r22, r18
     88a:	0e 94 5e 1b 	call	0x36bc	; 0x36bc <__udivmodhi4>
     88e:	c0 96       	adiw	r24, 0x30	; 48
     890:	90 93 30 05 	sts	0x0530, r25
     894:	80 93 2f 05 	sts	0x052F, r24
		lcd_wr_char(tens);
     898:	0e 94 86 03 	call	0x70c	; 0x70c <lcd_wr_char>
		flag=1;
     89c:	81 e0       	ldi	r24, 0x01	; 1
	}
	if(digits==1 || flag==1)
     89e:	c1 30       	cpi	r28, 0x01	; 1
     8a0:	d1 05       	cpc	r29, r1
     8a2:	11 f0       	breq	.+4      	; 0x8a8 <lcd_print+0xec>
     8a4:	81 30       	cpi	r24, 0x01	; 1
     8a6:	61 f4       	brne	.+24     	; 0x8c0 <lcd_print+0x104>
	{
		unit = value%10 + 48;
     8a8:	c8 01       	movw	r24, r16
     8aa:	6a e0       	ldi	r22, 0x0A	; 10
     8ac:	70 e0       	ldi	r23, 0x00	; 0
     8ae:	0e 94 5e 1b 	call	0x36bc	; 0x36bc <__udivmodhi4>
     8b2:	c0 96       	adiw	r24, 0x30	; 48
     8b4:	90 93 61 05 	sts	0x0561, r25
     8b8:	80 93 60 05 	sts	0x0560, r24
		lcd_wr_char(unit);
     8bc:	0e 94 86 03 	call	0x70c	; 0x70c <lcd_wr_char>
	}
	if(digits>5)
     8c0:	c6 30       	cpi	r28, 0x06	; 6
     8c2:	d1 05       	cpc	r29, r1
     8c4:	1c f0       	brlt	.+6      	; 0x8cc <lcd_print+0x110>
	{
		lcd_wr_char('E');
     8c6:	85 e4       	ldi	r24, 0x45	; 69
     8c8:	0e 94 86 03 	call	0x70c	; 0x70c <lcd_wr_char>
	}
	
}
     8cc:	df 91       	pop	r29
     8ce:	cf 91       	pop	r28
     8d0:	1f 91       	pop	r17
     8d2:	0f 91       	pop	r16
     8d4:	08 95       	ret

000008d6 <navigate>:
*
*/

void navigate(void) 
{
	cli();
     8d6:	f8 94       	cli
	if(navigation_in_degrees==0)
     8d8:	80 91 3d 02 	lds	r24, 0x023D
     8dc:	90 91 3e 02 	lds	r25, 0x023E
     8e0:	00 97       	sbiw	r24, 0x00	; 0
     8e2:	39 f4       	brne	.+14     	; 0x8f2 <navigate+0x1c>
	navigation_pointer="East ";
     8e4:	80 e0       	ldi	r24, 0x00	; 0
     8e6:	92 e0       	ldi	r25, 0x02	; 2
     8e8:	90 93 ad 02 	sts	0x02AD, r25
     8ec:	80 93 ac 02 	sts	0x02AC, r24
     8f0:	39 c0       	rjmp	.+114    	; 0x964 <navigate+0x8e>
	else if(abs(navigation_in_degrees)==270)
     8f2:	9c 01       	movw	r18, r24
     8f4:	99 23       	and	r25, r25
     8f6:	24 f4       	brge	.+8      	; 0x900 <navigate+0x2a>
     8f8:	22 27       	eor	r18, r18
     8fa:	33 27       	eor	r19, r19
     8fc:	28 1b       	sub	r18, r24
     8fe:	39 0b       	sbc	r19, r25
     900:	41 e0       	ldi	r20, 0x01	; 1
     902:	2e 30       	cpi	r18, 0x0E	; 14
     904:	34 07       	cpc	r19, r20
     906:	89 f4       	brne	.+34     	; 0x92a <navigate+0x54>
	{
		if(navigation_in_degrees>0)
     908:	18 16       	cp	r1, r24
     90a:	19 06       	cpc	r1, r25
     90c:	3c f4       	brge	.+14     	; 0x91c <navigate+0x46>
		navigation_pointer="South";
     90e:	86 e0       	ldi	r24, 0x06	; 6
     910:	92 e0       	ldi	r25, 0x02	; 2
     912:	90 93 ad 02 	sts	0x02AD, r25
     916:	80 93 ac 02 	sts	0x02AC, r24
     91a:	24 c0       	rjmp	.+72     	; 0x964 <navigate+0x8e>
		else
		navigation_pointer="North";
     91c:	8c e0       	ldi	r24, 0x0C	; 12
     91e:	92 e0       	ldi	r25, 0x02	; 2
     920:	90 93 ad 02 	sts	0x02AD, r25
     924:	80 93 ac 02 	sts	0x02AC, r24
     928:	1d c0       	rjmp	.+58     	; 0x964 <navigate+0x8e>
	}
	else if(abs(navigation_in_degrees)==180)
     92a:	24 3b       	cpi	r18, 0xB4	; 180
     92c:	31 05       	cpc	r19, r1
     92e:	39 f4       	brne	.+14     	; 0x93e <navigate+0x68>
	{
		navigation_pointer="West ";
     930:	82 e1       	ldi	r24, 0x12	; 18
     932:	92 e0       	ldi	r25, 0x02	; 2
     934:	90 93 ad 02 	sts	0x02AD, r25
     938:	80 93 ac 02 	sts	0x02AC, r24
     93c:	13 c0       	rjmp	.+38     	; 0x964 <navigate+0x8e>
	}
	else if(abs(navigation_in_degrees)==90)
     93e:	2a 35       	cpi	r18, 0x5A	; 90
     940:	31 05       	cpc	r19, r1
     942:	81 f4       	brne	.+32     	; 0x964 <navigate+0x8e>
	{
		if(navigation_in_degrees>0)
     944:	18 16       	cp	r1, r24
     946:	19 06       	cpc	r1, r25
     948:	3c f4       	brge	.+14     	; 0x958 <navigate+0x82>
		navigation_pointer="North";
     94a:	8c e0       	ldi	r24, 0x0C	; 12
     94c:	92 e0       	ldi	r25, 0x02	; 2
     94e:	90 93 ad 02 	sts	0x02AD, r25
     952:	80 93 ac 02 	sts	0x02AC, r24
     956:	06 c0       	rjmp	.+12     	; 0x964 <navigate+0x8e>
		else
		navigation_pointer="South";
     958:	86 e0       	ldi	r24, 0x06	; 6
     95a:	92 e0       	ldi	r25, 0x02	; 2
     95c:	90 93 ad 02 	sts	0x02AD, r25
     960:	80 93 ac 02 	sts	0x02AC, r24
	}
	lcd_cursor(2,12);
     964:	82 e0       	ldi	r24, 0x02	; 2
     966:	6c e0       	ldi	r22, 0x0C	; 12
     968:	0e 94 be 03 	call	0x77c	; 0x77c <lcd_cursor>
	lcd_string(navigation_pointer);
     96c:	80 91 ac 02 	lds	r24, 0x02AC
     970:	90 91 ad 02 	lds	r25, 0x02AD
     974:	0e 94 af 03 	call	0x75e	; 0x75e <lcd_string>
	lcd_cursor(2,1);
     978:	82 e0       	ldi	r24, 0x02	; 2
     97a:	61 e0       	ldi	r22, 0x01	; 1
     97c:	0e 94 be 03 	call	0x77c	; 0x77c <lcd_cursor>
	lcd_string("Node:-");
     980:	88 e1       	ldi	r24, 0x18	; 24
     982:	92 e0       	ldi	r25, 0x02	; 2
     984:	0e 94 af 03 	call	0x75e	; 0x75e <lcd_string>
	lcd_print(2,7,node_number,2);
     988:	40 91 5f 02 	lds	r20, 0x025F
     98c:	50 91 60 02 	lds	r21, 0x0260
     990:	82 e0       	ldi	r24, 0x02	; 2
     992:	67 e0       	ldi	r22, 0x07	; 7
     994:	22 e0       	ldi	r18, 0x02	; 2
     996:	30 e0       	ldi	r19, 0x00	; 0
     998:	0e 94 de 03 	call	0x7bc	; 0x7bc <lcd_print>
	lcd_cursor(1,1);
     99c:	81 e0       	ldi	r24, 0x01	; 1
     99e:	61 e0       	ldi	r22, 0x01	; 1
     9a0:	0e 94 be 03 	call	0x77c	; 0x77c <lcd_cursor>
	lcd_string("A:");
     9a4:	8f e1       	ldi	r24, 0x1F	; 31
     9a6:	92 e0       	ldi	r25, 0x02	; 2
     9a8:	0e 94 af 03 	call	0x75e	; 0x75e <lcd_string>
	lcd_print(1,3,deposition_zone_A,1);
     9ac:	40 91 3b 02 	lds	r20, 0x023B
     9b0:	50 91 3c 02 	lds	r21, 0x023C
     9b4:	81 e0       	ldi	r24, 0x01	; 1
     9b6:	63 e0       	ldi	r22, 0x03	; 3
     9b8:	21 e0       	ldi	r18, 0x01	; 1
     9ba:	30 e0       	ldi	r19, 0x00	; 0
     9bc:	0e 94 de 03 	call	0x7bc	; 0x7bc <lcd_print>
	lcd_wr_char(' ');
     9c0:	80 e2       	ldi	r24, 0x20	; 32
     9c2:	0e 94 86 03 	call	0x70c	; 0x70c <lcd_wr_char>
	lcd_string("B:");
     9c6:	82 e2       	ldi	r24, 0x22	; 34
     9c8:	92 e0       	ldi	r25, 0x02	; 2
     9ca:	0e 94 af 03 	call	0x75e	; 0x75e <lcd_string>
	lcd_print(1,7,deposition_zone_B,1);
     9ce:	40 91 39 02 	lds	r20, 0x0239
     9d2:	50 91 3a 02 	lds	r21, 0x023A
     9d6:	81 e0       	ldi	r24, 0x01	; 1
     9d8:	67 e0       	ldi	r22, 0x07	; 7
     9da:	21 e0       	ldi	r18, 0x01	; 1
     9dc:	30 e0       	ldi	r19, 0x00	; 0
     9de:	0e 94 de 03 	call	0x7bc	; 0x7bc <lcd_print>
	lcd_wr_char(' ');
     9e2:	80 e2       	ldi	r24, 0x20	; 32
     9e4:	0e 94 86 03 	call	0x70c	; 0x70c <lcd_wr_char>
	lcd_string("C:");
     9e8:	85 e2       	ldi	r24, 0x25	; 37
     9ea:	92 e0       	ldi	r25, 0x02	; 2
     9ec:	0e 94 af 03 	call	0x75e	; 0x75e <lcd_string>
	lcd_print(1,11,deposition_zone_C,1);
     9f0:	40 91 37 02 	lds	r20, 0x0237
     9f4:	50 91 38 02 	lds	r21, 0x0238
     9f8:	81 e0       	ldi	r24, 0x01	; 1
     9fa:	6b e0       	ldi	r22, 0x0B	; 11
     9fc:	21 e0       	ldi	r18, 0x01	; 1
     9fe:	30 e0       	ldi	r19, 0x00	; 0
     a00:	0e 94 de 03 	call	0x7bc	; 0x7bc <lcd_print>
	lcd_wr_char(' ');
     a04:	80 e2       	ldi	r24, 0x20	; 32
     a06:	0e 94 86 03 	call	0x70c	; 0x70c <lcd_wr_char>
	lcd_string("I:");
     a0a:	88 e2       	ldi	r24, 0x28	; 40
     a0c:	92 e0       	ldi	r25, 0x02	; 2
     a0e:	0e 94 af 03 	call	0x75e	; 0x75e <lcd_string>
	lcd_print(1,15,IP,1);
     a12:	40 91 35 02 	lds	r20, 0x0235
     a16:	50 91 36 02 	lds	r21, 0x0236
     a1a:	81 e0       	ldi	r24, 0x01	; 1
     a1c:	6f e0       	ldi	r22, 0x0F	; 15
     a1e:	21 e0       	ldi	r18, 0x01	; 1
     a20:	30 e0       	ldi	r19, 0x00	; 0
     a22:	0e 94 de 03 	call	0x7bc	; 0x7bc <lcd_print>
	lcd_wr_char(' ');
     a26:	80 e2       	ldi	r24, 0x20	; 32
     a28:	0e 94 86 03 	call	0x70c	; 0x70c <lcd_wr_char>
	sei();
     a2c:	78 94       	sei
}
     a2e:	08 95       	ret

00000a30 <struct_config>:
*
*/

void struct_config(void)
{
	cli();                       // Clears the global interrupt
     a30:	f8 94       	cli
	def();						 // User defined function which gives null value to all the nodes of the arena
     a32:	0e 94 d6 00 	call	0x1ac	; 0x1ac <def>
	graph[0][1]='N';
     a36:	2e e4       	ldi	r18, 0x4E	; 78
     a38:	20 93 be 02 	sts	0x02BE, r18
	graph[0][2]='S';
     a3c:	33 e5       	ldi	r19, 0x53	; 83
     a3e:	30 93 bf 02 	sts	0x02BF, r19
	graph[0][6]='E';
     a42:	95 e4       	ldi	r25, 0x45	; 69
     a44:	90 93 c3 02 	sts	0x02C3, r25
	graph[0][10]='W';
     a48:	87 e5       	ldi	r24, 0x57	; 87
     a4a:	80 93 c7 02 	sts	0x02C7, r24
	graph[1][0]='S';
     a4e:	30 93 d6 02 	sts	0x02D6, r19
	graph[2][0]='N';
     a52:	20 93 ef 02 	sts	0x02EF, r18
	graph[2][3]='S';
     a56:	30 93 f2 02 	sts	0x02F2, r19
	graph[2][4]='W';
     a5a:	80 93 f3 02 	sts	0x02F3, r24
	graph[3][2]='N';
     a5e:	20 93 0a 03 	sts	0x030A, r18
	graph[3][5]='W';
     a62:	80 93 0d 03 	sts	0x030D, r24
	graph[4][2]='E';
     a66:	90 93 23 03 	sts	0x0323, r25
	graph[5][3]='E';
     a6a:	90 93 3d 03 	sts	0x033D, r25
	graph[6][0]='W';
     a6e:	80 93 53 03 	sts	0x0353, r24
	graph[6][19]='N';
     a72:	20 93 66 03 	sts	0x0366, r18
	graph[6][18]='S';
     a76:	30 93 65 03 	sts	0x0365, r19
	graph[7][19]='W';
     a7a:	80 93 7f 03 	sts	0x037F, r24
	graph[7][20]='E';
     a7e:	90 93 80 03 	sts	0x0380, r25
	graph[8][20]='N';
     a82:	20 93 99 03 	sts	0x0399, r18
	graph[9][18]='W';
     a86:	80 93 b0 03 	sts	0x03B0, r24
	graph[10][0]='E';
     a8a:	90 93 b7 03 	sts	0x03B7, r25
	graph[10][11]='N';
     a8e:	20 93 c2 03 	sts	0x03C2, r18
	graph[10][13]='S';
     a92:	30 93 c4 03 	sts	0x03C4, r19
	graph[10][16]='W';
     a96:	80 93 c7 03 	sts	0x03C7, r24
	graph[11][14]='E';
     a9a:	90 93 de 03 	sts	0x03DE, r25
	graph[11][10]='S';
     a9e:	30 93 da 03 	sts	0x03DA, r19
	graph[11][12]='N';
     aa2:	20 93 dc 03 	sts	0x03DC, r18
	graph[12][15]='W';
     aa6:	80 93 f8 03 	sts	0x03F8, r24
	graph[12][11]='S';
     aaa:	30 93 f4 03 	sts	0x03F4, r19
	graph[13][10]='N';
     aae:	20 93 0c 04 	sts	0x040C, r18
	graph[13][17]='W';
     ab2:	80 93 13 04 	sts	0x0413, r24
	graph[14][11]='W';
     ab6:	80 93 26 04 	sts	0x0426, r24
	graph[15][12]='E';
     aba:	90 93 40 04 	sts	0x0440, r25
	graph[16][10]='E';
     abe:	90 93 57 04 	sts	0x0457, r25
	graph[17][13]='E';
     ac2:	90 93 73 04 	sts	0x0473, r25
	graph[19][7]='E';
     ac6:	90 93 9f 04 	sts	0x049F, r25
	graph[19][6]='S';
     aca:	30 93 9e 04 	sts	0x049E, r19
	graph[18][6]='N';
     ace:	20 93 85 04 	sts	0x0485, r18
	graph[18][9]='E';
     ad2:	90 93 88 04 	sts	0x0488, r25
	graph[20][8]='S';
     ad6:	30 93 b9 04 	sts	0x04B9, r19
	graph[20][7]='W';
     ada:	80 93 b8 04 	sts	0x04B8, r24
	graph[7][21]='N';
     ade:	20 93 81 03 	sts	0x0381, r18
	graph[8][22]='E';
     ae2:	90 93 9b 03 	sts	0x039B, r25
	graph[9][23]='S';
     ae6:	30 93 b5 03 	sts	0x03B5, r19
	graph[21][7]='S';
     aea:	30 93 d1 04 	sts	0x04D1, r19
	graph[22][8]='W';
     aee:	80 93 eb 04 	sts	0x04EB, r24
	graph[23][9]='N';
     af2:	20 93 05 05 	sts	0x0505, r18
	sei();					//Enables all the global interrupt
     af6:	78 94       	sei
}
     af8:	08 95       	ret

00000afa <path_logic>:
* Example Call:		path_logic(7,10);
*
*/

int path_logic(int curr_node, int req_node) 
{
     afa:	8f 92       	push	r8
     afc:	9f 92       	push	r9
     afe:	af 92       	push	r10
     b00:	bf 92       	push	r11
     b02:	cf 92       	push	r12
     b04:	df 92       	push	r13
     b06:	ef 92       	push	r14
     b08:	ff 92       	push	r15
     b0a:	0f 93       	push	r16
     b0c:	1f 93       	push	r17
     b0e:	cf 93       	push	r28
     b10:	df 93       	push	r29
     b12:	5c 01       	movw	r10, r24
     b14:	4b 01       	movw	r8, r22
	if(curr_node==req_node && found==0)  //found is the variable to check the bot's traversal
     b16:	86 17       	cp	r24, r22
     b18:	97 07       	cpc	r25, r23
     b1a:	69 f4       	brne	.+26     	; 0xb36 <path_logic+0x3c>
     b1c:	80 91 5d 05 	lds	r24, 0x055D
     b20:	90 91 5e 05 	lds	r25, 0x055E
     b24:	00 97       	sbiw	r24, 0x00	; 0
     b26:	39 f4       	brne	.+14     	; 0xb36 <path_logic+0x3c>
	{
		found++;
     b28:	81 e0       	ldi	r24, 0x01	; 1
     b2a:	90 e0       	ldi	r25, 0x00	; 0
     b2c:	90 93 5e 05 	sts	0x055E, r25
     b30:	80 93 5d 05 	sts	0x055D, r24
		return(1);
     b34:	51 c0       	rjmp	.+162    	; 0xbd8 <path_logic+0xde>
					According to that it updates the path string(global variable)
* Example Call:		path_logic(7,10);
*
*/

int path_logic(int curr_node, int req_node) 
     b36:	85 01       	movw	r16, r10
     b38:	00 0f       	add	r16, r16
     b3a:	11 1f       	adc	r17, r17
     b3c:	0a 0d       	add	r16, r10
     b3e:	1b 1d       	adc	r17, r11
     b40:	00 0f       	add	r16, r16
     b42:	11 1f       	adc	r17, r17
     b44:	00 0f       	add	r16, r16
     b46:	11 1f       	adc	r17, r17
     b48:	00 0f       	add	r16, r16
     b4a:	11 1f       	adc	r17, r17
     b4c:	0a 0d       	add	r16, r10
     b4e:	1b 1d       	adc	r17, r11
     b50:	03 54       	subi	r16, 0x43	; 67
     b52:	1d 4f       	sbci	r17, 0xFD	; 253
     b54:	ee 24       	eor	r14, r14
     b56:	ff 24       	eor	r15, r15
     b58:	c0 e0       	ldi	r28, 0x00	; 0
     b5a:	d0 e0       	ldi	r29, 0x00	; 0
	//j: will iterate from 0 to the maximum nodes (maximum_number_of_nodes is the constant for the maximum number of nodes in the arena )
	for(j=0;j<maximum_number_of_nodes;j++)
	{
		if(graph[curr_node][j]!='\0' && previous_node!=j)
		{
			p[path_index]=graph[curr_node][j];  //path index -> index of the path string
     b5c:	0f 2e       	mov	r0, r31
     b5e:	fa e8       	ldi	r31, 0x8A	; 138
     b60:	cf 2e       	mov	r12, r31
     b62:	f2 e0       	ldi	r31, 0x02	; 2
     b64:	df 2e       	mov	r13, r31
     b66:	f0 2d       	mov	r31, r0
	int j,r=0;							//r stores the value of return
	
	//j: will iterate from 0 to the maximum nodes (maximum_number_of_nodes is the constant for the maximum number of nodes in the arena )
	for(j=0;j<maximum_number_of_nodes;j++)
	{
		if(graph[curr_node][j]!='\0' && previous_node!=j)
     b68:	f8 01       	movw	r30, r16
     b6a:	21 91       	ld	r18, Z+
     b6c:	8f 01       	movw	r16, r30
     b6e:	22 23       	and	r18, r18
     b70:	f1 f0       	breq	.+60     	; 0xbae <path_logic+0xb4>
     b72:	80 91 31 05 	lds	r24, 0x0531
     b76:	90 91 32 05 	lds	r25, 0x0532
     b7a:	8c 17       	cp	r24, r28
     b7c:	9d 07       	cpc	r25, r29
     b7e:	b9 f0       	breq	.+46     	; 0xbae <path_logic+0xb4>
		{
			p[path_index]=graph[curr_node][j];  //path index -> index of the path string
     b80:	80 91 59 02 	lds	r24, 0x0259
     b84:	90 91 5a 02 	lds	r25, 0x025A
     b88:	f6 01       	movw	r30, r12
     b8a:	e8 0f       	add	r30, r24
     b8c:	f9 1f       	adc	r31, r25
     b8e:	20 83       	st	Z, r18
			path_index=path_index+1;
     b90:	01 96       	adiw	r24, 0x01	; 1
     b92:	90 93 5a 02 	sts	0x025A, r25
     b96:	80 93 59 02 	sts	0x0259, r24
			previous_node=curr_node;					//previous_node  -> previous node
     b9a:	b0 92 32 05 	sts	0x0532, r11
     b9e:	a0 92 31 05 	sts	0x0531, r10
			r=r+path_logic(j,req_node);
     ba2:	ce 01       	movw	r24, r28
     ba4:	b4 01       	movw	r22, r8
     ba6:	0e 94 7d 05 	call	0xafa	; 0xafa <path_logic>
     baa:	e8 0e       	add	r14, r24
     bac:	f9 1e       	adc	r15, r25
		return(1);
	}
	int j,r=0;							//r stores the value of return
	
	//j: will iterate from 0 to the maximum nodes (maximum_number_of_nodes is the constant for the maximum number of nodes in the arena )
	for(j=0;j<maximum_number_of_nodes;j++)
     bae:	21 96       	adiw	r28, 0x01	; 1
     bb0:	c9 31       	cpi	r28, 0x19	; 25
     bb2:	d1 05       	cpc	r29, r1
     bb4:	c9 f6       	brne	.-78     	; 0xb68 <path_logic+0x6e>
			path_index=path_index+1;
			previous_node=curr_node;					//previous_node  -> previous node
			r=r+path_logic(j,req_node);
		}
	}
	if(r>0)
     bb6:	1e 14       	cp	r1, r14
     bb8:	1f 04       	cpc	r1, r15
     bba:	64 f0       	brlt	.+24     	; 0xbd4 <path_logic+0xda>
	{
		return(1);
	}
	else
	{
		path_index--;
     bbc:	80 91 59 02 	lds	r24, 0x0259
     bc0:	90 91 5a 02 	lds	r25, 0x025A
     bc4:	01 97       	sbiw	r24, 0x01	; 1
     bc6:	90 93 5a 02 	sts	0x025A, r25
     bca:	80 93 59 02 	sts	0x0259, r24
		return(0);
     bce:	80 e0       	ldi	r24, 0x00	; 0
     bd0:	90 e0       	ldi	r25, 0x00	; 0
     bd2:	02 c0       	rjmp	.+4      	; 0xbd8 <path_logic+0xde>
			r=r+path_logic(j,req_node);
		}
	}
	if(r>0)
	{
		return(1);
     bd4:	81 e0       	ldi	r24, 0x01	; 1
     bd6:	90 e0       	ldi	r25, 0x00	; 0
	else
	{
		path_index--;
		return(0);
	}
}
     bd8:	df 91       	pop	r29
     bda:	cf 91       	pop	r28
     bdc:	1f 91       	pop	r17
     bde:	0f 91       	pop	r16
     be0:	ff 90       	pop	r15
     be2:	ef 90       	pop	r14
     be4:	df 90       	pop	r13
     be6:	cf 90       	pop	r12
     be8:	bf 90       	pop	r11
     bea:	af 90       	pop	r10
     bec:	9f 90       	pop	r9
     bee:	8f 90       	pop	r8
     bf0:	08 95       	ret

00000bf2 <path_find>:
* Example Call:			path_find(10);
*
*/

void path_find(int req_node) 
{
     bf2:	0f 93       	push	r16
     bf4:	1f 93       	push	r17
     bf6:	cf 93       	push	r28
     bf8:	df 93       	push	r29
     bfa:	bc 01       	movw	r22, r24
	int i; 
	if(node_number==8 && req_node==23) // special case for the traversal of the bot from node 8 to node 23.
     bfc:	80 91 5f 02 	lds	r24, 0x025F
     c00:	90 91 60 02 	lds	r25, 0x0260
     c04:	88 30       	cpi	r24, 0x08	; 8
     c06:	91 05       	cpc	r25, r1
     c08:	a1 f4       	brne	.+40     	; 0xc32 <path_find+0x40>
     c0a:	67 31       	cpi	r22, 0x17	; 23
     c0c:	71 05       	cpc	r23, r1
     c0e:	89 f4       	brne	.+34     	; 0xc32 <path_find+0x40>
	{
		path[1]='S';
     c10:	83 e5       	ldi	r24, 0x53	; 83
     c12:	80 93 70 02 	sts	0x0270, r24
		path[2]='W';
     c16:	97 e5       	ldi	r25, 0x57	; 87
     c18:	90 93 71 02 	sts	0x0271, r25
		path[3]='S';
     c1c:	80 93 72 02 	sts	0x0272, r24
		path[4]='\0';
     c20:	10 92 73 02 	sts	0x0273, r1
		path_index=1;
     c24:	81 e0       	ldi	r24, 0x01	; 1
     c26:	90 e0       	ldi	r25, 0x00	; 0
     c28:	90 93 5a 02 	sts	0x025A, r25
     c2c:	80 93 59 02 	sts	0x0259, r24
     c30:	d0 c0       	rjmp	.+416    	; 0xdd2 <path_find+0x1e0>
	}
	
	else if(path[path_index]=='\0')
     c32:	e0 91 59 02 	lds	r30, 0x0259
     c36:	f0 91 5a 02 	lds	r31, 0x025A
     c3a:	e1 59       	subi	r30, 0x91	; 145
     c3c:	fd 4f       	sbci	r31, 0xFD	; 253
     c3e:	80 81       	ld	r24, Z
     c40:	88 23       	and	r24, r24
     c42:	09 f0       	breq	.+2      	; 0xc46 <path_find+0x54>
     c44:	c3 c0       	rjmp	.+390    	; 0xdcc <path_find+0x1da>
	{
		cli();
     c46:	f8 94       	cli
		destinationn_node=req_node;
     c48:	70 93 5e 02 	sts	0x025E, r23
     c4c:	60 93 5d 02 	sts	0x025D, r22
		previous_node=node_number;
     c50:	20 91 5f 02 	lds	r18, 0x025F
     c54:	30 91 60 02 	lds	r19, 0x0260
     c58:	30 93 32 05 	sts	0x0532, r19
     c5c:	20 93 31 05 	sts	0x0531, r18
     c60:	cf e6       	ldi	r28, 0x6F	; 111
     c62:	d2 e0       	ldi	r29, 0x02	; 2
						If the path string is fully occupied then it stores the node which the bot will traverse in the queue.
* Example Call:			path_find(10);
*
*/

void path_find(int req_node) 
     c64:	8e 01       	movw	r16, r28
     c66:	ce 01       	movw	r24, r28
     c68:	4a 96       	adiw	r24, 0x1a	; 26
     c6a:	fe 01       	movw	r30, r28
		destinationn_node=req_node;
		previous_node=node_number;
		
		//i: will iterate from 0 to the maximum nodes (maximum_number_of_nodes is the constant for the maximum number of nodes in the arena )
		for(i=0;i<maximum_number_of_nodes+1;i++)
		path[i]='\0';
     c6c:	11 92       	st	Z+, r1
		cli();
		destinationn_node=req_node;
		previous_node=node_number;
		
		//i: will iterate from 0 to the maximum nodes (maximum_number_of_nodes is the constant for the maximum number of nodes in the arena )
		for(i=0;i<maximum_number_of_nodes+1;i++)
     c6e:	e8 17       	cp	r30, r24
     c70:	f9 07       	cpc	r31, r25
     c72:	e1 f7       	brne	.-8      	; 0xc6c <path_find+0x7a>
		path[i]='\0';
		path_index=1;
     c74:	81 e0       	ldi	r24, 0x01	; 1
     c76:	90 e0       	ldi	r25, 0x00	; 0
     c78:	90 93 5a 02 	sts	0x025A, r25
     c7c:	80 93 59 02 	sts	0x0259, r24
		found=0;
     c80:	10 92 5e 05 	sts	0x055E, r1
     c84:	10 92 5d 05 	sts	0x055D, r1
		path_logic(node_number,req_node);
     c88:	c9 01       	movw	r24, r18
     c8a:	0e 94 7d 05 	call	0xafa	; 0xafa <path_logic>
		path_index--;
     c8e:	20 91 59 02 	lds	r18, 0x0259
     c92:	30 91 5a 02 	lds	r19, 0x025A
     c96:	21 50       	subi	r18, 0x01	; 1
     c98:	30 40       	sbci	r19, 0x00	; 0
						If the path string is fully occupied then it stores the node which the bot will traverse in the queue.
* Example Call:			path_find(10);
*
*/

void path_find(int req_node) 
     c9a:	05 5e       	subi	r16, 0xE5	; 229
     c9c:	1f 4f       	sbci	r17, 0xFF	; 255
		path_index--;
		
		//i: will iterate from 0 to the maximum nodes (maximum_number_of_nodes is the constant for the maximum number of nodes in the arena )
		for(i=0;i<=maximum_number_of_nodes+1;i++)
		{
			path[i]='\0';
     c9e:	19 92       	st	Y+, r1
		found=0;
		path_logic(node_number,req_node);
		path_index--;
		
		//i: will iterate from 0 to the maximum nodes (maximum_number_of_nodes is the constant for the maximum number of nodes in the arena )
		for(i=0;i<=maximum_number_of_nodes+1;i++)
     ca0:	c0 17       	cp	r28, r16
     ca2:	d1 07       	cpc	r29, r17
     ca4:	e1 f7       	brne	.-8      	; 0xc9e <path_find+0xac>
		{
			path[i]='\0';
		}
		
		//i: will iterate from 1 to the length of the path index
		for(i=1;i<=path_index;i++)  
     ca6:	12 16       	cp	r1, r18
     ca8:	13 06       	cpc	r1, r19
     caa:	64 f4       	brge	.+24     	; 0xcc4 <path_find+0xd2>
     cac:	eb e8       	ldi	r30, 0x8B	; 139
     cae:	f2 e0       	ldi	r31, 0x02	; 2
     cb0:	a0 e7       	ldi	r26, 0x70	; 112
     cb2:	b2 e0       	ldi	r27, 0x02	; 2
     cb4:	81 e0       	ldi	r24, 0x01	; 1
     cb6:	90 e0       	ldi	r25, 0x00	; 0
		{
			path[i]=p[i];
     cb8:	41 91       	ld	r20, Z+
     cba:	4d 93       	st	X+, r20
		{
			path[i]='\0';
		}
		
		//i: will iterate from 1 to the length of the path index
		for(i=1;i<=path_index;i++)  
     cbc:	01 96       	adiw	r24, 0x01	; 1
     cbe:	28 17       	cp	r18, r24
     cc0:	39 07       	cpc	r19, r25
     cc2:	d4 f7       	brge	.-12     	; 0xcb8 <path_find+0xc6>
		}
		path_index=1;
		i=1;
		
		
		while(path[path_index]!='\0')		//Filters the counter direction West and East   
     cc4:	80 91 70 02 	lds	r24, 0x0270
     cc8:	88 23       	and	r24, r24
     cca:	31 f4       	brne	.+12     	; 0xcd8 <path_find+0xe6>
		for(i=1;i<=path_index;i++)  
		{
			path[i]=p[i];
		}
		path_index=1;
		i=1;
     ccc:	21 e0       	ldi	r18, 0x01	; 1
     cce:	30 e0       	ldi	r19, 0x00	; 0
						If the path string is fully occupied then it stores the node which the bot will traverse in the queue.
* Example Call:			path_find(10);
*
*/

void path_find(int req_node) 
     cd0:	f9 01       	movw	r30, r18
     cd2:	e1 59       	subi	r30, 0x91	; 145
     cd4:	fd 4f       	sbci	r31, 0xFD	; 253
     cd6:	2d c0       	rjmp	.+90     	; 0xd32 <path_find+0x140>
		}
		path_index=1;
		i=1;
		
		
		while(path[path_index]!='\0')		//Filters the counter direction West and East   
     cd8:	a0 e7       	ldi	r26, 0x70	; 112
     cda:	b2 e0       	ldi	r27, 0x02	; 2
     cdc:	ed 01       	movw	r28, r26
     cde:	81 e0       	ldi	r24, 0x01	; 1
     ce0:	90 e0       	ldi	r25, 0x00	; 0
     ce2:	61 e0       	ldi	r22, 0x01	; 1
     ce4:	70 e0       	ldi	r23, 0x00	; 0
		for(i=1;i<=path_index;i++)  
		{
			path[i]=p[i];
		}
		path_index=1;
		i=1;
     ce6:	21 e0       	ldi	r18, 0x01	; 1
     ce8:	30 e0       	ldi	r19, 0x00	; 0
		
		while(path[path_index]!='\0')		//Filters the counter direction West and East   
		{
			if((path[i]=='E' && path[i+1]=='W') || (path[i]=='W' && path[i+1]=='E'))
			path_index=path_index+2;
			path[i]=path[path_index];
     cea:	4f e6       	ldi	r20, 0x6F	; 111
     cec:	52 e0       	ldi	r21, 0x02	; 2
     cee:	01 c0       	rjmp	.+2      	; 0xcf2 <path_find+0x100>
		}
		path_index=1;
		i=1;
		
		
		while(path[path_index]!='\0')		//Filters the counter direction West and East   
     cf0:	bc 01       	movw	r22, r24
		{
			if((path[i]=='E' && path[i+1]=='W') || (path[i]=='W' && path[i+1]=='E'))
     cf2:	ed 91       	ld	r30, X+
     cf4:	e5 34       	cpi	r30, 0x45	; 69
     cf6:	21 f4       	brne	.+8      	; 0xd00 <path_find+0x10e>
     cf8:	ec 91       	ld	r30, X
     cfa:	e7 35       	cpi	r30, 0x57	; 87
     cfc:	41 f4       	brne	.+16     	; 0xd0e <path_find+0x11c>
     cfe:	05 c0       	rjmp	.+10     	; 0xd0a <path_find+0x118>
     d00:	e7 35       	cpi	r30, 0x57	; 87
     d02:	29 f4       	brne	.+10     	; 0xd0e <path_find+0x11c>
     d04:	ec 91       	ld	r30, X
     d06:	e5 34       	cpi	r30, 0x45	; 69
     d08:	11 f4       	brne	.+4      	; 0xd0e <path_find+0x11c>
			path_index=path_index+2;
     d0a:	cb 01       	movw	r24, r22
     d0c:	02 96       	adiw	r24, 0x02	; 2
			path[i]=path[path_index];
     d0e:	fa 01       	movw	r30, r20
     d10:	e8 0f       	add	r30, r24
     d12:	f9 1f       	adc	r31, r25
     d14:	60 81       	ld	r22, Z
     d16:	69 93       	st	Y+, r22
			i++;
     d18:	2f 5f       	subi	r18, 0xFF	; 255
     d1a:	3f 4f       	sbci	r19, 0xFF	; 255
			path_index++;
     d1c:	01 96       	adiw	r24, 0x01	; 1
		}
		path_index=1;
		i=1;
		
		
		while(path[path_index]!='\0')		//Filters the counter direction West and East   
     d1e:	fa 01       	movw	r30, r20
     d20:	e8 0f       	add	r30, r24
     d22:	f9 1f       	adc	r31, r25
     d24:	60 81       	ld	r22, Z
     d26:	66 23       	and	r22, r22
     d28:	19 f7       	brne	.-58     	; 0xcf0 <path_find+0xfe>
			i++;
			path_index++;
		}
		
		//path_index: will iterate from i to the maximum number of nodes
		for(path_index=i;path_index<=maximum_number_of_nodes+1;path_index++)		//only produces that string which is required for traversal and other elements are given null value
     d2a:	2b 31       	cpi	r18, 0x1B	; 27
     d2c:	31 05       	cpc	r19, r1
     d2e:	84 f2       	brlt	.-96     	; 0xcd0 <path_find+0xde>
     d30:	06 c0       	rjmp	.+12     	; 0xd3e <path_find+0x14c>
		path[path_index]='\0';
     d32:	11 92       	st	Z+, r1
			i++;
			path_index++;
		}
		
		//path_index: will iterate from i to the maximum number of nodes
		for(path_index=i;path_index<=maximum_number_of_nodes+1;path_index++)		//only produces that string which is required for traversal and other elements are given null value
     d34:	2f 5f       	subi	r18, 0xFF	; 255
     d36:	3f 4f       	sbci	r19, 0xFF	; 255
     d38:	2b 31       	cpi	r18, 0x1B	; 27
     d3a:	31 05       	cpc	r19, r1
     d3c:	d4 f3       	brlt	.-12     	; 0xd32 <path_find+0x140>
		path[path_index]='\0';
		path_index=1;
		i=1;
		
		while(path[path_index]!='\0')		//Filters the counter direction South and North
     d3e:	80 91 70 02 	lds	r24, 0x0270
     d42:	88 23       	and	r24, r24
     d44:	31 f4       	brne	.+12     	; 0xd52 <path_find+0x160>
		
		//path_index: will iterate from i to the maximum number of nodes
		for(path_index=i;path_index<=maximum_number_of_nodes+1;path_index++)		//only produces that string which is required for traversal and other elements are given null value
		path[path_index]='\0';
		path_index=1;
		i=1;
     d46:	41 e0       	ldi	r20, 0x01	; 1
     d48:	50 e0       	ldi	r21, 0x00	; 0
						If the path string is fully occupied then it stores the node which the bot will traverse in the queue.
* Example Call:			path_find(10);
*
*/

void path_find(int req_node) 
     d4a:	fa 01       	movw	r30, r20
     d4c:	e1 59       	subi	r30, 0x91	; 145
     d4e:	fd 4f       	sbci	r31, 0xFD	; 253
     d50:	2f c0       	rjmp	.+94     	; 0xdb0 <path_find+0x1be>
		for(path_index=i;path_index<=maximum_number_of_nodes+1;path_index++)		//only produces that string which is required for traversal and other elements are given null value
		path[path_index]='\0';
		path_index=1;
		i=1;
		
		while(path[path_index]!='\0')		//Filters the counter direction South and North
     d52:	a0 e7       	ldi	r26, 0x70	; 112
     d54:	b2 e0       	ldi	r27, 0x02	; 2
     d56:	ed 01       	movw	r28, r26
     d58:	81 e0       	ldi	r24, 0x01	; 1
     d5a:	90 e0       	ldi	r25, 0x00	; 0
     d5c:	21 e0       	ldi	r18, 0x01	; 1
     d5e:	30 e0       	ldi	r19, 0x00	; 0
		
		//path_index: will iterate from i to the maximum number of nodes
		for(path_index=i;path_index<=maximum_number_of_nodes+1;path_index++)		//only produces that string which is required for traversal and other elements are given null value
		path[path_index]='\0';
		path_index=1;
		i=1;
     d60:	41 e0       	ldi	r20, 0x01	; 1
     d62:	50 e0       	ldi	r21, 0x00	; 0
		
		while(path[path_index]!='\0')		//Filters the counter direction South and North
		{
			if((path[i]=='S' && path[i+1]=='N') || (path[i]=='N' && path[i+1]=='S'))
			path_index=path_index+2;
			path[i]=path[path_index];
     d64:	6f e6       	ldi	r22, 0x6F	; 111
     d66:	72 e0       	ldi	r23, 0x02	; 2
     d68:	01 c0       	rjmp	.+2      	; 0xd6c <path_find+0x17a>
			i++;
			path_index++;
     d6a:	c9 01       	movw	r24, r18
		path_index=1;
		i=1;
		
		while(path[path_index]!='\0')		//Filters the counter direction South and North
		{
			if((path[i]=='S' && path[i+1]=='N') || (path[i]=='N' && path[i+1]=='S'))
     d6c:	ed 91       	ld	r30, X+
     d6e:	e3 35       	cpi	r30, 0x53	; 83
     d70:	21 f4       	brne	.+8      	; 0xd7a <path_find+0x188>
     d72:	ec 91       	ld	r30, X
     d74:	ee 34       	cpi	r30, 0x4E	; 78
     d76:	41 f4       	brne	.+16     	; 0xd88 <path_find+0x196>
     d78:	05 c0       	rjmp	.+10     	; 0xd84 <path_find+0x192>
     d7a:	ee 34       	cpi	r30, 0x4E	; 78
     d7c:	29 f4       	brne	.+10     	; 0xd88 <path_find+0x196>
     d7e:	ec 91       	ld	r30, X
     d80:	e3 35       	cpi	r30, 0x53	; 83
     d82:	11 f4       	brne	.+4      	; 0xd88 <path_find+0x196>
			path_index=path_index+2;
     d84:	c9 01       	movw	r24, r18
     d86:	02 96       	adiw	r24, 0x02	; 2
			path[i]=path[path_index];
     d88:	fb 01       	movw	r30, r22
     d8a:	e8 0f       	add	r30, r24
     d8c:	f9 1f       	adc	r31, r25
     d8e:	20 81       	ld	r18, Z
     d90:	29 93       	st	Y+, r18
			i++;
     d92:	4f 5f       	subi	r20, 0xFF	; 255
     d94:	5f 4f       	sbci	r21, 0xFF	; 255
			path_index++;
     d96:	9c 01       	movw	r18, r24
     d98:	2f 5f       	subi	r18, 0xFF	; 255
     d9a:	3f 4f       	sbci	r19, 0xFF	; 255
		for(path_index=i;path_index<=maximum_number_of_nodes+1;path_index++)		//only produces that string which is required for traversal and other elements are given null value
		path[path_index]='\0';
		path_index=1;
		i=1;
		
		while(path[path_index]!='\0')		//Filters the counter direction South and North
     d9c:	fb 01       	movw	r30, r22
     d9e:	e2 0f       	add	r30, r18
     da0:	f3 1f       	adc	r31, r19
     da2:	80 81       	ld	r24, Z
     da4:	88 23       	and	r24, r24
     da6:	09 f7       	brne	.-62     	; 0xd6a <path_find+0x178>
			path[i]=path[path_index];
			i++;
			path_index++;
		}
		
		for(path_index=i;path_index<=maximum_number_of_nodes+1;path_index++)
     da8:	4b 31       	cpi	r20, 0x1B	; 27
     daa:	51 05       	cpc	r21, r1
     dac:	74 f2       	brlt	.-100    	; 0xd4a <path_find+0x158>
     dae:	06 c0       	rjmp	.+12     	; 0xdbc <path_find+0x1ca>
		path[path_index]='\0';
     db0:	11 92       	st	Z+, r1
			path[i]=path[path_index];
			i++;
			path_index++;
		}
		
		for(path_index=i;path_index<=maximum_number_of_nodes+1;path_index++)
     db2:	4f 5f       	subi	r20, 0xFF	; 255
     db4:	5f 4f       	sbci	r21, 0xFF	; 255
     db6:	4b 31       	cpi	r20, 0x1B	; 27
     db8:	51 05       	cpc	r21, r1
     dba:	d4 f3       	brlt	.-12     	; 0xdb0 <path_find+0x1be>
		path[path_index]='\0';
		
		path_index=1;
     dbc:	81 e0       	ldi	r24, 0x01	; 1
     dbe:	90 e0       	ldi	r25, 0x00	; 0
     dc0:	90 93 5a 02 	sts	0x025A, r25
     dc4:	80 93 59 02 	sts	0x0259, r24
		sei();
     dc8:	78 94       	sei
     dca:	03 c0       	rjmp	.+6      	; 0xdd2 <path_find+0x1e0>
	}
	else
	{
		enqueue(req_node);   //If the path string is fully occupied then it stores the node( which the bot will traverse) in the queue.
     dcc:	cb 01       	movw	r24, r22
     dce:	0e 94 02 01 	call	0x204	; 0x204 <enqueue>
	}
}
     dd2:	df 91       	pop	r29
     dd4:	cf 91       	pop	r28
     dd6:	1f 91       	pop	r17
     dd8:	0f 91       	pop	r16
     dda:	08 95       	ret

00000ddc <enq_end>:
* Example Call:				enq_end(10);
*
*/

void enq_end(int node_added_start)
{
     ddc:	0f 93       	push	r16
     dde:	1f 93       	push	r17
     de0:	cf 93       	push	r28
     de2:	df 93       	push	r29
     de4:	8c 01       	movw	r16, r24
	struct queue *newnode;
	if(end==NULL)
     de6:	c0 91 4a 02 	lds	r28, 0x024A
     dea:	d0 91 4b 02 	lds	r29, 0x024B
     dee:	20 97       	sbiw	r28, 0x00	; 0
     df0:	a9 f4       	brne	.+42     	; 0xe1c <enq_end+0x40>
	{
		end=(struct queue*)malloc(sizeof(struct queue));
     df2:	86 e0       	ldi	r24, 0x06	; 6
     df4:	90 e0       	ldi	r25, 0x00	; 0
     df6:	0e 94 85 1b 	call	0x370a	; 0x370a <malloc>
     dfa:	e8 2f       	mov	r30, r24
     dfc:	f9 2f       	mov	r31, r25
     dfe:	f0 93 4b 02 	sts	0x024B, r31
     e02:	e0 93 4a 02 	sts	0x024A, r30
		end->num=node_added_start;
     e06:	15 83       	std	Z+5, r17	; 0x05
     e08:	04 83       	std	Z+4, r16	; 0x04
		end->next=NULL;
     e0a:	11 82       	std	Z+1, r1	; 0x01
     e0c:	10 82       	st	Z, r1
		end->prev=NULL;
     e0e:	13 82       	std	Z+3, r1	; 0x03
     e10:	12 82       	std	Z+2, r1	; 0x02
		root=end;
     e12:	f0 93 4d 02 	sts	0x024D, r31
     e16:	e0 93 4c 02 	sts	0x024C, r30
     e1a:	14 c0       	rjmp	.+40     	; 0xe44 <enq_end+0x68>
	}
	else
	{
		newnode=(struct queue*)malloc(sizeof(struct queue));
     e1c:	86 e0       	ldi	r24, 0x06	; 6
     e1e:	90 e0       	ldi	r25, 0x00	; 0
     e20:	0e 94 85 1b 	call	0x370a	; 0x370a <malloc>
     e24:	e8 2f       	mov	r30, r24
     e26:	f9 2f       	mov	r31, r25
		newnode->num=node_added_start;
     e28:	15 83       	std	Z+5, r17	; 0x05
     e2a:	04 83       	std	Z+4, r16	; 0x04
		end->prev=newnode;
     e2c:	fb 83       	std	Y+3, r31	; 0x03
     e2e:	ea 83       	std	Y+2, r30	; 0x02
		newnode->next=end;
     e30:	d1 83       	std	Z+1, r29	; 0x01
     e32:	c0 83       	st	Z, r28
		end=end->prev;
     e34:	8a 81       	ldd	r24, Y+2	; 0x02
     e36:	9b 81       	ldd	r25, Y+3	; 0x03
     e38:	90 93 4b 02 	sts	0x024B, r25
     e3c:	80 93 4a 02 	sts	0x024A, r24
		newnode->prev=NULL;
     e40:	13 82       	std	Z+3, r1	; 0x03
     e42:	12 82       	std	Z+2, r1	; 0x02
	}
	que_length++;
     e44:	80 91 57 02 	lds	r24, 0x0257
     e48:	90 91 58 02 	lds	r25, 0x0258
     e4c:	01 96       	adiw	r24, 0x01	; 1
     e4e:	90 93 58 02 	sts	0x0258, r25
     e52:	80 93 57 02 	sts	0x0257, r24
}
     e56:	df 91       	pop	r29
     e58:	cf 91       	pop	r28
     e5a:	1f 91       	pop	r17
     e5c:	0f 91       	pop	r16
     e5e:	08 95       	ret

00000e60 <dequeue>:
*
*/

void dequeue(void)
{
	if(que_length!=0)
     e60:	80 91 57 02 	lds	r24, 0x0257
     e64:	90 91 58 02 	lds	r25, 0x0258
     e68:	00 97       	sbiw	r24, 0x00	; 0
     e6a:	b1 f0       	breq	.+44     	; 0xe98 <dequeue+0x38>
	{
		struct queue *newnode;
		newnode=end;
     e6c:	80 91 4a 02 	lds	r24, 0x024A
     e70:	90 91 4b 02 	lds	r25, 0x024B
		end=end->next;
     e74:	fc 01       	movw	r30, r24
     e76:	20 81       	ld	r18, Z
     e78:	31 81       	ldd	r19, Z+1	; 0x01
     e7a:	30 93 4b 02 	sts	0x024B, r19
     e7e:	20 93 4a 02 	sts	0x024A, r18
		free(newnode);
     e82:	0e 94 1b 1c 	call	0x3836	; 0x3836 <free>
		que_length--;
     e86:	80 91 57 02 	lds	r24, 0x0257
     e8a:	90 91 58 02 	lds	r25, 0x0258
     e8e:	01 97       	sbiw	r24, 0x01	; 1
     e90:	90 93 58 02 	sts	0x0258, r25
     e94:	80 93 57 02 	sts	0x0257, r24
     e98:	08 95       	ret

00000e9a <buzzer>:
*
*/

void buzzer(int a)
{
	DDRC=0xFF;			  //Buzzer is connected to pin no 3 of port c
     e9a:	2f ef       	ldi	r18, 0xFF	; 255
     e9c:	27 b9       	out	0x07, r18	; 7
	if(a==1)
     e9e:	81 30       	cpi	r24, 0x01	; 1
     ea0:	91 05       	cpc	r25, r1
     ea2:	11 f4       	brne	.+4      	; 0xea8 <buzzer+0xe>
	PORTC=PORTC|0b00001000;
     ea4:	43 9a       	sbi	0x08, 3	; 8
     ea6:	08 95       	ret
	else if(a==0)
     ea8:	00 97       	sbiw	r24, 0x00	; 0
     eaa:	09 f4       	brne	.+2      	; 0xeae <buzzer+0x14>
	PORTC=PORTC & 0b11110111;
     eac:	43 98       	cbi	0x08, 3	; 8
     eae:	08 95       	ret

00000eb0 <lcd_port_config>:
*
*/

void lcd_port_config (void)
{
	cli();
     eb0:	f8 94       	cli
	DDRC = DDRC | 0xF7;		 //all the LCD pin's direction set as output
     eb2:	87 b1       	in	r24, 0x07	; 7
     eb4:	87 6f       	ori	r24, 0xF7	; 247
     eb6:	87 b9       	out	0x07, r24	; 7
	PORTC = PORTC & 0x80;	 // all the LCD pins are set to logic 0 except PORTC 7
     eb8:	88 b1       	in	r24, 0x08	; 8
     eba:	80 78       	andi	r24, 0x80	; 128
     ebc:	88 b9       	out	0x08, r24	; 8
	sei();
     ebe:	78 94       	sei
}
     ec0:	08 95       	ret

00000ec2 <motion>:
*
*/

void motion(char movement)
{
	DDRA=DDRA | 0X0F; // Port A pin no 0,1,2,3 are for motion controlling
     ec2:	91 b1       	in	r25, 0x01	; 1
     ec4:	9f 60       	ori	r25, 0x0F	; 15
     ec6:	91 b9       	out	0x01, r25	; 1
	if(movement=='f')
     ec8:	86 36       	cpi	r24, 0x66	; 102
     eca:	19 f4       	brne	.+6      	; 0xed2 <motion+0x10>
	PORTA=0b00000110;
     ecc:	86 e0       	ldi	r24, 0x06	; 6
     ece:	82 b9       	out	0x02, r24	; 2
     ed0:	08 95       	ret
	else if(movement=='b')
     ed2:	82 36       	cpi	r24, 0x62	; 98
     ed4:	19 f4       	brne	.+6      	; 0xedc <motion+0x1a>
	PORTA=0b00001001;
     ed6:	89 e0       	ldi	r24, 0x09	; 9
     ed8:	82 b9       	out	0x02, r24	; 2
     eda:	08 95       	ret
	else if(movement=='l')
     edc:	8c 36       	cpi	r24, 0x6C	; 108
     ede:	19 f4       	brne	.+6      	; 0xee6 <motion+0x24>
	PORTA=0b00000101;
     ee0:	85 e0       	ldi	r24, 0x05	; 5
     ee2:	82 b9       	out	0x02, r24	; 2
     ee4:	08 95       	ret
	else if(movement=='r')
     ee6:	82 37       	cpi	r24, 0x72	; 114
     ee8:	19 f4       	brne	.+6      	; 0xef0 <motion+0x2e>
	PORTA=0b00001010;
     eea:	8a e0       	ldi	r24, 0x0A	; 10
     eec:	82 b9       	out	0x02, r24	; 2
     eee:	08 95       	ret
	else if('s')
	PORTA=0x00;
     ef0:	12 b8       	out	0x02, r1	; 2
     ef2:	08 95       	ret

00000ef4 <sppeed_config>:
*
*/

void sppeed_config(void)
{
	cli();
     ef4:	f8 94       	cli
	DDRA=DDRA|0x0F;
     ef6:	81 b1       	in	r24, 0x01	; 1
     ef8:	8f 60       	ori	r24, 0x0F	; 15
     efa:	81 b9       	out	0x01, r24	; 1
	DDRL=DDRL | 0b00011000;			// declaring pin mo Pl3 and Pl4 as output
     efc:	ea e0       	ldi	r30, 0x0A	; 10
     efe:	f1 e0       	ldi	r31, 0x01	; 1
     f00:	80 81       	ld	r24, Z
     f02:	88 61       	ori	r24, 0x18	; 24
     f04:	80 83       	st	Z, r24
	PORTL=PORTL|0b00011000;			// if Output Compare pins are disconnected than output Will be one at these pins
     f06:	eb e0       	ldi	r30, 0x0B	; 11
     f08:	f1 e0       	ldi	r31, 0x01	; 1
     f0a:	80 81       	ld	r24, Z
     f0c:	88 61       	ori	r24, 0x18	; 24
     f0e:	80 83       	st	Z, r24
	TCNT5=0x00FF;					// initial value of counter
     f10:	8f ef       	ldi	r24, 0xFF	; 255
     f12:	90 e0       	ldi	r25, 0x00	; 0
     f14:	90 93 25 01 	sts	0x0125, r25
     f18:	80 93 24 01 	sts	0x0124, r24
	TCCR5A=TCCR5A | 0b10101001;		// Timer counter control register
     f1c:	e0 e2       	ldi	r30, 0x20	; 32
     f1e:	f1 e0       	ldi	r31, 0x01	; 1
     f20:	80 81       	ld	r24, Z
     f22:	89 6a       	ori	r24, 0xA9	; 169
     f24:	80 83       	st	Z, r24
	TCCR5B=TCCR5B | 0b00001011;
     f26:	e1 e2       	ldi	r30, 0x21	; 33
     f28:	f1 e0       	ldi	r31, 0x01	; 1
     f2a:	80 81       	ld	r24, Z
     f2c:	8b 60       	ori	r24, 0x0B	; 11
     f2e:	80 83       	st	Z, r24
	sppeed(255,249);
     f30:	8f ef       	ldi	r24, 0xFF	; 255
     f32:	90 e0       	ldi	r25, 0x00	; 0
     f34:	69 ef       	ldi	r22, 0xF9	; 249
     f36:	70 e0       	ldi	r23, 0x00	; 0
     f38:	0e 94 f7 00 	call	0x1ee	; 0x1ee <sppeed>
	sei();
     f3c:	78 94       	sei
}
     f3e:	08 95       	ret

00000f40 <distance>:
* Example Call:				distance('f',11,'o');
*
*/

void distance(char a,float cm,char iop)
{
     f40:	cf 92       	push	r12
     f42:	df 92       	push	r13
     f44:	ef 92       	push	r14
     f46:	ff 92       	push	r15
     f48:	1f 93       	push	r17
     f4a:	cf 93       	push	r28
     f4c:	df 93       	push	r29
     f4e:	c8 2f       	mov	r28, r24
     f50:	6a 01       	movw	r12, r20
     f52:	7b 01       	movw	r14, r22
	sppeed(255,249);
     f54:	8f ef       	ldi	r24, 0xFF	; 255
     f56:	90 e0       	ldi	r25, 0x00	; 0
     f58:	69 ef       	ldi	r22, 0xF9	; 249
     f5a:	70 e0       	ldi	r23, 0x00	; 0
     f5c:	0e 94 f7 00 	call	0x1ee	; 0x1ee <sppeed>
	float b=0;
	right_position_encode=0; //clearing encoder value
     f60:	10 92 61 02 	sts	0x0261, r1
     f64:	10 92 62 02 	sts	0x0262, r1
     f68:	10 92 63 02 	sts	0x0263, r1
     f6c:	10 92 64 02 	sts	0x0264, r1
	left_position_encode=0;
     f70:	10 92 65 02 	sts	0x0265, r1
     f74:	10 92 66 02 	sts	0x0266, r1
     f78:	10 92 67 02 	sts	0x0267, r1
     f7c:	10 92 68 02 	sts	0x0268, r1
*/

void distance(char a,float cm,char iop)
{
	sppeed(255,249);
	float b=0;
     f80:	60 e0       	ldi	r22, 0x00	; 0
     f82:	70 e0       	ldi	r23, 0x00	; 0
     f84:	80 e0       	ldi	r24, 0x00	; 0
     f86:	90 e0       	ldi	r25, 0x00	; 0
		{
			PORTA=0b00000110;
		}
		else if(a=='b')
		{
			PORTA=0b00001001;
     f88:	19 e0       	ldi	r17, 0x09	; 9
	left_position_encode=0;
	while((ceil(b))<(cm))
	{
		if(a=='f')
		{
			PORTA=0b00000110;
     f8a:	d6 e0       	ldi	r29, 0x06	; 6
{
	sppeed(255,249);
	float b=0;
	right_position_encode=0; //clearing encoder value
	left_position_encode=0;
	while((ceil(b))<(cm))
     f8c:	17 c0       	rjmp	.+46     	; 0xfbc <distance+0x7c>
	{
		if(a=='f')
     f8e:	c6 36       	cpi	r28, 0x66	; 102
     f90:	11 f4       	brne	.+4      	; 0xf96 <distance+0x56>
		{
			PORTA=0b00000110;
     f92:	d2 b9       	out	0x02, r29	; 2
     f94:	03 c0       	rjmp	.+6      	; 0xf9c <distance+0x5c>
		}
		else if(a=='b')
     f96:	c2 36       	cpi	r28, 0x62	; 98
     f98:	09 f4       	brne	.+2      	; 0xf9c <distance+0x5c>
		{
			PORTA=0b00001001;
     f9a:	12 b9       	out	0x02, r17	; 2

		}
		b=0.5413*right_position_encode; // feedback constant value
     f9c:	60 91 61 02 	lds	r22, 0x0261
     fa0:	70 91 62 02 	lds	r23, 0x0262
     fa4:	80 91 63 02 	lds	r24, 0x0263
     fa8:	90 91 64 02 	lds	r25, 0x0264
     fac:	0e 94 b2 18 	call	0x3164	; 0x3164 <__floatunsisf>
     fb0:	23 ea       	ldi	r18, 0xA3	; 163
     fb2:	32 e9       	ldi	r19, 0x92	; 146
     fb4:	4a e0       	ldi	r20, 0x0A	; 10
     fb6:	5f e3       	ldi	r21, 0x3F	; 63
     fb8:	0e 94 a4 19 	call	0x3348	; 0x3348 <__mulsf3>
{
	sppeed(255,249);
	float b=0;
	right_position_encode=0; //clearing encoder value
	left_position_encode=0;
	while((ceil(b))<(cm))
     fbc:	38 2f       	mov	r19, r24
     fbe:	29 2f       	mov	r18, r25
     fc0:	86 2f       	mov	r24, r22
     fc2:	97 2f       	mov	r25, r23
     fc4:	a3 2f       	mov	r26, r19
     fc6:	b2 2f       	mov	r27, r18
     fc8:	bc 01       	movw	r22, r24
     fca:	cd 01       	movw	r24, r26
     fcc:	0e 94 02 18 	call	0x3004	; 0x3004 <ceil>
     fd0:	a7 01       	movw	r20, r14
     fd2:	96 01       	movw	r18, r12
     fd4:	0e 94 15 18 	call	0x302a	; 0x302a <__cmpsf2>
     fd8:	88 23       	and	r24, r24
     fda:	cc f2       	brlt	.-78     	; 0xf8e <distance+0x4e>
			PORTA=0b00001001;

		}
		b=0.5413*right_position_encode; // feedback constant value
	}
	stop();
     fdc:	0e 94 26 08 	call	0x104c	; 0x104c <stop>
}
     fe0:	df 91       	pop	r29
     fe2:	cf 91       	pop	r28
     fe4:	1f 91       	pop	r17
     fe6:	ff 90       	pop	r15
     fe8:	ef 90       	pop	r14
     fea:	df 90       	pop	r13
     fec:	cf 90       	pop	r12
     fee:	08 95       	ret

00000ff0 <motion_pin_config>:
*
*/

void motion_pin_config (void)
{
	DDRA = DDRA | 0x0F;
     ff0:	81 b1       	in	r24, 0x01	; 1
     ff2:	8f 60       	ori	r24, 0x0F	; 15
     ff4:	81 b9       	out	0x01, r24	; 1
	PORTA = PORTA & 0xF0;
     ff6:	82 b1       	in	r24, 0x02	; 2
     ff8:	80 7f       	andi	r24, 0xF0	; 240
     ffa:	82 b9       	out	0x02, r24	; 2
	DDRL = DDRL | 0x18;			//Setting PL3 and PL4 pins as output for PWM generation
     ffc:	ea e0       	ldi	r30, 0x0A	; 10
     ffe:	f1 e0       	ldi	r31, 0x01	; 1
    1000:	80 81       	ld	r24, Z
    1002:	88 61       	ori	r24, 0x18	; 24
    1004:	80 83       	st	Z, r24
	PORTL = PORTL | 0x18;		//PL3 and PL4 pins are for velocity control using PWM.
    1006:	eb e0       	ldi	r30, 0x0B	; 11
    1008:	f1 e0       	ldi	r31, 0x01	; 1
    100a:	80 81       	ld	r24, Z
    100c:	88 61       	ori	r24, 0x18	; 24
    100e:	80 83       	st	Z, r24
	OCR5A=0x00FF;
    1010:	8f ef       	ldi	r24, 0xFF	; 255
    1012:	90 e0       	ldi	r25, 0x00	; 0
    1014:	90 93 29 01 	sts	0x0129, r25
    1018:	80 93 28 01 	sts	0x0128, r24
	OCR5B=0x00FF;
    101c:	90 93 2b 01 	sts	0x012B, r25
    1020:	80 93 2a 01 	sts	0x012A, r24
}
    1024:	08 95       	ret

00001026 <left_encoder_pin_config>:
*
*/

void left_encoder_pin_config (void)
{
	DDRE  = DDRE & 0xEF;  //Set the direction of the PORTE 4 pin as input
    1026:	6c 98       	cbi	0x0d, 4	; 13
	PORTE = PORTE | 0x10; //Enable internal pull-up for PORTE 4 pin
    1028:	74 9a       	sbi	0x0e, 4	; 14
}
    102a:	08 95       	ret

0000102c <right_encoder_pin_config>:
*
*/

void right_encoder_pin_config (void)
{
	DDRE  = DDRE & 0xDF;		//Set the direction of the PORTE 4 pin as input
    102c:	6d 98       	cbi	0x0d, 5	; 13
	PORTE = PORTE | 0x20;		//Enable internal pull-up for PORTE 4 pin
    102e:	75 9a       	sbi	0x0e, 5	; 14
}
    1030:	08 95       	ret

00001032 <port_init>:
*
*/

void port_init()
{
	motion_pin_config(); //robot motion pins config
    1032:	0e 94 f8 07 	call	0xff0	; 0xff0 <motion_pin_config>
	left_encoder_pin_config(); //left encoder pin config
    1036:	0e 94 13 08 	call	0x1026	; 0x1026 <left_encoder_pin_config>
	right_encoder_pin_config(); //right encoder pin config
    103a:	0e 94 16 08 	call	0x102c	; 0x102c <right_encoder_pin_config>
}
    103e:	08 95       	ret

00001040 <motion_set>:
void motion_set (unsigned char Direction)
{
	unsigned char PortARestore = 0;

	Direction &= 0x0F; 						// removing upper nibble for the protection
	PortARestore = PORTA; 					// reading the PORTA original status
    1040:	92 b1       	in	r25, 0x02	; 2
	PortARestore &= 0xF0; 					// making lower direction nibble to 0
    1042:	90 7f       	andi	r25, 0xF0	; 240

void motion_set (unsigned char Direction)
{
	unsigned char PortARestore = 0;

	Direction &= 0x0F; 						// removing upper nibble for the protection
    1044:	8f 70       	andi	r24, 0x0F	; 15
	PortARestore = PORTA; 					// reading the PORTA original status
	PortARestore &= 0xF0; 					// making lower direction nibble to 0
	PortARestore |= Direction;				// adding lower nibble for forward command and restoring the PORTA status
    1046:	98 2b       	or	r25, r24
	PORTA = PortARestore; 					// executing the command
    1048:	92 b9       	out	0x02, r25	; 2
}
    104a:	08 95       	ret

0000104c <stop>:
*
*/

void stop (void)
{
	motion_set(0x00);
    104c:	80 e0       	ldi	r24, 0x00	; 0
    104e:	0e 94 20 08 	call	0x1040	; 0x1040 <motion_set>
	//_delay_ms(1000);
}
    1052:	08 95       	ret

00001054 <left>:
*
*/

void left (void) 
{
	motion_set(0x05);
    1054:	85 e0       	ldi	r24, 0x05	; 5
    1056:	0e 94 20 08 	call	0x1040	; 0x1040 <motion_set>
}
    105a:	08 95       	ret

0000105c <right>:
*
*/

void right (void) 
{
	motion_set(0x0A);
    105c:	8a e0       	ldi	r24, 0x0A	; 10
    105e:	0e 94 20 08 	call	0x1040	; 0x1040 <motion_set>
}
    1062:	08 95       	ret

00001064 <soft_left>:
*
*/

void soft_left (void) 
{
	motion_set(0x04);
    1064:	84 e0       	ldi	r24, 0x04	; 4
    1066:	0e 94 20 08 	call	0x1040	; 0x1040 <motion_set>
}
    106a:	08 95       	ret

0000106c <soft_right>:
*
*/

void soft_right (void) 
{
	motion_set(0x02);
    106c:	82 e0       	ldi	r24, 0x02	; 2
    106e:	0e 94 20 08 	call	0x1040	; 0x1040 <motion_set>
}
    1072:	08 95       	ret

00001074 <angle_rotate>:
* Example Call:				angle_rotate(90);
*
*/

void angle_rotate(unsigned int Degrees)
{
    1074:	0f 93       	push	r16
    1076:	1f 93       	push	r17
    1078:	cf 93       	push	r28
    107a:	df 93       	push	r29
    107c:	ec 01       	movw	r28, r24
	sppeed(255,249);  //sets the speed of motors
    107e:	8f ef       	ldi	r24, 0xFF	; 255
    1080:	90 e0       	ldi	r25, 0x00	; 0
    1082:	69 ef       	ldi	r22, 0xF9	; 249
    1084:	70 e0       	ldi	r23, 0x00	; 0
    1086:	0e 94 f7 00 	call	0x1ee	; 0x1ee <sppeed>
	float ReqdShaftCount = 0;
	unsigned long int ReqdShaftCountInt = 0;
	if(node_number==15 || node_number==16 || node_number==17)
    108a:	80 91 5f 02 	lds	r24, 0x025F
    108e:	90 91 60 02 	lds	r25, 0x0260
    1092:	0f 97       	sbiw	r24, 0x0f	; 15
    1094:	83 30       	cpi	r24, 0x03	; 3
    1096:	91 05       	cpc	r25, r1
    1098:	60 f4       	brcc	.+24     	; 0x10b2 <angle_rotate+0x3e>
	ReqdShaftCount = (float) Degrees/ 4.60;
    109a:	be 01       	movw	r22, r28
    109c:	80 e0       	ldi	r24, 0x00	; 0
    109e:	90 e0       	ldi	r25, 0x00	; 0
    10a0:	0e 94 b2 18 	call	0x3164	; 0x3164 <__floatunsisf>
    10a4:	23 e3       	ldi	r18, 0x33	; 51
    10a6:	33 e3       	ldi	r19, 0x33	; 51
    10a8:	43 e9       	ldi	r20, 0x93	; 147
    10aa:	50 e4       	ldi	r21, 0x40	; 64
    10ac:	0e 94 19 18 	call	0x3032	; 0x3032 <__divsf3>
    10b0:	0b c0       	rjmp	.+22     	; 0x10c8 <angle_rotate+0x54>
	else
	ReqdShaftCount = (float) Degrees/ 4.090; // division by resolution to get shaft count
    10b2:	be 01       	movw	r22, r28
    10b4:	80 e0       	ldi	r24, 0x00	; 0
    10b6:	90 e0       	ldi	r25, 0x00	; 0
    10b8:	0e 94 b2 18 	call	0x3164	; 0x3164 <__floatunsisf>
    10bc:	28 e4       	ldi	r18, 0x48	; 72
    10be:	31 ee       	ldi	r19, 0xE1	; 225
    10c0:	42 e8       	ldi	r20, 0x82	; 130
    10c2:	50 e4       	ldi	r21, 0x40	; 64
    10c4:	0e 94 19 18 	call	0x3032	; 0x3032 <__divsf3>
	ReqdShaftCountInt = (unsigned int) ReqdShaftCount;
    10c8:	38 2f       	mov	r19, r24
    10ca:	29 2f       	mov	r18, r25
    10cc:	86 2f       	mov	r24, r22
    10ce:	97 2f       	mov	r25, r23
    10d0:	a3 2f       	mov	r26, r19
    10d2:	b2 2f       	mov	r27, r18
    10d4:	bc 01       	movw	r22, r24
    10d6:	cd 01       	movw	r24, r26
    10d8:	0e 94 86 18 	call	0x310c	; 0x310c <__fixunssfsi>
    10dc:	dc 01       	movw	r26, r24
    10de:	cb 01       	movw	r24, r22
    10e0:	a0 e0       	ldi	r26, 0x00	; 0
    10e2:	b0 e0       	ldi	r27, 0x00	; 0
	right_position_encode = 0;
    10e4:	10 92 61 02 	sts	0x0261, r1
    10e8:	10 92 62 02 	sts	0x0262, r1
    10ec:	10 92 63 02 	sts	0x0263, r1
    10f0:	10 92 64 02 	sts	0x0264, r1
	left_position_encode = 0;
    10f4:	10 92 65 02 	sts	0x0265, r1
    10f8:	10 92 66 02 	sts	0x0266, r1
    10fc:	10 92 67 02 	sts	0x0267, r1
    1100:	10 92 68 02 	sts	0x0268, r1
	while (1)
	{
		if((right_position_encode >= ReqdShaftCountInt) | (left_position_encode >= ReqdShaftCountInt))
    1104:	f1 e0       	ldi	r31, 0x01	; 1
    1106:	c0 e0       	ldi	r28, 0x00	; 0
    1108:	40 91 61 02 	lds	r20, 0x0261
    110c:	50 91 62 02 	lds	r21, 0x0262
    1110:	60 91 63 02 	lds	r22, 0x0263
    1114:	70 91 64 02 	lds	r23, 0x0264
    1118:	00 91 65 02 	lds	r16, 0x0265
    111c:	10 91 66 02 	lds	r17, 0x0266
    1120:	20 91 67 02 	lds	r18, 0x0267
    1124:	30 91 68 02 	lds	r19, 0x0268
    1128:	ef 2f       	mov	r30, r31
    112a:	48 17       	cp	r20, r24
    112c:	59 07       	cpc	r21, r25
    112e:	6a 07       	cpc	r22, r26
    1130:	7b 07       	cpc	r23, r27
    1132:	08 f4       	brcc	.+2      	; 0x1136 <angle_rotate+0xc2>
    1134:	ec 2f       	mov	r30, r28
    1136:	ee 23       	and	r30, r30
    1138:	49 f4       	brne	.+18     	; 0x114c <angle_rotate+0xd8>
    113a:	4f 2f       	mov	r20, r31
    113c:	08 17       	cp	r16, r24
    113e:	19 07       	cpc	r17, r25
    1140:	2a 07       	cpc	r18, r26
    1142:	3b 07       	cpc	r19, r27
    1144:	08 f4       	brcc	.+2      	; 0x1148 <angle_rotate+0xd4>
    1146:	4c 2f       	mov	r20, r28
    1148:	44 23       	and	r20, r20
    114a:	f1 f2       	breq	.-68     	; 0x1108 <angle_rotate+0x94>
		break;
	}
	stop(); //Stop robot
    114c:	0e 94 26 08 	call	0x104c	; 0x104c <stop>
	navigate();   //navigate the bot after rotating
    1150:	0e 94 6b 04 	call	0x8d6	; 0x8d6 <navigate>
}
    1154:	df 91       	pop	r29
    1156:	cf 91       	pop	r28
    1158:	1f 91       	pop	r17
    115a:	0f 91       	pop	r16
    115c:	08 95       	ret

0000115e <left_degrees>:
* Example Call:				left_degrees(90);
*
*/

void left_degrees(unsigned int Degrees)
{
    115e:	ef 92       	push	r14
    1160:	ff 92       	push	r15
    1162:	0f 93       	push	r16
    1164:	1f 93       	push	r17
    1166:	cf 93       	push	r28
    1168:	df 93       	push	r29
    116a:	ec 01       	movw	r28, r24
	// 88 pulses for 360 degrees rotation 4.090 degrees per count
	navigation_in_degrees = navigation_in_degrees + Degrees;
    116c:	80 91 3d 02 	lds	r24, 0x023D
    1170:	90 91 3e 02 	lds	r25, 0x023E
    1174:	8c 0f       	add	r24, r28
    1176:	9d 1f       	adc	r25, r29
    1178:	90 93 3e 02 	sts	0x023E, r25
    117c:	80 93 3d 02 	sts	0x023D, r24
	left(); //Turn left
    1180:	0e 94 2a 08 	call	0x1054	; 0x1054 <left>
	angle_rotate(Degrees);
    1184:	ce 01       	movw	r24, r28
    1186:	0e 94 3a 08 	call	0x1074	; 0x1074 <angle_rotate>
	while(digital[2]<15 && digital[1]<15 && digital[3]<15)
    118a:	80 91 3e 05 	lds	r24, 0x053E
    118e:	90 91 3f 05 	lds	r25, 0x053F
    1192:	8f 30       	cpi	r24, 0x0F	; 15
    1194:	91 05       	cpc	r25, r1
    1196:	08 f0       	brcs	.+2      	; 0x119a <left_degrees+0x3c>
    1198:	40 c0       	rjmp	.+128    	; 0x121a <left_degrees+0xbc>
    119a:	80 91 3c 05 	lds	r24, 0x053C
    119e:	90 91 3d 05 	lds	r25, 0x053D
    11a2:	8f 30       	cpi	r24, 0x0F	; 15
    11a4:	91 05       	cpc	r25, r1
    11a6:	c8 f5       	brcc	.+114    	; 0x121a <left_degrees+0xbc>
    11a8:	80 91 40 05 	lds	r24, 0x0540
    11ac:	90 91 41 05 	lds	r25, 0x0541
    11b0:	8f 30       	cpi	r24, 0x0F	; 15
    11b2:	91 05       	cpc	r25, r1
    11b4:	90 f5       	brcc	.+100    	; 0x121a <left_degrees+0xbc>
    11b6:	ce e3       	ldi	r28, 0x3E	; 62
    11b8:	d5 e0       	ldi	r29, 0x05	; 5
    11ba:	0c e3       	ldi	r16, 0x3C	; 60
    11bc:	15 e0       	ldi	r17, 0x05	; 5
    11be:	0f 2e       	mov	r0, r31
    11c0:	f0 e4       	ldi	r31, 0x40	; 64
    11c2:	ef 2e       	mov	r14, r31
    11c4:	f5 e0       	ldi	r31, 0x05	; 5
    11c6:	ff 2e       	mov	r15, r31
    11c8:	f0 2d       	mov	r31, r0
	{
		sppeed(255,249);
    11ca:	8f ef       	ldi	r24, 0xFF	; 255
    11cc:	90 e0       	ldi	r25, 0x00	; 0
    11ce:	69 ef       	ldi	r22, 0xF9	; 249
    11d0:	70 e0       	ldi	r23, 0x00	; 0
    11d2:	0e 94 f7 00 	call	0x1ee	; 0x1ee <sppeed>
		if(node_number==10 || node_number==0)
    11d6:	80 91 5f 02 	lds	r24, 0x025F
    11da:	90 91 60 02 	lds	r25, 0x0260
    11de:	8a 30       	cpi	r24, 0x0A	; 10
    11e0:	91 05       	cpc	r25, r1
    11e2:	11 f0       	breq	.+4      	; 0x11e8 <left_degrees+0x8a>
    11e4:	00 97       	sbiw	r24, 0x00	; 0
    11e6:	31 f4       	brne	.+12     	; 0x11f4 <left_degrees+0x96>
		sppeed(180,174);
    11e8:	84 eb       	ldi	r24, 0xB4	; 180
    11ea:	90 e0       	ldi	r25, 0x00	; 0
    11ec:	6e ea       	ldi	r22, 0xAE	; 174
    11ee:	70 e0       	ldi	r23, 0x00	; 0
    11f0:	0e 94 f7 00 	call	0x1ee	; 0x1ee <sppeed>
		left();
    11f4:	0e 94 2a 08 	call	0x1054	; 0x1054 <left>
{
	// 88 pulses for 360 degrees rotation 4.090 degrees per count
	navigation_in_degrees = navigation_in_degrees + Degrees;
	left(); //Turn left
	angle_rotate(Degrees);
	while(digital[2]<15 && digital[1]<15 && digital[3]<15)
    11f8:	88 81       	ld	r24, Y
    11fa:	99 81       	ldd	r25, Y+1	; 0x01
    11fc:	8f 30       	cpi	r24, 0x0F	; 15
    11fe:	91 05       	cpc	r25, r1
    1200:	60 f4       	brcc	.+24     	; 0x121a <left_degrees+0xbc>
    1202:	f8 01       	movw	r30, r16
    1204:	80 81       	ld	r24, Z
    1206:	91 81       	ldd	r25, Z+1	; 0x01
    1208:	8f 30       	cpi	r24, 0x0F	; 15
    120a:	91 05       	cpc	r25, r1
    120c:	30 f4       	brcc	.+12     	; 0x121a <left_degrees+0xbc>
    120e:	f7 01       	movw	r30, r14
    1210:	80 81       	ld	r24, Z
    1212:	91 81       	ldd	r25, Z+1	; 0x01
    1214:	8f 30       	cpi	r24, 0x0F	; 15
    1216:	91 05       	cpc	r25, r1
    1218:	c0 f2       	brcs	.-80     	; 0x11ca <left_degrees+0x6c>
		sppeed(255,249);
		if(node_number==10 || node_number==0)
		sppeed(180,174);
		left();
	}
	stop();
    121a:	0e 94 26 08 	call	0x104c	; 0x104c <stop>
}
    121e:	df 91       	pop	r29
    1220:	cf 91       	pop	r28
    1222:	1f 91       	pop	r17
    1224:	0f 91       	pop	r16
    1226:	ff 90       	pop	r15
    1228:	ef 90       	pop	r14
    122a:	08 95       	ret

0000122c <right_degrees>:
* Example Call:				right_degrees(90);
*
*/

void right_degrees(unsigned int Degrees)
{
    122c:	ef 92       	push	r14
    122e:	ff 92       	push	r15
    1230:	0f 93       	push	r16
    1232:	1f 93       	push	r17
    1234:	cf 93       	push	r28
    1236:	df 93       	push	r29
    1238:	ec 01       	movw	r28, r24
	// 88 pulses for 360 degrees rotation 4.090 degrees per count
	navigation_in_degrees=navigation_in_degrees-Degrees;
    123a:	80 91 3d 02 	lds	r24, 0x023D
    123e:	90 91 3e 02 	lds	r25, 0x023E
    1242:	8c 1b       	sub	r24, r28
    1244:	9d 0b       	sbc	r25, r29
    1246:	90 93 3e 02 	sts	0x023E, r25
    124a:	80 93 3d 02 	sts	0x023D, r24
	right(); //Turn right
    124e:	0e 94 2e 08 	call	0x105c	; 0x105c <right>
	angle_rotate(Degrees);
    1252:	ce 01       	movw	r24, r28
    1254:	0e 94 3a 08 	call	0x1074	; 0x1074 <angle_rotate>
	while(digital[2]<15 && digital[3]<15 && digital[1]<15)
    1258:	80 91 3e 05 	lds	r24, 0x053E
    125c:	90 91 3f 05 	lds	r25, 0x053F
    1260:	8f 30       	cpi	r24, 0x0F	; 15
    1262:	91 05       	cpc	r25, r1
    1264:	08 f0       	brcs	.+2      	; 0x1268 <right_degrees+0x3c>
    1266:	40 c0       	rjmp	.+128    	; 0x12e8 <right_degrees+0xbc>
    1268:	80 91 40 05 	lds	r24, 0x0540
    126c:	90 91 41 05 	lds	r25, 0x0541
    1270:	8f 30       	cpi	r24, 0x0F	; 15
    1272:	91 05       	cpc	r25, r1
    1274:	c8 f5       	brcc	.+114    	; 0x12e8 <right_degrees+0xbc>
    1276:	80 91 3c 05 	lds	r24, 0x053C
    127a:	90 91 3d 05 	lds	r25, 0x053D
    127e:	8f 30       	cpi	r24, 0x0F	; 15
    1280:	91 05       	cpc	r25, r1
    1282:	90 f5       	brcc	.+100    	; 0x12e8 <right_degrees+0xbc>
    1284:	ce e3       	ldi	r28, 0x3E	; 62
    1286:	d5 e0       	ldi	r29, 0x05	; 5
    1288:	00 e4       	ldi	r16, 0x40	; 64
    128a:	15 e0       	ldi	r17, 0x05	; 5
    128c:	0f 2e       	mov	r0, r31
    128e:	fc e3       	ldi	r31, 0x3C	; 60
    1290:	ef 2e       	mov	r14, r31
    1292:	f5 e0       	ldi	r31, 0x05	; 5
    1294:	ff 2e       	mov	r15, r31
    1296:	f0 2d       	mov	r31, r0
	{
		sppeed(255,249);
    1298:	8f ef       	ldi	r24, 0xFF	; 255
    129a:	90 e0       	ldi	r25, 0x00	; 0
    129c:	69 ef       	ldi	r22, 0xF9	; 249
    129e:	70 e0       	ldi	r23, 0x00	; 0
    12a0:	0e 94 f7 00 	call	0x1ee	; 0x1ee <sppeed>
		if(node_number==10 || node_number==0)
    12a4:	80 91 5f 02 	lds	r24, 0x025F
    12a8:	90 91 60 02 	lds	r25, 0x0260
    12ac:	8a 30       	cpi	r24, 0x0A	; 10
    12ae:	91 05       	cpc	r25, r1
    12b0:	11 f0       	breq	.+4      	; 0x12b6 <right_degrees+0x8a>
    12b2:	00 97       	sbiw	r24, 0x00	; 0
    12b4:	31 f4       	brne	.+12     	; 0x12c2 <right_degrees+0x96>
		sppeed(180,174);
    12b6:	84 eb       	ldi	r24, 0xB4	; 180
    12b8:	90 e0       	ldi	r25, 0x00	; 0
    12ba:	6e ea       	ldi	r22, 0xAE	; 174
    12bc:	70 e0       	ldi	r23, 0x00	; 0
    12be:	0e 94 f7 00 	call	0x1ee	; 0x1ee <sppeed>
		right();
    12c2:	0e 94 2e 08 	call	0x105c	; 0x105c <right>
{
	// 88 pulses for 360 degrees rotation 4.090 degrees per count
	navigation_in_degrees=navigation_in_degrees-Degrees;
	right(); //Turn right
	angle_rotate(Degrees);
	while(digital[2]<15 && digital[3]<15 && digital[1]<15)
    12c6:	88 81       	ld	r24, Y
    12c8:	99 81       	ldd	r25, Y+1	; 0x01
    12ca:	8f 30       	cpi	r24, 0x0F	; 15
    12cc:	91 05       	cpc	r25, r1
    12ce:	60 f4       	brcc	.+24     	; 0x12e8 <right_degrees+0xbc>
    12d0:	f8 01       	movw	r30, r16
    12d2:	80 81       	ld	r24, Z
    12d4:	91 81       	ldd	r25, Z+1	; 0x01
    12d6:	8f 30       	cpi	r24, 0x0F	; 15
    12d8:	91 05       	cpc	r25, r1
    12da:	30 f4       	brcc	.+12     	; 0x12e8 <right_degrees+0xbc>
    12dc:	f7 01       	movw	r30, r14
    12de:	80 81       	ld	r24, Z
    12e0:	91 81       	ldd	r25, Z+1	; 0x01
    12e2:	8f 30       	cpi	r24, 0x0F	; 15
    12e4:	91 05       	cpc	r25, r1
    12e6:	c0 f2       	brcs	.-80     	; 0x1298 <right_degrees+0x6c>
		sppeed(255,249);
		if(node_number==10 || node_number==0)
		sppeed(180,174);
		right();
	}
	stop();
    12e8:	0e 94 26 08 	call	0x104c	; 0x104c <stop>
}
    12ec:	df 91       	pop	r29
    12ee:	cf 91       	pop	r28
    12f0:	1f 91       	pop	r17
    12f2:	0f 91       	pop	r16
    12f4:	ff 90       	pop	r15
    12f6:	ef 90       	pop	r14
    12f8:	08 95       	ret

000012fa <soft_left_degrees>:
* Example Call:				soft_left_degrees(90);
*
*/

void soft_left_degrees(unsigned int Degrees)
{
    12fa:	cf 93       	push	r28
    12fc:	df 93       	push	r29
    12fe:	ec 01       	movw	r28, r24
	navigation_in_degrees=navigation_in_degrees+Degrees;
    1300:	80 91 3d 02 	lds	r24, 0x023D
    1304:	90 91 3e 02 	lds	r25, 0x023E
    1308:	8c 0f       	add	r24, r28
    130a:	9d 1f       	adc	r25, r29
    130c:	90 93 3e 02 	sts	0x023E, r25
    1310:	80 93 3d 02 	sts	0x023D, r24
	// 176 pulses for 360 degrees rotation 2.045 degrees per count
	soft_left(); //Turn soft left
    1314:	0e 94 32 08 	call	0x1064	; 0x1064 <soft_left>
	Degrees=Degrees*2;
	angle_rotate(Degrees);
    1318:	ce 01       	movw	r24, r28
    131a:	88 0f       	add	r24, r24
    131c:	99 1f       	adc	r25, r25
    131e:	0e 94 3a 08 	call	0x1074	; 0x1074 <angle_rotate>
}
    1322:	df 91       	pop	r29
    1324:	cf 91       	pop	r28
    1326:	08 95       	ret

00001328 <soft_right_degrees>:
* Example Call:				soft_right_degrees(90);
*
*/

void soft_right_degrees(unsigned int Degrees)
{
    1328:	cf 93       	push	r28
    132a:	df 93       	push	r29
    132c:	ec 01       	movw	r28, r24
	navigation_in_degrees=navigation_in_degrees-Degrees;
    132e:	80 91 3d 02 	lds	r24, 0x023D
    1332:	90 91 3e 02 	lds	r25, 0x023E
    1336:	8c 1b       	sub	r24, r28
    1338:	9d 0b       	sbc	r25, r29
    133a:	90 93 3e 02 	sts	0x023E, r25
    133e:	80 93 3d 02 	sts	0x023D, r24
	// 176 pulses for 360 degrees rotation 2.045 degrees per count
	soft_right();  //Turn soft right
    1342:	0e 94 36 08 	call	0x106c	; 0x106c <soft_right>
	Degrees=Degrees*2;
	angle_rotate(Degrees);
    1346:	ce 01       	movw	r24, r28
    1348:	88 0f       	add	r24, r24
    134a:	99 1f       	adc	r25, r25
    134c:	0e 94 3a 08 	call	0x1074	; 0x1074 <angle_rotate>
}
    1350:	df 91       	pop	r29
    1352:	cf 91       	pop	r28
    1354:	08 95       	ret

00001356 <INT_position>:
*
*/

void INT_position(void)
{
	cli(); //Clears the global interrupt
    1356:	f8 94       	cli
	port_init();  //Initializes all the ports
    1358:	0e 94 19 08 	call	0x1032	; 0x1032 <port_init>
	EICRB = EICRB | 0x08; // INT5 is set to trigger with falling edge
    135c:	ea e6       	ldi	r30, 0x6A	; 106
    135e:	f0 e0       	ldi	r31, 0x00	; 0
    1360:	80 81       	ld	r24, Z
    1362:	88 60       	ori	r24, 0x08	; 8
    1364:	80 83       	st	Z, r24
	EIMSK = EIMSK | 0x20; // Enable Interrupt INT5 for right position encoder
    1366:	ed 9a       	sbi	0x1d, 5	; 29
	EICRB = EICRB | 0x02; // INT4 is set to trigger with falling edge
    1368:	80 81       	ld	r24, Z
    136a:	82 60       	ori	r24, 0x02	; 2
    136c:	80 83       	st	Z, r24
	EIMSK = EIMSK | 0x10; // Enable Interrupt INT4 for left position encoder
    136e:	ec 9a       	sbi	0x1d, 4	; 29
	sei();   // Enables the global interrupt
    1370:	78 94       	sei
}
    1372:	08 95       	ret

00001374 <servo_config>:
*
*/

void servo_config(void)
{
	cli();
    1374:	f8 94       	cli
	TCNT1=0x0000;							// set starting value of counter
    1376:	10 92 85 00 	sts	0x0085, r1
    137a:	10 92 84 00 	sts	0x0084, r1
	ICR1=1150;								// set top value of counter
    137e:	8e e7       	ldi	r24, 0x7E	; 126
    1380:	94 e0       	ldi	r25, 0x04	; 4
    1382:	90 93 87 00 	sts	0x0087, r25
    1386:	80 93 86 00 	sts	0x0086, r24
	TCCR1A=0b10101010;						// counter configuring
    138a:	2a ea       	ldi	r18, 0xAA	; 170
    138c:	20 93 80 00 	sts	0x0080, r18
	TCCR1B=0b00011100;
    1390:	2c e1       	ldi	r18, 0x1C	; 28
    1392:	20 93 81 00 	sts	0x0081, r18
	DDRB=DDRB|0b11100000;					// set Output Compare pins as output pins
    1396:	24 b1       	in	r18, 0x04	; 4
    1398:	20 6e       	ori	r18, 0xE0	; 224
    139a:	24 b9       	out	0x04, r18	; 4
	PORTB=PORTB|0b1110000;
    139c:	25 b1       	in	r18, 0x05	; 5
    139e:	20 67       	ori	r18, 0x70	; 112
    13a0:	25 b9       	out	0x05, r18	; 5
	OCR1A=1150;								// to free the servo
    13a2:	90 93 89 00 	sts	0x0089, r25
    13a6:	80 93 88 00 	sts	0x0088, r24
	OCR1B=1150;
    13aa:	90 93 8b 00 	sts	0x008B, r25
    13ae:	80 93 8a 00 	sts	0x008A, r24
	OCR1C=1150;
    13b2:	90 93 8d 00 	sts	0x008D, r25
    13b6:	80 93 8c 00 	sts	0x008C, r24
	sei();
    13ba:	78 94       	sei
}
    13bc:	08 95       	ret

000013be <servo1_mov>:
* Example Call:					servo1_mov(10);
*
*/

void servo1_mov(int degree)
{
    13be:	cf 93       	push	r28
    13c0:	df 93       	push	r29
    13c2:	ec 01       	movw	r28, r24

	if(node_number==13)
    13c4:	80 91 5f 02 	lds	r24, 0x025F
    13c8:	90 91 60 02 	lds	r25, 0x0260
    13cc:	8d 30       	cpi	r24, 0x0D	; 13
    13ce:	91 05       	cpc	r25, r1
    13d0:	e1 f4       	brne	.+56     	; 0x140a <servo1_mov+0x4c>
	OCR1A=((degree/1.89)+25);
    13d2:	be 01       	movw	r22, r28
    13d4:	88 27       	eor	r24, r24
    13d6:	77 fd       	sbrc	r23, 7
    13d8:	80 95       	com	r24
    13da:	98 2f       	mov	r25, r24
    13dc:	0e 94 b4 18 	call	0x3168	; 0x3168 <__floatsisf>
    13e0:	25 e8       	ldi	r18, 0x85	; 133
    13e2:	3b ee       	ldi	r19, 0xEB	; 235
    13e4:	41 ef       	ldi	r20, 0xF1	; 241
    13e6:	5f e3       	ldi	r21, 0x3F	; 63
    13e8:	0e 94 19 18 	call	0x3032	; 0x3032 <__divsf3>
    13ec:	20 e0       	ldi	r18, 0x00	; 0
    13ee:	30 e0       	ldi	r19, 0x00	; 0
    13f0:	48 ec       	ldi	r20, 0xC8	; 200
    13f2:	51 e4       	ldi	r21, 0x41	; 65
    13f4:	0e 94 9e 17 	call	0x2f3c	; 0x2f3c <__addsf3>
    13f8:	0e 94 86 18 	call	0x310c	; 0x310c <__fixunssfsi>
    13fc:	dc 01       	movw	r26, r24
    13fe:	cb 01       	movw	r24, r22
    1400:	90 93 89 00 	sts	0x0089, r25
    1404:	80 93 88 00 	sts	0x0088, r24
    1408:	1d c0       	rjmp	.+58     	; 0x1444 <servo1_mov+0x86>
	else
	OCR1A=ceil(((degree/1.89)+25));
    140a:	be 01       	movw	r22, r28
    140c:	88 27       	eor	r24, r24
    140e:	77 fd       	sbrc	r23, 7
    1410:	80 95       	com	r24
    1412:	98 2f       	mov	r25, r24
    1414:	0e 94 b4 18 	call	0x3168	; 0x3168 <__floatsisf>
    1418:	25 e8       	ldi	r18, 0x85	; 133
    141a:	3b ee       	ldi	r19, 0xEB	; 235
    141c:	41 ef       	ldi	r20, 0xF1	; 241
    141e:	5f e3       	ldi	r21, 0x3F	; 63
    1420:	0e 94 19 18 	call	0x3032	; 0x3032 <__divsf3>
    1424:	20 e0       	ldi	r18, 0x00	; 0
    1426:	30 e0       	ldi	r19, 0x00	; 0
    1428:	48 ec       	ldi	r20, 0xC8	; 200
    142a:	51 e4       	ldi	r21, 0x41	; 65
    142c:	0e 94 9e 17 	call	0x2f3c	; 0x2f3c <__addsf3>
    1430:	0e 94 02 18 	call	0x3004	; 0x3004 <ceil>
    1434:	0e 94 86 18 	call	0x310c	; 0x310c <__fixunssfsi>
    1438:	dc 01       	movw	r26, r24
    143a:	cb 01       	movw	r24, r22
    143c:	90 93 89 00 	sts	0x0089, r25
    1440:	80 93 88 00 	sts	0x0088, r24
	servo_angle_1=degree;
    1444:	d0 93 42 02 	sts	0x0242, r29
    1448:	c0 93 41 02 	sts	0x0241, r28
}
    144c:	df 91       	pop	r29
    144e:	cf 91       	pop	r28
    1450:	08 95       	ret

00001452 <servo2_mov>:
* Example Call:					servo2_mov(10);
*
*/

void servo2_mov(int degree)
{
    1452:	cf 93       	push	r28
    1454:	df 93       	push	r29
    1456:	ec 01       	movw	r28, r24
	OCR1B=ceil(((degree/1.89)+25));
    1458:	be 01       	movw	r22, r28
    145a:	88 27       	eor	r24, r24
    145c:	77 fd       	sbrc	r23, 7
    145e:	80 95       	com	r24
    1460:	98 2f       	mov	r25, r24
    1462:	0e 94 b4 18 	call	0x3168	; 0x3168 <__floatsisf>
    1466:	25 e8       	ldi	r18, 0x85	; 133
    1468:	3b ee       	ldi	r19, 0xEB	; 235
    146a:	41 ef       	ldi	r20, 0xF1	; 241
    146c:	5f e3       	ldi	r21, 0x3F	; 63
    146e:	0e 94 19 18 	call	0x3032	; 0x3032 <__divsf3>
    1472:	20 e0       	ldi	r18, 0x00	; 0
    1474:	30 e0       	ldi	r19, 0x00	; 0
    1476:	48 ec       	ldi	r20, 0xC8	; 200
    1478:	51 e4       	ldi	r21, 0x41	; 65
    147a:	0e 94 9e 17 	call	0x2f3c	; 0x2f3c <__addsf3>
    147e:	0e 94 02 18 	call	0x3004	; 0x3004 <ceil>
    1482:	0e 94 86 18 	call	0x310c	; 0x310c <__fixunssfsi>
    1486:	dc 01       	movw	r26, r24
    1488:	cb 01       	movw	r24, r22
    148a:	90 93 8b 00 	sts	0x008B, r25
    148e:	80 93 8a 00 	sts	0x008A, r24
	servo_angle_2=degree;
    1492:	d0 93 40 02 	sts	0x0240, r29
    1496:	c0 93 3f 02 	sts	0x023F, r28
}
    149a:	df 91       	pop	r29
    149c:	cf 91       	pop	r28
    149e:	08 95       	ret

000014a0 <servo1_free>:
*
*/

void servo1_free(void)
{
	OCR1A=1150;
    14a0:	8e e7       	ldi	r24, 0x7E	; 126
    14a2:	94 e0       	ldi	r25, 0x04	; 4
    14a4:	90 93 89 00 	sts	0x0089, r25
    14a8:	80 93 88 00 	sts	0x0088, r24
}
    14ac:	08 95       	ret

000014ae <servo2_free>:
*
*/

void servo2_free(void)
{
	OCR1B=1150;
    14ae:	8e e7       	ldi	r24, 0x7E	; 126
    14b0:	94 e0       	ldi	r25, 0x04	; 4
    14b2:	90 93 8b 00 	sts	0x008B, r25
    14b6:	80 93 8a 00 	sts	0x008A, r24
}
    14ba:	08 95       	ret

000014bc <pick_waste>:
*/


void pick_waste(void)
{
	servo2_mov(5);
    14bc:	85 e0       	ldi	r24, 0x05	; 5
    14be:	90 e0       	ldi	r25, 0x00	; 0
    14c0:	0e 94 29 0a 	call	0x1452	; 0x1452 <servo2_mov>
    14c4:	8f ef       	ldi	r24, 0xFF	; 255
    14c6:	9f ef       	ldi	r25, 0xFF	; 255
    14c8:	ac e2       	ldi	r26, 0x2C	; 44
    14ca:	81 50       	subi	r24, 0x01	; 1
    14cc:	90 40       	sbci	r25, 0x00	; 0
    14ce:	a0 40       	sbci	r26, 0x00	; 0
    14d0:	e1 f7       	brne	.-8      	; 0x14ca <pick_waste+0xe>
    14d2:	00 c0       	rjmp	.+0      	; 0x14d4 <pick_waste+0x18>
    14d4:	00 00       	nop
	_delay_ms(1000);
}
    14d6:	08 95       	ret

000014d8 <ADC_config>:
*/


void ADC_config(void)
{
	cli();
    14d8:	f8 94       	cli
	TCCR3A=0x00;
    14da:	10 92 90 00 	sts	0x0090, r1
	TCCR3B=0x02; // with clock setting 8
    14de:	82 e0       	ldi	r24, 0x02	; 2
    14e0:	80 93 91 00 	sts	0x0091, r24
	TCCR3C=0x00;
    14e4:	10 92 92 00 	sts	0x0092, r1
	TIMSK3=0x01; // to enable timer overflow interrupt
    14e8:	81 e0       	ldi	r24, 0x01	; 1
    14ea:	80 93 71 00 	sts	0x0071, r24
	DDRF = 0x00; //set PORTF direction as input
    14ee:	10 ba       	out	0x10, r1	; 16
	PORTF = 0x00; //set PORTF pins floating
    14f0:	11 ba       	out	0x11, r1	; 17
	DDRK = 0x00; //set PORTK direction as input
    14f2:	10 92 07 01 	sts	0x0107, r1
	PORTK = 0x00; //set PORTK pins floating
    14f6:	10 92 08 01 	sts	0x0108, r1
	ADCSRA = 0x00;
    14fa:	ea e7       	ldi	r30, 0x7A	; 122
    14fc:	f0 e0       	ldi	r31, 0x00	; 0
    14fe:	10 82       	st	Z, r1
	ADCSRB = 0x00;		//MUX5 = 0
    1500:	10 92 7b 00 	sts	0x007B, r1
	ADMUX = 0x20;		//Vref=5V external --- ADLAR=1 --- MUX4:0 = 0000
    1504:	80 e2       	ldi	r24, 0x20	; 32
    1506:	80 93 7c 00 	sts	0x007C, r24
	ACSR = 0x80;
    150a:	80 e8       	ldi	r24, 0x80	; 128
    150c:	80 bf       	out	0x30, r24	; 48
	ADCSRA = 0x86;		//ADEN=1 --- ADIE=1 --- ADPS2:0 = 1 1 0
    150e:	86 e8       	ldi	r24, 0x86	; 134
    1510:	80 83       	st	Z, r24
}
    1512:	08 95       	ret

00001514 <getdata>:
*/

int getdata(int Ch)
{
	int a;									//a -> digital value which stores the digital value of ADCH register
	if(Ch>7)
    1514:	88 30       	cpi	r24, 0x08	; 8
    1516:	91 05       	cpc	r25, r1
    1518:	1c f0       	brlt	.+6      	; 0x1520 <getdata+0xc>
	{
		ADCSRB = 0x08;
    151a:	28 e0       	ldi	r18, 0x08	; 8
    151c:	20 93 7b 00 	sts	0x007B, r18
	}
	Ch = Ch & 0x07;
    1520:	87 70       	andi	r24, 0x07	; 7
    1522:	90 70       	andi	r25, 0x00	; 0
	ADMUX= 0x20| Ch;
    1524:	80 62       	ori	r24, 0x20	; 32
    1526:	80 93 7c 00 	sts	0x007C, r24
	ADCSRA = ADCSRA | 0x40;		//Set start conversion bit
    152a:	ea e7       	ldi	r30, 0x7A	; 122
    152c:	f0 e0       	ldi	r31, 0x00	; 0
    152e:	80 81       	ld	r24, Z
    1530:	80 64       	ori	r24, 0x40	; 64
    1532:	80 83       	st	Z, r24
	while((ADCSRA&0x10)==0);	//Wait for ADC conversion to complete
    1534:	80 81       	ld	r24, Z
    1536:	84 ff       	sbrs	r24, 4
    1538:	fd cf       	rjmp	.-6      	; 0x1534 <getdata+0x20>
	a=ADCH;
    153a:	80 91 79 00 	lds	r24, 0x0079
	ADCSRA = ADCSRA|0x10; //clear ADIF (ADC Interrupt Flag) by writing 1 to it
    153e:	ea e7       	ldi	r30, 0x7A	; 122
    1540:	f0 e0       	ldi	r31, 0x00	; 0
    1542:	90 81       	ld	r25, Z
    1544:	90 61       	ori	r25, 0x10	; 16
    1546:	90 83       	st	Z, r25
	ADCSRB = 0x00;
    1548:	10 92 7b 00 	sts	0x007B, r1
	return a;
}
    154c:	90 e0       	ldi	r25, 0x00	; 0
    154e:	08 95       	ret

00001550 <__vector_6>:
* Example Call:								NONE
*
*/

ISR(INT5_vect) 
{
    1550:	1f 92       	push	r1
    1552:	0f 92       	push	r0
    1554:	0f b6       	in	r0, 0x3f	; 63
    1556:	0f 92       	push	r0
    1558:	0b b6       	in	r0, 0x3b	; 59
    155a:	0f 92       	push	r0
    155c:	11 24       	eor	r1, r1
    155e:	0f 93       	push	r16
    1560:	1f 93       	push	r17
    1562:	2f 93       	push	r18
    1564:	3f 93       	push	r19
    1566:	4f 93       	push	r20
    1568:	5f 93       	push	r21
    156a:	6f 93       	push	r22
    156c:	7f 93       	push	r23
    156e:	8f 93       	push	r24
    1570:	9f 93       	push	r25
    1572:	af 93       	push	r26
    1574:	bf 93       	push	r27
    1576:	cf 93       	push	r28
    1578:	df 93       	push	r29
    157a:	ef 93       	push	r30
    157c:	ff 93       	push	r31
	int i=0;
	right_position_encode++;
    157e:	80 91 61 02 	lds	r24, 0x0261
    1582:	90 91 62 02 	lds	r25, 0x0262
    1586:	a0 91 63 02 	lds	r26, 0x0263
    158a:	b0 91 64 02 	lds	r27, 0x0264
    158e:	01 96       	adiw	r24, 0x01	; 1
    1590:	a1 1d       	adc	r26, r1
    1592:	b1 1d       	adc	r27, r1
    1594:	80 93 61 02 	sts	0x0261, r24
    1598:	90 93 62 02 	sts	0x0262, r25
    159c:	a0 93 63 02 	sts	0x0263, r26
    15a0:	b0 93 64 02 	sts	0x0264, r27
	if(abs(navigation_in_degrees)==360)
    15a4:	80 91 3d 02 	lds	r24, 0x023D
    15a8:	90 91 3e 02 	lds	r25, 0x023E
    15ac:	99 23       	and	r25, r25
    15ae:	1c f4       	brge	.+6      	; 0x15b6 <__vector_6+0x66>
    15b0:	90 95       	com	r25
    15b2:	81 95       	neg	r24
    15b4:	9f 4f       	sbci	r25, 0xFF	; 255
    15b6:	21 e0       	ldi	r18, 0x01	; 1
    15b8:	88 36       	cpi	r24, 0x68	; 104
    15ba:	92 07       	cpc	r25, r18
    15bc:	21 f4       	brne	.+8      	; 0x15c6 <__vector_6+0x76>
	navigation_in_degrees=0;
    15be:	10 92 3e 02 	sts	0x023E, r1
    15c2:	10 92 3d 02 	sts	0x023D, r1
* Example Call:								NONE
*
*/

ISR(INT5_vect) 
{
    15c6:	c0 e0       	ldi	r28, 0x00	; 0
    15c8:	d0 e0       	ldi	r29, 0x00	; 0
	right_position_encode++;
	if(abs(navigation_in_degrees)==360)
	navigation_in_degrees=0;
	//i: will iterate from 0 to the channel length
	for(i=0;i<16;i++)
	digital[i]=getdata(i);
    15ca:	0a e3       	ldi	r16, 0x3A	; 58
    15cc:	15 e0       	ldi	r17, 0x05	; 5
    15ce:	ce 01       	movw	r24, r28
    15d0:	0e 94 8a 0a 	call	0x1514	; 0x1514 <getdata>
    15d4:	28 2f       	mov	r18, r24
    15d6:	39 2f       	mov	r19, r25
    15d8:	fe 01       	movw	r30, r28
    15da:	ee 0f       	add	r30, r30
    15dc:	ff 1f       	adc	r31, r31
    15de:	e0 0f       	add	r30, r16
    15e0:	f1 1f       	adc	r31, r17
    15e2:	31 83       	std	Z+1, r19	; 0x01
    15e4:	20 83       	st	Z, r18
	int i=0;
	right_position_encode++;
	if(abs(navigation_in_degrees)==360)
	navigation_in_degrees=0;
	//i: will iterate from 0 to the channel length
	for(i=0;i<16;i++)
    15e6:	21 96       	adiw	r28, 0x01	; 1
    15e8:	c0 31       	cpi	r28, 0x10	; 16
    15ea:	d1 05       	cpc	r29, r1
    15ec:	81 f7       	brne	.-32     	; 0x15ce <__vector_6+0x7e>
	digital[i]=getdata(i);
}
    15ee:	ff 91       	pop	r31
    15f0:	ef 91       	pop	r30
    15f2:	df 91       	pop	r29
    15f4:	cf 91       	pop	r28
    15f6:	bf 91       	pop	r27
    15f8:	af 91       	pop	r26
    15fa:	9f 91       	pop	r25
    15fc:	8f 91       	pop	r24
    15fe:	7f 91       	pop	r23
    1600:	6f 91       	pop	r22
    1602:	5f 91       	pop	r21
    1604:	4f 91       	pop	r20
    1606:	3f 91       	pop	r19
    1608:	2f 91       	pop	r18
    160a:	1f 91       	pop	r17
    160c:	0f 91       	pop	r16
    160e:	0f 90       	pop	r0
    1610:	0b be       	out	0x3b, r0	; 59
    1612:	0f 90       	pop	r0
    1614:	0f be       	out	0x3f, r0	; 63
    1616:	0f 90       	pop	r0
    1618:	1f 90       	pop	r1
    161a:	18 95       	reti

0000161c <__vector_5>:
* Example Call:								NONE
*
*/

ISR(INT4_vect)
{
    161c:	1f 92       	push	r1
    161e:	0f 92       	push	r0
    1620:	0f b6       	in	r0, 0x3f	; 63
    1622:	0f 92       	push	r0
    1624:	0b b6       	in	r0, 0x3b	; 59
    1626:	0f 92       	push	r0
    1628:	11 24       	eor	r1, r1
    162a:	0f 93       	push	r16
    162c:	1f 93       	push	r17
    162e:	2f 93       	push	r18
    1630:	3f 93       	push	r19
    1632:	4f 93       	push	r20
    1634:	5f 93       	push	r21
    1636:	6f 93       	push	r22
    1638:	7f 93       	push	r23
    163a:	8f 93       	push	r24
    163c:	9f 93       	push	r25
    163e:	af 93       	push	r26
    1640:	bf 93       	push	r27
    1642:	cf 93       	push	r28
    1644:	df 93       	push	r29
    1646:	ef 93       	push	r30
    1648:	ff 93       	push	r31
	int i=0;
	left_position_encode++;
    164a:	80 91 65 02 	lds	r24, 0x0265
    164e:	90 91 66 02 	lds	r25, 0x0266
    1652:	a0 91 67 02 	lds	r26, 0x0267
    1656:	b0 91 68 02 	lds	r27, 0x0268
    165a:	01 96       	adiw	r24, 0x01	; 1
    165c:	a1 1d       	adc	r26, r1
    165e:	b1 1d       	adc	r27, r1
    1660:	80 93 65 02 	sts	0x0265, r24
    1664:	90 93 66 02 	sts	0x0266, r25
    1668:	a0 93 67 02 	sts	0x0267, r26
    166c:	b0 93 68 02 	sts	0x0268, r27
	if(abs(navigation_in_degrees)==360)
    1670:	80 91 3d 02 	lds	r24, 0x023D
    1674:	90 91 3e 02 	lds	r25, 0x023E
    1678:	99 23       	and	r25, r25
    167a:	1c f4       	brge	.+6      	; 0x1682 <__vector_5+0x66>
    167c:	90 95       	com	r25
    167e:	81 95       	neg	r24
    1680:	9f 4f       	sbci	r25, 0xFF	; 255
    1682:	21 e0       	ldi	r18, 0x01	; 1
    1684:	88 36       	cpi	r24, 0x68	; 104
    1686:	92 07       	cpc	r25, r18
    1688:	21 f4       	brne	.+8      	; 0x1692 <__vector_5+0x76>
	navigation_in_degrees=0;
    168a:	10 92 3e 02 	sts	0x023E, r1
    168e:	10 92 3d 02 	sts	0x023D, r1
* Example Call:								NONE
*
*/

ISR(INT4_vect)
{
    1692:	c0 e0       	ldi	r28, 0x00	; 0
    1694:	d0 e0       	ldi	r29, 0x00	; 0
	left_position_encode++;
	if(abs(navigation_in_degrees)==360)
	navigation_in_degrees=0;
	//i: will iterate from 0 to the channel length
	for(i=0;i<16;i++)
	digital[i]=getdata(i);
    1696:	0a e3       	ldi	r16, 0x3A	; 58
    1698:	15 e0       	ldi	r17, 0x05	; 5
    169a:	ce 01       	movw	r24, r28
    169c:	0e 94 8a 0a 	call	0x1514	; 0x1514 <getdata>
    16a0:	28 2f       	mov	r18, r24
    16a2:	39 2f       	mov	r19, r25
    16a4:	fe 01       	movw	r30, r28
    16a6:	ee 0f       	add	r30, r30
    16a8:	ff 1f       	adc	r31, r31
    16aa:	e0 0f       	add	r30, r16
    16ac:	f1 1f       	adc	r31, r17
    16ae:	31 83       	std	Z+1, r19	; 0x01
    16b0:	20 83       	st	Z, r18
	int i=0;
	left_position_encode++;
	if(abs(navigation_in_degrees)==360)
	navigation_in_degrees=0;
	//i: will iterate from 0 to the channel length
	for(i=0;i<16;i++)
    16b2:	21 96       	adiw	r28, 0x01	; 1
    16b4:	c0 31       	cpi	r28, 0x10	; 16
    16b6:	d1 05       	cpc	r29, r1
    16b8:	81 f7       	brne	.-32     	; 0x169a <__vector_5+0x7e>
	digital[i]=getdata(i);
}
    16ba:	ff 91       	pop	r31
    16bc:	ef 91       	pop	r30
    16be:	df 91       	pop	r29
    16c0:	cf 91       	pop	r28
    16c2:	bf 91       	pop	r27
    16c4:	af 91       	pop	r26
    16c6:	9f 91       	pop	r25
    16c8:	8f 91       	pop	r24
    16ca:	7f 91       	pop	r23
    16cc:	6f 91       	pop	r22
    16ce:	5f 91       	pop	r21
    16d0:	4f 91       	pop	r20
    16d2:	3f 91       	pop	r19
    16d4:	2f 91       	pop	r18
    16d6:	1f 91       	pop	r17
    16d8:	0f 91       	pop	r16
    16da:	0f 90       	pop	r0
    16dc:	0b be       	out	0x3b, r0	; 59
    16de:	0f 90       	pop	r0
    16e0:	0f be       	out	0x3f, r0	; 63
    16e2:	0f 90       	pop	r0
    16e4:	1f 90       	pop	r1
    16e6:	18 95       	reti

000016e8 <sharp>:
* Example Call:				sharp(digital[11]);
*	
*/

int sharp(int adc_reading)
{
    16e8:	0f 93       	push	r16
    16ea:	1f 93       	push	r17
	float distance;
	int distanceInt;
	distance = (int)(10.00*(2799.6*(1.00/(pow(adc_reading,1.1546)))));
    16ec:	9c 01       	movw	r18, r24
    16ee:	b9 01       	movw	r22, r18
    16f0:	88 27       	eor	r24, r24
    16f2:	77 fd       	sbrc	r23, 7
    16f4:	80 95       	com	r24
    16f6:	98 2f       	mov	r25, r24
    16f8:	0e 94 b4 18 	call	0x3168	; 0x3168 <__floatsisf>
    16fc:	2f ee       	ldi	r18, 0xEF	; 239
    16fe:	39 ec       	ldi	r19, 0xC9	; 201
    1700:	43 e9       	ldi	r20, 0x93	; 147
    1702:	5f e3       	ldi	r21, 0x3F	; 63
    1704:	0e 94 07 1a 	call	0x340e	; 0x340e <pow>
    1708:	b6 2f       	mov	r27, r22
    170a:	a7 2f       	mov	r26, r23
    170c:	38 2f       	mov	r19, r24
    170e:	29 2f       	mov	r18, r25
    1710:	60 e0       	ldi	r22, 0x00	; 0
    1712:	70 e0       	ldi	r23, 0x00	; 0
    1714:	80 e8       	ldi	r24, 0x80	; 128
    1716:	9f e3       	ldi	r25, 0x3F	; 63
    1718:	42 2f       	mov	r20, r18
    171a:	0b 2f       	mov	r16, r27
    171c:	1a 2f       	mov	r17, r26
    171e:	23 2f       	mov	r18, r19
    1720:	34 2f       	mov	r19, r20
    1722:	a9 01       	movw	r20, r18
    1724:	98 01       	movw	r18, r16
    1726:	0e 94 19 18 	call	0x3032	; 0x3032 <__divsf3>
    172a:	2a e9       	ldi	r18, 0x9A	; 154
    172c:	39 ef       	ldi	r19, 0xF9	; 249
    172e:	4e e2       	ldi	r20, 0x2E	; 46
    1730:	55 e4       	ldi	r21, 0x45	; 69
    1732:	0e 94 a4 19 	call	0x3348	; 0x3348 <__mulsf3>
    1736:	20 e0       	ldi	r18, 0x00	; 0
    1738:	30 e0       	ldi	r19, 0x00	; 0
    173a:	40 e2       	ldi	r20, 0x20	; 32
    173c:	51 e4       	ldi	r21, 0x41	; 65
    173e:	0e 94 a4 19 	call	0x3348	; 0x3348 <__mulsf3>
    1742:	0e 94 81 18 	call	0x3102	; 0x3102 <__fixsfsi>
    1746:	88 27       	eor	r24, r24
    1748:	77 fd       	sbrc	r23, 7
    174a:	80 95       	com	r24
    174c:	98 2f       	mov	r25, r24
    174e:	0e 94 b4 18 	call	0x3168	; 0x3168 <__floatsisf>
	distanceInt = (int)distance;
    1752:	0e 94 81 18 	call	0x3102	; 0x3102 <__fixsfsi>
	if(distanceInt>800)
	{
		distanceInt=800;
	}
	return distanceInt;
    1756:	86 2f       	mov	r24, r22
    1758:	97 2f       	mov	r25, r23
    175a:	33 e0       	ldi	r19, 0x03	; 3
    175c:	81 32       	cpi	r24, 0x21	; 33
    175e:	93 07       	cpc	r25, r19
    1760:	14 f0       	brlt	.+4      	; 0x1766 <sharp+0x7e>
    1762:	80 e2       	ldi	r24, 0x20	; 32
    1764:	93 e0       	ldi	r25, 0x03	; 3
}
    1766:	1f 91       	pop	r17
    1768:	0f 91       	pop	r16
    176a:	08 95       	ret

0000176c <node_behave>:
* Example Call:				node_behave(); 
*
*/

void node_behave(void) 
{
    176c:	af 92       	push	r10
    176e:	bf 92       	push	r11
    1770:	cf 92       	push	r12
    1772:	df 92       	push	r13
    1774:	ef 92       	push	r14
    1776:	ff 92       	push	r15
    1778:	0f 93       	push	r16
    177a:	1f 93       	push	r17
    177c:	cf 93       	push	r28
    177e:	df 93       	push	r29
	int i;
    if(path[path_index]!='\0')
    1780:	e0 91 59 02 	lds	r30, 0x0259
    1784:	f0 91 5a 02 	lds	r31, 0x025A
    1788:	e1 59       	subi	r30, 0x91	; 145
    178a:	fd 4f       	sbci	r31, 0xFD	; 253
    178c:	80 81       	ld	r24, Z
    178e:	88 23       	and	r24, r24
    1790:	09 f4       	brne	.+2      	; 0x1794 <node_behave+0x28>
    1792:	eb c0       	rjmp	.+470    	; 0x196a <node_behave+0x1fe>
	{
		if((node_number==6 && *navigation_pointer=='E' && destinationn_node!=21) ||(node_number==16 && *navigation_pointer=='W') ||(node_number==15 && *navigation_pointer=='W') ||(node_number==17 && *navigation_pointer=='W') )
    1794:	80 91 5f 02 	lds	r24, 0x025F
    1798:	90 91 60 02 	lds	r25, 0x0260
    179c:	86 30       	cpi	r24, 0x06	; 6
    179e:	91 05       	cpc	r25, r1
    17a0:	79 f4       	brne	.+30     	; 0x17c0 <node_behave+0x54>
    17a2:	e0 91 ac 02 	lds	r30, 0x02AC
    17a6:	f0 91 ad 02 	lds	r31, 0x02AD
    17aa:	20 81       	ld	r18, Z
    17ac:	25 34       	cpi	r18, 0x45	; 69
    17ae:	41 f4       	brne	.+16     	; 0x17c0 <node_behave+0x54>
    17b0:	20 91 5d 02 	lds	r18, 0x025D
    17b4:	30 91 5e 02 	lds	r19, 0x025E
    17b8:	25 31       	cpi	r18, 0x15	; 21
    17ba:	31 05       	cpc	r19, r1
    17bc:	09 f5       	brne	.+66     	; 0x1800 <node_behave+0x94>
    17be:	16 c0       	rjmp	.+44     	; 0x17ec <node_behave+0x80>
    17c0:	80 31       	cpi	r24, 0x10	; 16
    17c2:	91 05       	cpc	r25, r1
    17c4:	41 f4       	brne	.+16     	; 0x17d6 <node_behave+0x6a>
    17c6:	e0 91 ac 02 	lds	r30, 0x02AC
    17ca:	f0 91 ad 02 	lds	r31, 0x02AD
    17ce:	20 81       	ld	r18, Z
    17d0:	27 35       	cpi	r18, 0x57	; 87
    17d2:	f9 f4       	brne	.+62     	; 0x1812 <node_behave+0xa6>
    17d4:	15 c0       	rjmp	.+42     	; 0x1800 <node_behave+0x94>
    17d6:	8f 30       	cpi	r24, 0x0F	; 15
    17d8:	91 05       	cpc	r25, r1
    17da:	41 f4       	brne	.+16     	; 0x17ec <node_behave+0x80>
    17dc:	e0 91 ac 02 	lds	r30, 0x02AC
    17e0:	f0 91 ad 02 	lds	r31, 0x02AD
    17e4:	80 81       	ld	r24, Z
    17e6:	87 35       	cpi	r24, 0x57	; 87
    17e8:	01 f5       	brne	.+64     	; 0x182a <node_behave+0xbe>
    17ea:	0a c0       	rjmp	.+20     	; 0x1800 <node_behave+0x94>
    17ec:	81 31       	cpi	r24, 0x11	; 17
    17ee:	91 05       	cpc	r25, r1
    17f0:	81 f4       	brne	.+32     	; 0x1812 <node_behave+0xa6>
    17f2:	e0 91 ac 02 	lds	r30, 0x02AC
    17f6:	f0 91 ad 02 	lds	r31, 0x02AD
    17fa:	80 81       	ld	r24, Z
    17fc:	87 35       	cpi	r24, 0x57	; 87
    17fe:	a9 f4       	brne	.+42     	; 0x182a <node_behave+0xbe>
		distance('f',3,'o');
    1800:	86 e6       	ldi	r24, 0x66	; 102
    1802:	40 e0       	ldi	r20, 0x00	; 0
    1804:	50 e0       	ldi	r21, 0x00	; 0
    1806:	60 e4       	ldi	r22, 0x40	; 64
    1808:	70 e4       	ldi	r23, 0x40	; 64
    180a:	2f e6       	ldi	r18, 0x6F	; 111
    180c:	0e 94 a0 07 	call	0xf40	; 0xf40 <distance>
    1810:	14 c0       	rjmp	.+40     	; 0x183a <node_behave+0xce>
		else if(node_number==14)
    1812:	8e 30       	cpi	r24, 0x0E	; 14
    1814:	91 05       	cpc	r25, r1
    1816:	49 f4       	brne	.+18     	; 0x182a <node_behave+0xbe>
		distance('f',7,'o');
    1818:	86 e6       	ldi	r24, 0x66	; 102
    181a:	40 e0       	ldi	r20, 0x00	; 0
    181c:	50 e0       	ldi	r21, 0x00	; 0
    181e:	60 ee       	ldi	r22, 0xE0	; 224
    1820:	70 e4       	ldi	r23, 0x40	; 64
    1822:	2f e6       	ldi	r18, 0x6F	; 111
    1824:	0e 94 a0 07 	call	0xf40	; 0xf40 <distance>
    1828:	08 c0       	rjmp	.+16     	; 0x183a <node_behave+0xce>
		else
		distance('f',8.5,'o');
    182a:	86 e6       	ldi	r24, 0x66	; 102
    182c:	40 e0       	ldi	r20, 0x00	; 0
    182e:	50 e0       	ldi	r21, 0x00	; 0
    1830:	68 e0       	ldi	r22, 0x08	; 8
    1832:	71 e4       	ldi	r23, 0x41	; 65
    1834:	2f e6       	ldi	r18, 0x6F	; 111
    1836:	0e 94 a0 07 	call	0xf40	; 0xf40 <distance>
		if((*navigation_pointer-path[path_index])==-9 || (*navigation_pointer-path[path_index])==4 || (*navigation_pointer-path[path_index])==14) //-9,4,14 are ASCII values for 270 degree while rotating in rightwards
    183a:	e0 91 ac 02 	lds	r30, 0x02AC
    183e:	f0 91 ad 02 	lds	r31, 0x02AD
    1842:	50 81       	ld	r21, Z
    1844:	e0 91 59 02 	lds	r30, 0x0259
    1848:	f0 91 5a 02 	lds	r31, 0x025A
    184c:	e1 59       	subi	r30, 0x91	; 145
    184e:	fd 4f       	sbci	r31, 0xFD	; 253
    1850:	40 81       	ld	r20, Z
    1852:	85 2f       	mov	r24, r21
    1854:	90 e0       	ldi	r25, 0x00	; 0
    1856:	84 1b       	sub	r24, r20
    1858:	91 09       	sbc	r25, r1
    185a:	2f ef       	ldi	r18, 0xFF	; 255
    185c:	87 3f       	cpi	r24, 0xF7	; 247
    185e:	92 07       	cpc	r25, r18
    1860:	31 f0       	breq	.+12     	; 0x186e <node_behave+0x102>
    1862:	84 30       	cpi	r24, 0x04	; 4
    1864:	91 05       	cpc	r25, r1
    1866:	19 f0       	breq	.+6      	; 0x186e <node_behave+0x102>
    1868:	8e 30       	cpi	r24, 0x0E	; 14
    186a:	91 05       	cpc	r25, r1
    186c:	c1 f4       	brne	.+48     	; 0x189e <node_behave+0x132>
			while(*navigation_pointer!=path[path_index])
    186e:	54 17       	cp	r21, r20
    1870:	09 f4       	brne	.+2      	; 0x1874 <node_behave+0x108>
    1872:	70 c0       	rjmp	.+224    	; 0x1954 <node_behave+0x1e8>
    1874:	cf e6       	ldi	r28, 0x6F	; 111
    1876:	d2 e0       	ldi	r29, 0x02	; 2
				{left_degrees(90);}
    1878:	8a e5       	ldi	r24, 0x5A	; 90
    187a:	90 e0       	ldi	r25, 0x00	; 0
    187c:	0e 94 af 08 	call	0x115e	; 0x115e <left_degrees>
		else if(node_number==14)
		distance('f',7,'o');
		else
		distance('f',8.5,'o');
		if((*navigation_pointer-path[path_index])==-9 || (*navigation_pointer-path[path_index])==4 || (*navigation_pointer-path[path_index])==14) //-9,4,14 are ASCII values for 270 degree while rotating in rightwards
			while(*navigation_pointer!=path[path_index])
    1880:	e0 91 ac 02 	lds	r30, 0x02AC
    1884:	f0 91 ad 02 	lds	r31, 0x02AD
    1888:	a0 91 59 02 	lds	r26, 0x0259
    188c:	b0 91 5a 02 	lds	r27, 0x025A
    1890:	ac 0f       	add	r26, r28
    1892:	bd 1f       	adc	r27, r29
    1894:	90 81       	ld	r25, Z
    1896:	8c 91       	ld	r24, X
    1898:	98 17       	cp	r25, r24
    189a:	71 f7       	brne	.-36     	; 0x1878 <node_behave+0x10c>
    189c:	5b c0       	rjmp	.+182    	; 0x1954 <node_behave+0x1e8>
				{left_degrees(90);}
		else if(node_number==3)
    189e:	20 91 5f 02 	lds	r18, 0x025F
    18a2:	30 91 60 02 	lds	r19, 0x0260
    18a6:	23 30       	cpi	r18, 0x03	; 3
    18a8:	31 05       	cpc	r19, r1
    18aa:	c1 f4       	brne	.+48     	; 0x18dc <node_behave+0x170>
			while(*navigation_pointer!=path[path_index])
    18ac:	54 17       	cp	r21, r20
    18ae:	09 f4       	brne	.+2      	; 0x18b2 <node_behave+0x146>
    18b0:	51 c0       	rjmp	.+162    	; 0x1954 <node_behave+0x1e8>
    18b2:	cf e6       	ldi	r28, 0x6F	; 111
    18b4:	d2 e0       	ldi	r29, 0x02	; 2
				right_degrees(180);
    18b6:	84 eb       	ldi	r24, 0xB4	; 180
    18b8:	90 e0       	ldi	r25, 0x00	; 0
    18ba:	0e 94 16 09 	call	0x122c	; 0x122c <right_degrees>
		distance('f',8.5,'o');
		if((*navigation_pointer-path[path_index])==-9 || (*navigation_pointer-path[path_index])==4 || (*navigation_pointer-path[path_index])==14) //-9,4,14 are ASCII values for 270 degree while rotating in rightwards
			while(*navigation_pointer!=path[path_index])
				{left_degrees(90);}
		else if(node_number==3)
			while(*navigation_pointer!=path[path_index])
    18be:	e0 91 ac 02 	lds	r30, 0x02AC
    18c2:	f0 91 ad 02 	lds	r31, 0x02AD
    18c6:	a0 91 59 02 	lds	r26, 0x0259
    18ca:	b0 91 5a 02 	lds	r27, 0x025A
    18ce:	ac 0f       	add	r26, r28
    18d0:	bd 1f       	adc	r27, r29
    18d2:	90 81       	ld	r25, Z
    18d4:	8c 91       	ld	r24, X
    18d6:	98 17       	cp	r25, r24
    18d8:	71 f7       	brne	.-36     	; 0x18b6 <node_behave+0x14a>
    18da:	3c c0       	rjmp	.+120    	; 0x1954 <node_behave+0x1e8>
				right_degrees(180);
		else if(abs(*navigation_pointer-path[path_index])==5 || abs(*navigation_pointer-path[path_index])==18)
    18dc:	9c 01       	movw	r18, r24
    18de:	99 23       	and	r25, r25
    18e0:	24 f4       	brge	.+8      	; 0x18ea <node_behave+0x17e>
    18e2:	22 27       	eor	r18, r18
    18e4:	33 27       	eor	r19, r19
    18e6:	28 1b       	sub	r18, r24
    18e8:	39 0b       	sbc	r19, r25
    18ea:	25 30       	cpi	r18, 0x05	; 5
    18ec:	31 05       	cpc	r19, r1
    18ee:	19 f4       	brne	.+6      	; 0x18f6 <node_behave+0x18a>
			while(*navigation_pointer!=path[path_index])
    18f0:	54 17       	cp	r21, r20
    18f2:	39 f4       	brne	.+14     	; 0x1902 <node_behave+0x196>
    18f4:	2f c0       	rjmp	.+94     	; 0x1954 <node_behave+0x1e8>
			while(*navigation_pointer!=path[path_index])
				{left_degrees(90);}
		else if(node_number==3)
			while(*navigation_pointer!=path[path_index])
				right_degrees(180);
		else if(abs(*navigation_pointer-path[path_index])==5 || abs(*navigation_pointer-path[path_index])==18)
    18f6:	22 31       	cpi	r18, 0x12	; 18
    18f8:	31 05       	cpc	r19, r1
    18fa:	d1 f3       	breq	.-12     	; 0x18f0 <node_behave+0x184>
			while(*navigation_pointer!=path[path_index])
				left_degrees(180);
		else
			while(*navigation_pointer!=path[path_index])
    18fc:	54 17       	cp	r21, r20
    18fe:	b1 f4       	brne	.+44     	; 0x192c <node_behave+0x1c0>
    1900:	29 c0       	rjmp	.+82     	; 0x1954 <node_behave+0x1e8>
				{left_degrees(90);}
		else if(node_number==3)
			while(*navigation_pointer!=path[path_index])
				right_degrees(180);
		else if(abs(*navigation_pointer-path[path_index])==5 || abs(*navigation_pointer-path[path_index])==18)
			while(*navigation_pointer!=path[path_index])
    1902:	cf e6       	ldi	r28, 0x6F	; 111
    1904:	d2 e0       	ldi	r29, 0x02	; 2
				left_degrees(180);
    1906:	84 eb       	ldi	r24, 0xB4	; 180
    1908:	90 e0       	ldi	r25, 0x00	; 0
    190a:	0e 94 af 08 	call	0x115e	; 0x115e <left_degrees>
				{left_degrees(90);}
		else if(node_number==3)
			while(*navigation_pointer!=path[path_index])
				right_degrees(180);
		else if(abs(*navigation_pointer-path[path_index])==5 || abs(*navigation_pointer-path[path_index])==18)
			while(*navigation_pointer!=path[path_index])
    190e:	e0 91 ac 02 	lds	r30, 0x02AC
    1912:	f0 91 ad 02 	lds	r31, 0x02AD
    1916:	a0 91 59 02 	lds	r26, 0x0259
    191a:	b0 91 5a 02 	lds	r27, 0x025A
    191e:	ac 0f       	add	r26, r28
    1920:	bd 1f       	adc	r27, r29
    1922:	90 81       	ld	r25, Z
    1924:	8c 91       	ld	r24, X
    1926:	98 17       	cp	r25, r24
    1928:	71 f7       	brne	.-36     	; 0x1906 <node_behave+0x19a>
    192a:	14 c0       	rjmp	.+40     	; 0x1954 <node_behave+0x1e8>
				left_degrees(180);
		else
			while(*navigation_pointer!=path[path_index])
    192c:	cf e6       	ldi	r28, 0x6F	; 111
    192e:	d2 e0       	ldi	r29, 0x02	; 2
			right_degrees(90);
    1930:	8a e5       	ldi	r24, 0x5A	; 90
    1932:	90 e0       	ldi	r25, 0x00	; 0
    1934:	0e 94 16 09 	call	0x122c	; 0x122c <right_degrees>
				right_degrees(180);
		else if(abs(*navigation_pointer-path[path_index])==5 || abs(*navigation_pointer-path[path_index])==18)
			while(*navigation_pointer!=path[path_index])
				left_degrees(180);
		else
			while(*navigation_pointer!=path[path_index])
    1938:	e0 91 ac 02 	lds	r30, 0x02AC
    193c:	f0 91 ad 02 	lds	r31, 0x02AD
    1940:	a0 91 59 02 	lds	r26, 0x0259
    1944:	b0 91 5a 02 	lds	r27, 0x025A
    1948:	ac 0f       	add	r26, r28
    194a:	bd 1f       	adc	r27, r29
    194c:	90 81       	ld	r25, Z
    194e:	8c 91       	ld	r24, X
    1950:	98 17       	cp	r25, r24
    1952:	71 f7       	brne	.-36     	; 0x1930 <node_behave+0x1c4>
			right_degrees(90);
		path_index++;
    1954:	80 91 59 02 	lds	r24, 0x0259
    1958:	90 91 5a 02 	lds	r25, 0x025A
    195c:	01 96       	adiw	r24, 0x01	; 1
    195e:	90 93 5a 02 	sts	0x025A, r25
    1962:	80 93 59 02 	sts	0x0259, r24
    1966:	0c 94 d1 14 	jmp	0x29a2	; 0x29a2 <__stack+0x7a3>
	}
	else
	{
		node_number=destinationn_node;
    196a:	80 91 5d 02 	lds	r24, 0x025D
    196e:	90 91 5e 02 	lds	r25, 0x025E
    1972:	90 93 60 02 	sts	0x0260, r25
    1976:	80 93 5f 02 	sts	0x025F, r24
		navigate();
    197a:	0e 94 6b 04 	call	0x8d6	; 0x8d6 <navigate>
		if(node_number==15 || node_number==16 || node_number==17)
    197e:	80 91 5f 02 	lds	r24, 0x025F
    1982:	90 91 60 02 	lds	r25, 0x0260
    1986:	0f 97       	sbiw	r24, 0x0f	; 15
    1988:	83 30       	cpi	r24, 0x03	; 3
    198a:	91 05       	cpc	r25, r1
    198c:	08 f0       	brcs	.+2      	; 0x1990 <node_behave+0x224>
    198e:	42 c1       	rjmp	.+644    	; 0x1c14 <node_behave+0x4a8>
		{
			if((deposition_zone_A+deposition_zone_B+deposition_zone_C)!=1 && color_found==0)
    1990:	80 91 3b 02 	lds	r24, 0x023B
    1994:	90 91 3c 02 	lds	r25, 0x023C
    1998:	20 91 39 02 	lds	r18, 0x0239
    199c:	30 91 3a 02 	lds	r19, 0x023A
    19a0:	82 0f       	add	r24, r18
    19a2:	93 1f       	adc	r25, r19
    19a4:	20 91 37 02 	lds	r18, 0x0237
    19a8:	30 91 38 02 	lds	r19, 0x0238
    19ac:	82 0f       	add	r24, r18
    19ae:	93 1f       	adc	r25, r19
    19b0:	81 30       	cpi	r24, 0x01	; 1
    19b2:	91 05       	cpc	r25, r1
    19b4:	09 f4       	brne	.+2      	; 0x19b8 <node_behave+0x24c>
    19b6:	89 c0       	rjmp	.+274    	; 0x1aca <node_behave+0x35e>
    19b8:	80 91 5b 02 	lds	r24, 0x025B
    19bc:	90 91 5c 02 	lds	r25, 0x025C
    19c0:	00 97       	sbiw	r24, 0x00	; 0
    19c2:	09 f0       	breq	.+2      	; 0x19c6 <node_behave+0x25a>
    19c4:	82 c0       	rjmp	.+260    	; 0x1aca <node_behave+0x35e>
			{
				left(); //Turn left
    19c6:	0e 94 2a 08 	call	0x1054	; 0x1054 <left>
				angle_rotate(45);
    19ca:	8d e2       	ldi	r24, 0x2D	; 45
    19cc:	90 e0       	ldi	r25, 0x00	; 0
    19ce:	0e 94 3a 08 	call	0x1074	; 0x1074 <angle_rotate>
				distance('f',13,'o');
    19d2:	86 e6       	ldi	r24, 0x66	; 102
    19d4:	40 e0       	ldi	r20, 0x00	; 0
    19d6:	50 e0       	ldi	r21, 0x00	; 0
    19d8:	60 e5       	ldi	r22, 0x50	; 80
    19da:	71 e4       	ldi	r23, 0x41	; 65
    19dc:	2f e6       	ldi	r18, 0x6F	; 111
    19de:	0e 94 a0 07 	call	0xf40	; 0xf40 <distance>
				right(); //Turn left
    19e2:	0e 94 2e 08 	call	0x105c	; 0x105c <right>
				angle_rotate(170);
    19e6:	8a ea       	ldi	r24, 0xAA	; 170
    19e8:	90 e0       	ldi	r25, 0x00	; 0
    19ea:	0e 94 3a 08 	call	0x1074	; 0x1074 <angle_rotate>
				stop();
    19ee:	0e 94 26 08 	call	0x104c	; 0x104c <stop>
				color_sensor();
    19f2:	0e 94 59 16 	call	0x2cb2	; 0x2cb2 <color_sensor>
				if(node_number==15)
    19f6:	80 91 5f 02 	lds	r24, 0x025F
    19fa:	90 91 60 02 	lds	r25, 0x0260
    19fe:	8f 30       	cpi	r24, 0x0F	; 15
    1a00:	91 05       	cpc	r25, r1
    1a02:	29 f4       	brne	.+10     	; 0x1a0e <node_behave+0x2a2>
				color_deposited[0]=color_identified;
    1a04:	80 91 54 02 	lds	r24, 0x0254
    1a08:	80 93 a4 02 	sts	0x02A4, r24
    1a0c:	0f c0       	rjmp	.+30     	; 0x1a2c <node_behave+0x2c0>
				if(node_number==16)
    1a0e:	80 31       	cpi	r24, 0x10	; 16
    1a10:	91 05       	cpc	r25, r1
    1a12:	29 f4       	brne	.+10     	; 0x1a1e <node_behave+0x2b2>
				color_deposited[1]=color_identified;
    1a14:	80 91 54 02 	lds	r24, 0x0254
    1a18:	80 93 a5 02 	sts	0x02A5, r24
    1a1c:	07 c0       	rjmp	.+14     	; 0x1a2c <node_behave+0x2c0>
				if(node_number==17)
    1a1e:	81 31       	cpi	r24, 0x11	; 17
    1a20:	91 05       	cpc	r25, r1
    1a22:	21 f4       	brne	.+8      	; 0x1a2c <node_behave+0x2c0>
				color_deposited[2]=color_identified;
    1a24:	80 91 54 02 	lds	r24, 0x0254
    1a28:	80 93 a6 02 	sts	0x02A6, r24
				left(); //Turn left
    1a2c:	0e 94 2a 08 	call	0x1054	; 0x1054 <left>
				angle_rotate(170);
    1a30:	8a ea       	ldi	r24, 0xAA	; 170
    1a32:	90 e0       	ldi	r25, 0x00	; 0
    1a34:	0e 94 3a 08 	call	0x1074	; 0x1074 <angle_rotate>
				distance('b',11,'o');
    1a38:	82 e6       	ldi	r24, 0x62	; 98
    1a3a:	40 e0       	ldi	r20, 0x00	; 0
    1a3c:	50 e0       	ldi	r21, 0x00	; 0
    1a3e:	60 e3       	ldi	r22, 0x30	; 48
    1a40:	71 e4       	ldi	r23, 0x41	; 65
    1a42:	2f e6       	ldi	r18, 0x6F	; 111
    1a44:	0e 94 a0 07 	call	0xf40	; 0xf40 <distance>
				while(digital[2]<15 && digital[1]<15 && digital[3]<15)
    1a48:	80 91 3e 05 	lds	r24, 0x053E
    1a4c:	90 91 3f 05 	lds	r25, 0x053F
    1a50:	8f 30       	cpi	r24, 0x0F	; 15
    1a52:	91 05       	cpc	r25, r1
    1a54:	90 f5       	brcc	.+100    	; 0x1aba <node_behave+0x34e>
    1a56:	80 91 3c 05 	lds	r24, 0x053C
    1a5a:	90 91 3d 05 	lds	r25, 0x053D
    1a5e:	8f 30       	cpi	r24, 0x0F	; 15
    1a60:	91 05       	cpc	r25, r1
    1a62:	58 f5       	brcc	.+86     	; 0x1aba <node_behave+0x34e>
    1a64:	80 91 40 05 	lds	r24, 0x0540
    1a68:	90 91 41 05 	lds	r25, 0x0541
    1a6c:	8f 30       	cpi	r24, 0x0F	; 15
    1a6e:	91 05       	cpc	r25, r1
    1a70:	20 f5       	brcc	.+72     	; 0x1aba <node_behave+0x34e>
    1a72:	ce e3       	ldi	r28, 0x3E	; 62
    1a74:	d5 e0       	ldi	r29, 0x05	; 5
    1a76:	0c e3       	ldi	r16, 0x3C	; 60
    1a78:	15 e0       	ldi	r17, 0x05	; 5
    1a7a:	0f 2e       	mov	r0, r31
    1a7c:	f0 e4       	ldi	r31, 0x40	; 64
    1a7e:	ef 2e       	mov	r14, r31
    1a80:	f5 e0       	ldi	r31, 0x05	; 5
    1a82:	ff 2e       	mov	r15, r31
    1a84:	f0 2d       	mov	r31, r0
				{
					sppeed(255,249);
    1a86:	8f ef       	ldi	r24, 0xFF	; 255
    1a88:	90 e0       	ldi	r25, 0x00	; 0
    1a8a:	69 ef       	ldi	r22, 0xF9	; 249
    1a8c:	70 e0       	ldi	r23, 0x00	; 0
    1a8e:	0e 94 f7 00 	call	0x1ee	; 0x1ee <sppeed>
					right();
    1a92:	0e 94 2e 08 	call	0x105c	; 0x105c <right>
				if(node_number==17)
				color_deposited[2]=color_identified;
				left(); //Turn left
				angle_rotate(170);
				distance('b',11,'o');
				while(digital[2]<15 && digital[1]<15 && digital[3]<15)
    1a96:	88 81       	ld	r24, Y
    1a98:	99 81       	ldd	r25, Y+1	; 0x01
    1a9a:	8f 30       	cpi	r24, 0x0F	; 15
    1a9c:	91 05       	cpc	r25, r1
    1a9e:	68 f4       	brcc	.+26     	; 0x1aba <node_behave+0x34e>
    1aa0:	d8 01       	movw	r26, r16
    1aa2:	8d 91       	ld	r24, X+
    1aa4:	9c 91       	ld	r25, X
    1aa6:	11 97       	sbiw	r26, 0x01	; 1
    1aa8:	8f 30       	cpi	r24, 0x0F	; 15
    1aaa:	91 05       	cpc	r25, r1
    1aac:	30 f4       	brcc	.+12     	; 0x1aba <node_behave+0x34e>
    1aae:	f7 01       	movw	r30, r14
    1ab0:	80 81       	ld	r24, Z
    1ab2:	91 81       	ldd	r25, Z+1	; 0x01
    1ab4:	8f 30       	cpi	r24, 0x0F	; 15
    1ab6:	91 05       	cpc	r25, r1
    1ab8:	30 f3       	brcs	.-52     	; 0x1a86 <node_behave+0x31a>
				{
					sppeed(255,249);
					right();
				}
				right();
    1aba:	0e 94 2e 08 	call	0x105c	; 0x105c <right>
				angle_rotate(25);
    1abe:	89 e1       	ldi	r24, 0x19	; 25
    1ac0:	90 e0       	ldi	r25, 0x00	; 0
    1ac2:	0e 94 3a 08 	call	0x1074	; 0x1074 <angle_rotate>
				stop();
    1ac6:	0e 94 26 08 	call	0x104c	; 0x104c <stop>
			}
			if(color_identified==color[color_index-1] || (deposition_zone_A+deposition_zone_B+deposition_zone_C)==1)
    1aca:	e0 91 52 02 	lds	r30, 0x0252
    1ace:	f0 91 53 02 	lds	r31, 0x0253
    1ad2:	ec 5c       	subi	r30, 0xCC	; 204
    1ad4:	fa 4f       	sbci	r31, 0xFA	; 250
    1ad6:	90 81       	ld	r25, Z
    1ad8:	80 91 54 02 	lds	r24, 0x0254
    1adc:	98 17       	cp	r25, r24
    1ade:	a1 f0       	breq	.+40     	; 0x1b08 <node_behave+0x39c>
    1ae0:	80 91 3b 02 	lds	r24, 0x023B
    1ae4:	90 91 3c 02 	lds	r25, 0x023C
    1ae8:	20 91 39 02 	lds	r18, 0x0239
    1aec:	30 91 3a 02 	lds	r19, 0x023A
    1af0:	82 0f       	add	r24, r18
    1af2:	93 1f       	adc	r25, r19
    1af4:	20 91 37 02 	lds	r18, 0x0237
    1af8:	30 91 38 02 	lds	r19, 0x0238
    1afc:	82 0f       	add	r24, r18
    1afe:	93 1f       	adc	r25, r19
    1b00:	81 30       	cpi	r24, 0x01	; 1
    1b02:	91 05       	cpc	r25, r1
    1b04:	09 f0       	breq	.+2      	; 0x1b08 <node_behave+0x39c>
    1b06:	60 c0       	rjmp	.+192    	; 0x1bc8 <node_behave+0x45c>
			{
				servo1_mov(10);
    1b08:	8a e0       	ldi	r24, 0x0A	; 10
    1b0a:	90 e0       	ldi	r25, 0x00	; 0
    1b0c:	0e 94 df 09 	call	0x13be	; 0x13be <servo1_mov>
    1b10:	8f ef       	ldi	r24, 0xFF	; 255
    1b12:	9f ef       	ldi	r25, 0xFF	; 255
    1b14:	ac e2       	ldi	r26, 0x2C	; 44
    1b16:	81 50       	subi	r24, 0x01	; 1
    1b18:	90 40       	sbci	r25, 0x00	; 0
    1b1a:	a0 40       	sbci	r26, 0x00	; 0
    1b1c:	e1 f7       	brne	.-8      	; 0x1b16 <node_behave+0x3aa>
    1b1e:	00 c0       	rjmp	.+0      	; 0x1b20 <node_behave+0x3b4>
    1b20:	00 00       	nop
				_delay_ms(1000);
				servo2_mov(45);
    1b22:	8d e2       	ldi	r24, 0x2D	; 45
    1b24:	90 e0       	ldi	r25, 0x00	; 0
    1b26:	0e 94 29 0a 	call	0x1452	; 0x1452 <servo2_mov>
    1b2a:	8f ef       	ldi	r24, 0xFF	; 255
    1b2c:	9f e7       	ldi	r25, 0x7F	; 127
    1b2e:	a4 e0       	ldi	r26, 0x04	; 4
    1b30:	81 50       	subi	r24, 0x01	; 1
    1b32:	90 40       	sbci	r25, 0x00	; 0
    1b34:	a0 40       	sbci	r26, 0x00	; 0
    1b36:	e1 f7       	brne	.-8      	; 0x1b30 <node_behave+0x3c4>
    1b38:	00 c0       	rjmp	.+0      	; 0x1b3a <node_behave+0x3ce>
    1b3a:	00 00       	nop
				_delay_ms(100);
				servo1_mov(80);
    1b3c:	80 e5       	ldi	r24, 0x50	; 80
    1b3e:	90 e0       	ldi	r25, 0x00	; 0
    1b40:	0e 94 df 09 	call	0x13be	; 0x13be <servo1_mov>
    1b44:	8f ef       	ldi	r24, 0xFF	; 255
    1b46:	9f ef       	ldi	r25, 0xFF	; 255
    1b48:	ac e2       	ldi	r26, 0x2C	; 44
    1b4a:	81 50       	subi	r24, 0x01	; 1
    1b4c:	90 40       	sbci	r25, 0x00	; 0
    1b4e:	a0 40       	sbci	r26, 0x00	; 0
    1b50:	e1 f7       	brne	.-8      	; 0x1b4a <node_behave+0x3de>
    1b52:	00 c0       	rjmp	.+0      	; 0x1b54 <node_behave+0x3e8>
    1b54:	00 00       	nop
				_delay_ms(1000);
				servo2_free();
    1b56:	0e 94 57 0a 	call	0x14ae	; 0x14ae <servo2_free>
				if(node_number==15)
    1b5a:	80 91 5f 02 	lds	r24, 0x025F
    1b5e:	90 91 60 02 	lds	r25, 0x0260
    1b62:	8f 30       	cpi	r24, 0x0F	; 15
    1b64:	91 05       	cpc	r25, r1
    1b66:	51 f4       	brne	.+20     	; 0x1b7c <node_behave+0x410>
				deposition_zone_A--;
    1b68:	80 91 3b 02 	lds	r24, 0x023B
    1b6c:	90 91 3c 02 	lds	r25, 0x023C
    1b70:	01 97       	sbiw	r24, 0x01	; 1
    1b72:	90 93 3c 02 	sts	0x023C, r25
    1b76:	80 93 3b 02 	sts	0x023B, r24
    1b7a:	19 c0       	rjmp	.+50     	; 0x1bae <node_behave+0x442>
				if(node_number==16)
    1b7c:	80 31       	cpi	r24, 0x10	; 16
    1b7e:	91 05       	cpc	r25, r1
    1b80:	51 f4       	brne	.+20     	; 0x1b96 <node_behave+0x42a>
				deposition_zone_B--;
    1b82:	80 91 39 02 	lds	r24, 0x0239
    1b86:	90 91 3a 02 	lds	r25, 0x023A
    1b8a:	01 97       	sbiw	r24, 0x01	; 1
    1b8c:	90 93 3a 02 	sts	0x023A, r25
    1b90:	80 93 39 02 	sts	0x0239, r24
    1b94:	0c c0       	rjmp	.+24     	; 0x1bae <node_behave+0x442>
				if(node_number==17)
    1b96:	81 31       	cpi	r24, 0x11	; 17
    1b98:	91 05       	cpc	r25, r1
    1b9a:	49 f4       	brne	.+18     	; 0x1bae <node_behave+0x442>
				deposition_zone_C--;
    1b9c:	80 91 37 02 	lds	r24, 0x0237
    1ba0:	90 91 38 02 	lds	r25, 0x0238
    1ba4:	01 97       	sbiw	r24, 0x01	; 1
    1ba6:	90 93 38 02 	sts	0x0238, r25
    1baa:	80 93 37 02 	sts	0x0237, r24
				path_find(10);
    1bae:	8a e0       	ldi	r24, 0x0A	; 10
    1bb0:	90 e0       	ldi	r25, 0x00	; 0
    1bb2:	0e 94 f9 05 	call	0xbf2	; 0xbf2 <path_find>
				distance('b',6,'o');
    1bb6:	82 e6       	ldi	r24, 0x62	; 98
    1bb8:	40 e0       	ldi	r20, 0x00	; 0
    1bba:	50 e0       	ldi	r21, 0x00	; 0
    1bbc:	60 ec       	ldi	r22, 0xC0	; 192
    1bbe:	70 e4       	ldi	r23, 0x40	; 64
    1bc0:	2f e6       	ldi	r18, 0x6F	; 111
    1bc2:	0e 94 a0 07 	call	0xf40	; 0xf40 <distance>
    1bc6:	26 c0       	rjmp	.+76     	; 0x1c14 <node_behave+0x4a8>
			}
			else
			{
				distance('b',6,'o');
    1bc8:	82 e6       	ldi	r24, 0x62	; 98
    1bca:	40 e0       	ldi	r20, 0x00	; 0
    1bcc:	50 e0       	ldi	r21, 0x00	; 0
    1bce:	60 ec       	ldi	r22, 0xC0	; 192
    1bd0:	70 e4       	ldi	r23, 0x40	; 64
    1bd2:	2f e6       	ldi	r18, 0x6F	; 111
    1bd4:	0e 94 a0 07 	call	0xf40	; 0xf40 <distance>
				if(deposition_zone_A==1 && node_number!=15)
    1bd8:	80 91 3b 02 	lds	r24, 0x023B
    1bdc:	90 91 3c 02 	lds	r25, 0x023C
    1be0:	81 30       	cpi	r24, 0x01	; 1
    1be2:	91 05       	cpc	r25, r1
    1be4:	61 f4       	brne	.+24     	; 0x1bfe <node_behave+0x492>
    1be6:	80 91 5f 02 	lds	r24, 0x025F
    1bea:	90 91 60 02 	lds	r25, 0x0260
    1bee:	8f 30       	cpi	r24, 0x0F	; 15
    1bf0:	91 05       	cpc	r25, r1
    1bf2:	29 f0       	breq	.+10     	; 0x1bfe <node_behave+0x492>
				enq_end(15);
    1bf4:	8f e0       	ldi	r24, 0x0F	; 15
    1bf6:	90 e0       	ldi	r25, 0x00	; 0
    1bf8:	0e 94 ee 06 	call	0xddc	; 0xddc <enq_end>
    1bfc:	0b c0       	rjmp	.+22     	; 0x1c14 <node_behave+0x4a8>
				else if(deposition_zone_C==1)
    1bfe:	80 91 37 02 	lds	r24, 0x0237
    1c02:	90 91 38 02 	lds	r25, 0x0238
    1c06:	81 30       	cpi	r24, 0x01	; 1
    1c08:	91 05       	cpc	r25, r1
    1c0a:	21 f4       	brne	.+8      	; 0x1c14 <node_behave+0x4a8>
				enq_end(17);
    1c0c:	81 e1       	ldi	r24, 0x11	; 17
    1c0e:	90 e0       	ldi	r25, 0x00	; 0
    1c10:	0e 94 ee 06 	call	0xddc	; 0xddc <enq_end>
			}
		}
		if(node_number==1)
    1c14:	80 91 5f 02 	lds	r24, 0x025F
    1c18:	90 91 60 02 	lds	r25, 0x0260
    1c1c:	81 30       	cpi	r24, 0x01	; 1
    1c1e:	91 05       	cpc	r25, r1
    1c20:	09 f0       	breq	.+2      	; 0x1c24 <node_behave+0x4b8>
    1c22:	9c c0       	rjmp	.+312    	; 0x1d5c <node_behave+0x5f0>
		{
			distance('f',10,'o');
    1c24:	86 e6       	ldi	r24, 0x66	; 102
    1c26:	40 e0       	ldi	r20, 0x00	; 0
    1c28:	50 e0       	ldi	r21, 0x00	; 0
    1c2a:	60 e2       	ldi	r22, 0x20	; 32
    1c2c:	71 e4       	ldi	r23, 0x41	; 65
    1c2e:	2f e6       	ldi	r18, 0x6F	; 111
    1c30:	0e 94 a0 07 	call	0xf40	; 0xf40 <distance>
			left();
    1c34:	0e 94 2a 08 	call	0x1054	; 0x1054 <left>
			navigation_in_degrees=navigation_in_degrees+90;
    1c38:	80 91 3d 02 	lds	r24, 0x023D
    1c3c:	90 91 3e 02 	lds	r25, 0x023E
    1c40:	86 5a       	subi	r24, 0xA6	; 166
    1c42:	9f 4f       	sbci	r25, 0xFF	; 255
    1c44:	90 93 3e 02 	sts	0x023E, r25
    1c48:	80 93 3d 02 	sts	0x023D, r24
			angle_rotate(105);
    1c4c:	89 e6       	ldi	r24, 0x69	; 105
    1c4e:	90 e0       	ldi	r25, 0x00	; 0
    1c50:	0e 94 3a 08 	call	0x1074	; 0x1074 <angle_rotate>
			stop();
    1c54:	0e 94 26 08 	call	0x104c	; 0x104c <stop>
			if(weight_block_position_1==2)
    1c58:	80 91 33 02 	lds	r24, 0x0233
    1c5c:	90 91 34 02 	lds	r25, 0x0234
    1c60:	82 30       	cpi	r24, 0x02	; 2
    1c62:	91 05       	cpc	r25, r1
    1c64:	91 f5       	brne	.+100    	; 0x1cca <node_behave+0x55e>
			{
				distance('f',3,'o');
    1c66:	86 e6       	ldi	r24, 0x66	; 102
    1c68:	40 e0       	ldi	r20, 0x00	; 0
    1c6a:	50 e0       	ldi	r21, 0x00	; 0
    1c6c:	60 e4       	ldi	r22, 0x40	; 64
    1c6e:	70 e4       	ldi	r23, 0x40	; 64
    1c70:	2f e6       	ldi	r18, 0x6F	; 111
    1c72:	0e 94 a0 07 	call	0xf40	; 0xf40 <distance>
				servo1_mov(16);
    1c76:	80 e1       	ldi	r24, 0x10	; 16
    1c78:	90 e0       	ldi	r25, 0x00	; 0
    1c7a:	0e 94 df 09 	call	0x13be	; 0x13be <servo1_mov>
    1c7e:	8f ef       	ldi	r24, 0xFF	; 255
    1c80:	9f ef       	ldi	r25, 0xFF	; 255
    1c82:	ac e2       	ldi	r26, 0x2C	; 44
    1c84:	81 50       	subi	r24, 0x01	; 1
    1c86:	90 40       	sbci	r25, 0x00	; 0
    1c88:	a0 40       	sbci	r26, 0x00	; 0
    1c8a:	e1 f7       	brne	.-8      	; 0x1c84 <node_behave+0x518>
    1c8c:	00 c0       	rjmp	.+0      	; 0x1c8e <node_behave+0x522>
    1c8e:	00 00       	nop
				_delay_ms(1000);
				servo2_mov(1);
    1c90:	81 e0       	ldi	r24, 0x01	; 1
    1c92:	90 e0       	ldi	r25, 0x00	; 0
    1c94:	0e 94 29 0a 	call	0x1452	; 0x1452 <servo2_mov>
    1c98:	8f ef       	ldi	r24, 0xFF	; 255
    1c9a:	9f ef       	ldi	r25, 0xFF	; 255
    1c9c:	ac e2       	ldi	r26, 0x2C	; 44
    1c9e:	81 50       	subi	r24, 0x01	; 1
    1ca0:	90 40       	sbci	r25, 0x00	; 0
    1ca2:	a0 40       	sbci	r26, 0x00	; 0
    1ca4:	e1 f7       	brne	.-8      	; 0x1c9e <node_behave+0x532>
    1ca6:	00 c0       	rjmp	.+0      	; 0x1ca8 <node_behave+0x53c>
    1ca8:	00 00       	nop
				_delay_ms(1000);
				servo1_mov(130);
    1caa:	82 e8       	ldi	r24, 0x82	; 130
    1cac:	90 e0       	ldi	r25, 0x00	; 0
    1cae:	0e 94 df 09 	call	0x13be	; 0x13be <servo1_mov>
    1cb2:	8f ef       	ldi	r24, 0xFF	; 255
    1cb4:	9f e7       	ldi	r25, 0x7F	; 127
    1cb6:	a1 e3       	ldi	r26, 0x31	; 49
    1cb8:	81 50       	subi	r24, 0x01	; 1
    1cba:	90 40       	sbci	r25, 0x00	; 0
    1cbc:	a0 40       	sbci	r26, 0x00	; 0
    1cbe:	e1 f7       	brne	.-8      	; 0x1cb8 <node_behave+0x54c>
    1cc0:	00 c0       	rjmp	.+0      	; 0x1cc2 <node_behave+0x556>
    1cc2:	00 00       	nop
				_delay_ms(1100);
				servo1_free();
    1cc4:	0e 94 50 0a 	call	0x14a0	; 0x14a0 <servo1_free>
    1cc8:	34 c0       	rjmp	.+104    	; 0x1d32 <node_behave+0x5c6>
			}
			else if(weight_block_position_1==1)
    1cca:	81 30       	cpi	r24, 0x01	; 1
    1ccc:	91 05       	cpc	r25, r1
    1cce:	89 f5       	brne	.+98     	; 0x1d32 <node_behave+0x5c6>
			{
				distance('f',4,'o');
    1cd0:	86 e6       	ldi	r24, 0x66	; 102
    1cd2:	40 e0       	ldi	r20, 0x00	; 0
    1cd4:	50 e0       	ldi	r21, 0x00	; 0
    1cd6:	60 e8       	ldi	r22, 0x80	; 128
    1cd8:	70 e4       	ldi	r23, 0x40	; 64
    1cda:	2f e6       	ldi	r18, 0x6F	; 111
    1cdc:	0e 94 a0 07 	call	0xf40	; 0xf40 <distance>
				servo1_mov(11);
    1ce0:	8b e0       	ldi	r24, 0x0B	; 11
    1ce2:	90 e0       	ldi	r25, 0x00	; 0
    1ce4:	0e 94 df 09 	call	0x13be	; 0x13be <servo1_mov>
    1ce8:	8f ef       	ldi	r24, 0xFF	; 255
    1cea:	9f ef       	ldi	r25, 0xFF	; 255
    1cec:	ac e2       	ldi	r26, 0x2C	; 44
    1cee:	81 50       	subi	r24, 0x01	; 1
    1cf0:	90 40       	sbci	r25, 0x00	; 0
    1cf2:	a0 40       	sbci	r26, 0x00	; 0
    1cf4:	e1 f7       	brne	.-8      	; 0x1cee <node_behave+0x582>
    1cf6:	00 c0       	rjmp	.+0      	; 0x1cf8 <node_behave+0x58c>
    1cf8:	00 00       	nop
				_delay_ms(1000);
				servo2_mov(1);
    1cfa:	81 e0       	ldi	r24, 0x01	; 1
    1cfc:	90 e0       	ldi	r25, 0x00	; 0
    1cfe:	0e 94 29 0a 	call	0x1452	; 0x1452 <servo2_mov>
    1d02:	8f ef       	ldi	r24, 0xFF	; 255
    1d04:	9f ef       	ldi	r25, 0xFF	; 255
    1d06:	ac e2       	ldi	r26, 0x2C	; 44
    1d08:	81 50       	subi	r24, 0x01	; 1
    1d0a:	90 40       	sbci	r25, 0x00	; 0
    1d0c:	a0 40       	sbci	r26, 0x00	; 0
    1d0e:	e1 f7       	brne	.-8      	; 0x1d08 <node_behave+0x59c>
    1d10:	00 c0       	rjmp	.+0      	; 0x1d12 <node_behave+0x5a6>
    1d12:	00 00       	nop
				_delay_ms(1000);
				servo1_mov(130);
    1d14:	82 e8       	ldi	r24, 0x82	; 130
    1d16:	90 e0       	ldi	r25, 0x00	; 0
    1d18:	0e 94 df 09 	call	0x13be	; 0x13be <servo1_mov>
    1d1c:	8f ef       	ldi	r24, 0xFF	; 255
    1d1e:	9f e7       	ldi	r25, 0x7F	; 127
    1d20:	a1 e3       	ldi	r26, 0x31	; 49
    1d22:	81 50       	subi	r24, 0x01	; 1
    1d24:	90 40       	sbci	r25, 0x00	; 0
    1d26:	a0 40       	sbci	r26, 0x00	; 0
    1d28:	e1 f7       	brne	.-8      	; 0x1d22 <node_behave+0x5b6>
    1d2a:	00 c0       	rjmp	.+0      	; 0x1d2c <node_behave+0x5c0>
    1d2c:	00 00       	nop
				_delay_ms(1100);
				servo1_free();
    1d2e:	0e 94 50 0a 	call	0x14a0	; 0x14a0 <servo1_free>
			}
			weight_block_position_1--;
    1d32:	80 91 33 02 	lds	r24, 0x0233
    1d36:	90 91 34 02 	lds	r25, 0x0234
    1d3a:	01 97       	sbiw	r24, 0x01	; 1
    1d3c:	90 93 34 02 	sts	0x0234, r25
    1d40:	80 93 33 02 	sts	0x0233, r24
			distance('b',14,'o');
    1d44:	82 e6       	ldi	r24, 0x62	; 98
    1d46:	40 e0       	ldi	r20, 0x00	; 0
    1d48:	50 e0       	ldi	r21, 0x00	; 0
    1d4a:	60 e6       	ldi	r22, 0x60	; 96
    1d4c:	71 e4       	ldi	r23, 0x41	; 65
    1d4e:	2f e6       	ldi	r18, 0x6F	; 111
    1d50:	0e 94 a0 07 	call	0xf40	; 0xf40 <distance>
			enq_end(4);
    1d54:	84 e0       	ldi	r24, 0x04	; 4
    1d56:	90 e0       	ldi	r25, 0x00	; 0
    1d58:	0e 94 ee 06 	call	0xddc	; 0xddc <enq_end>
		}

		if(node_number==13)
    1d5c:	80 91 5f 02 	lds	r24, 0x025F
    1d60:	90 91 60 02 	lds	r25, 0x0260
    1d64:	8d 30       	cpi	r24, 0x0D	; 13
    1d66:	91 05       	cpc	r25, r1
    1d68:	09 f0       	breq	.+2      	; 0x1d6c <node_behave+0x600>
    1d6a:	1e c1       	rjmp	.+572    	; 0x1fa8 <node_behave+0x83c>
		{
			if(weight_block_position_5!=0)
    1d6c:	80 91 2b 02 	lds	r24, 0x022B
    1d70:	90 91 2c 02 	lds	r25, 0x022C
    1d74:	00 97       	sbiw	r24, 0x00	; 0
    1d76:	09 f4       	brne	.+2      	; 0x1d7a <node_behave+0x60e>
    1d78:	7b c0       	rjmp	.+246    	; 0x1e70 <node_behave+0x704>
			{
				distance('f',12,'o');
    1d7a:	86 e6       	ldi	r24, 0x66	; 102
    1d7c:	40 e0       	ldi	r20, 0x00	; 0
    1d7e:	50 e0       	ldi	r21, 0x00	; 0
    1d80:	60 e4       	ldi	r22, 0x40	; 64
    1d82:	71 e4       	ldi	r23, 0x41	; 65
    1d84:	2f e6       	ldi	r18, 0x6F	; 111
    1d86:	0e 94 a0 07 	call	0xf40	; 0xf40 <distance>
				if(weight_block_position_5==2)
    1d8a:	80 91 2b 02 	lds	r24, 0x022B
    1d8e:	90 91 2c 02 	lds	r25, 0x022C
    1d92:	82 30       	cpi	r24, 0x02	; 2
    1d94:	91 05       	cpc	r25, r1
    1d96:	51 f5       	brne	.+84     	; 0x1dec <node_behave+0x680>
				{
					servo1_mov(16);
    1d98:	80 e1       	ldi	r24, 0x10	; 16
    1d9a:	90 e0       	ldi	r25, 0x00	; 0
    1d9c:	0e 94 df 09 	call	0x13be	; 0x13be <servo1_mov>
    1da0:	8f ef       	ldi	r24, 0xFF	; 255
    1da2:	9f ef       	ldi	r25, 0xFF	; 255
    1da4:	ac e2       	ldi	r26, 0x2C	; 44
    1da6:	81 50       	subi	r24, 0x01	; 1
    1da8:	90 40       	sbci	r25, 0x00	; 0
    1daa:	a0 40       	sbci	r26, 0x00	; 0
    1dac:	e1 f7       	brne	.-8      	; 0x1da6 <node_behave+0x63a>
    1dae:	00 c0       	rjmp	.+0      	; 0x1db0 <node_behave+0x644>
    1db0:	00 00       	nop
					_delay_ms(1000);
					servo2_mov(1);
    1db2:	81 e0       	ldi	r24, 0x01	; 1
    1db4:	90 e0       	ldi	r25, 0x00	; 0
    1db6:	0e 94 29 0a 	call	0x1452	; 0x1452 <servo2_mov>
    1dba:	8f ef       	ldi	r24, 0xFF	; 255
    1dbc:	9f ef       	ldi	r25, 0xFF	; 255
    1dbe:	ac e2       	ldi	r26, 0x2C	; 44
    1dc0:	81 50       	subi	r24, 0x01	; 1
    1dc2:	90 40       	sbci	r25, 0x00	; 0
    1dc4:	a0 40       	sbci	r26, 0x00	; 0
    1dc6:	e1 f7       	brne	.-8      	; 0x1dc0 <node_behave+0x654>
    1dc8:	00 c0       	rjmp	.+0      	; 0x1dca <node_behave+0x65e>
    1dca:	00 00       	nop
					_delay_ms(1000);
					servo1_mov(130);
    1dcc:	82 e8       	ldi	r24, 0x82	; 130
    1dce:	90 e0       	ldi	r25, 0x00	; 0
    1dd0:	0e 94 df 09 	call	0x13be	; 0x13be <servo1_mov>
    1dd4:	8f ef       	ldi	r24, 0xFF	; 255
    1dd6:	9f e7       	ldi	r25, 0x7F	; 127
    1dd8:	a1 e3       	ldi	r26, 0x31	; 49
    1dda:	81 50       	subi	r24, 0x01	; 1
    1ddc:	90 40       	sbci	r25, 0x00	; 0
    1dde:	a0 40       	sbci	r26, 0x00	; 0
    1de0:	e1 f7       	brne	.-8      	; 0x1dda <node_behave+0x66e>
    1de2:	00 c0       	rjmp	.+0      	; 0x1de4 <node_behave+0x678>
    1de4:	00 00       	nop
					_delay_ms(1100);
					servo1_free();
    1de6:	0e 94 50 0a 	call	0x14a0	; 0x14a0 <servo1_free>
    1dea:	2c c0       	rjmp	.+88     	; 0x1e44 <node_behave+0x6d8>
				}
				else if(weight_block_position_5==1)
    1dec:	81 30       	cpi	r24, 0x01	; 1
    1dee:	91 05       	cpc	r25, r1
    1df0:	49 f5       	brne	.+82     	; 0x1e44 <node_behave+0x6d8>
				{
					servo1_mov(11);
    1df2:	8b e0       	ldi	r24, 0x0B	; 11
    1df4:	90 e0       	ldi	r25, 0x00	; 0
    1df6:	0e 94 df 09 	call	0x13be	; 0x13be <servo1_mov>
    1dfa:	8f ef       	ldi	r24, 0xFF	; 255
    1dfc:	9f ef       	ldi	r25, 0xFF	; 255
    1dfe:	ac e2       	ldi	r26, 0x2C	; 44
    1e00:	81 50       	subi	r24, 0x01	; 1
    1e02:	90 40       	sbci	r25, 0x00	; 0
    1e04:	a0 40       	sbci	r26, 0x00	; 0
    1e06:	e1 f7       	brne	.-8      	; 0x1e00 <node_behave+0x694>
    1e08:	00 c0       	rjmp	.+0      	; 0x1e0a <node_behave+0x69e>
    1e0a:	00 00       	nop
					_delay_ms(1000);
					servo2_mov(1);
    1e0c:	81 e0       	ldi	r24, 0x01	; 1
    1e0e:	90 e0       	ldi	r25, 0x00	; 0
    1e10:	0e 94 29 0a 	call	0x1452	; 0x1452 <servo2_mov>
    1e14:	8f ef       	ldi	r24, 0xFF	; 255
    1e16:	9f ef       	ldi	r25, 0xFF	; 255
    1e18:	ac e2       	ldi	r26, 0x2C	; 44
    1e1a:	81 50       	subi	r24, 0x01	; 1
    1e1c:	90 40       	sbci	r25, 0x00	; 0
    1e1e:	a0 40       	sbci	r26, 0x00	; 0
    1e20:	e1 f7       	brne	.-8      	; 0x1e1a <node_behave+0x6ae>
    1e22:	00 c0       	rjmp	.+0      	; 0x1e24 <node_behave+0x6b8>
    1e24:	00 00       	nop
					_delay_ms(1000);
					servo1_mov(130);
    1e26:	82 e8       	ldi	r24, 0x82	; 130
    1e28:	90 e0       	ldi	r25, 0x00	; 0
    1e2a:	0e 94 df 09 	call	0x13be	; 0x13be <servo1_mov>
    1e2e:	8f ef       	ldi	r24, 0xFF	; 255
    1e30:	9f e7       	ldi	r25, 0x7F	; 127
    1e32:	a1 e3       	ldi	r26, 0x31	; 49
    1e34:	81 50       	subi	r24, 0x01	; 1
    1e36:	90 40       	sbci	r25, 0x00	; 0
    1e38:	a0 40       	sbci	r26, 0x00	; 0
    1e3a:	e1 f7       	brne	.-8      	; 0x1e34 <node_behave+0x6c8>
    1e3c:	00 c0       	rjmp	.+0      	; 0x1e3e <node_behave+0x6d2>
    1e3e:	00 00       	nop
					_delay_ms(1100);
					servo1_free();
    1e40:	0e 94 50 0a 	call	0x14a0	; 0x14a0 <servo1_free>
				}
				weight_block_position_5--;
    1e44:	80 91 2b 02 	lds	r24, 0x022B
    1e48:	90 91 2c 02 	lds	r25, 0x022C
    1e4c:	01 97       	sbiw	r24, 0x01	; 1
    1e4e:	90 93 2c 02 	sts	0x022C, r25
    1e52:	80 93 2b 02 	sts	0x022B, r24
				distance('b',14,'o');
    1e56:	82 e6       	ldi	r24, 0x62	; 98
    1e58:	40 e0       	ldi	r20, 0x00	; 0
    1e5a:	50 e0       	ldi	r21, 0x00	; 0
    1e5c:	60 e6       	ldi	r22, 0x60	; 96
    1e5e:	71 e4       	ldi	r23, 0x41	; 65
    1e60:	2f e6       	ldi	r18, 0x6F	; 111
    1e62:	0e 94 a0 07 	call	0xf40	; 0xf40 <distance>
				enq_end(14);
    1e66:	8e e0       	ldi	r24, 0x0E	; 14
    1e68:	90 e0       	ldi	r25, 0x00	; 0
    1e6a:	0e 94 ee 06 	call	0xddc	; 0xddc <enq_end>
    1e6e:	9c c0       	rjmp	.+312    	; 0x1fa8 <node_behave+0x83c>
			}
			else
			{
				distance('f',11,'o');
    1e70:	86 e6       	ldi	r24, 0x66	; 102
    1e72:	40 e0       	ldi	r20, 0x00	; 0
    1e74:	50 e0       	ldi	r21, 0x00	; 0
    1e76:	60 e3       	ldi	r22, 0x30	; 48
    1e78:	71 e4       	ldi	r23, 0x41	; 65
    1e7a:	2f e6       	ldi	r18, 0x6F	; 111
    1e7c:	0e 94 a0 07 	call	0xf40	; 0xf40 <distance>
				left();
    1e80:	0e 94 2a 08 	call	0x1054	; 0x1054 <left>
				navigation_in_degrees=navigation_in_degrees+90;
    1e84:	80 91 3d 02 	lds	r24, 0x023D
    1e88:	90 91 3e 02 	lds	r25, 0x023E
    1e8c:	86 5a       	subi	r24, 0xA6	; 166
    1e8e:	9f 4f       	sbci	r25, 0xFF	; 255
    1e90:	90 93 3e 02 	sts	0x023E, r25
    1e94:	80 93 3d 02 	sts	0x023D, r24
				angle_rotate(97);
    1e98:	81 e6       	ldi	r24, 0x61	; 97
    1e9a:	90 e0       	ldi	r25, 0x00	; 0
    1e9c:	0e 94 3a 08 	call	0x1074	; 0x1074 <angle_rotate>
				stop();
    1ea0:	0e 94 26 08 	call	0x104c	; 0x104c <stop>
				if(weight_block_position_4==2)
    1ea4:	80 91 2d 02 	lds	r24, 0x022D
    1ea8:	90 91 2e 02 	lds	r25, 0x022E
    1eac:	82 30       	cpi	r24, 0x02	; 2
    1eae:	91 05       	cpc	r25, r1
    1eb0:	91 f5       	brne	.+100    	; 0x1f16 <node_behave+0x7aa>
				{
					distance('f',4,'o');
    1eb2:	86 e6       	ldi	r24, 0x66	; 102
    1eb4:	40 e0       	ldi	r20, 0x00	; 0
    1eb6:	50 e0       	ldi	r21, 0x00	; 0
    1eb8:	60 e8       	ldi	r22, 0x80	; 128
    1eba:	70 e4       	ldi	r23, 0x40	; 64
    1ebc:	2f e6       	ldi	r18, 0x6F	; 111
    1ebe:	0e 94 a0 07 	call	0xf40	; 0xf40 <distance>
					servo1_mov(16);
    1ec2:	80 e1       	ldi	r24, 0x10	; 16
    1ec4:	90 e0       	ldi	r25, 0x00	; 0
    1ec6:	0e 94 df 09 	call	0x13be	; 0x13be <servo1_mov>
    1eca:	8f ef       	ldi	r24, 0xFF	; 255
    1ecc:	9f ef       	ldi	r25, 0xFF	; 255
    1ece:	ac e2       	ldi	r26, 0x2C	; 44
    1ed0:	81 50       	subi	r24, 0x01	; 1
    1ed2:	90 40       	sbci	r25, 0x00	; 0
    1ed4:	a0 40       	sbci	r26, 0x00	; 0
    1ed6:	e1 f7       	brne	.-8      	; 0x1ed0 <node_behave+0x764>
    1ed8:	00 c0       	rjmp	.+0      	; 0x1eda <node_behave+0x76e>
    1eda:	00 00       	nop
					_delay_ms(1000);
					servo2_mov(1);
    1edc:	81 e0       	ldi	r24, 0x01	; 1
    1ede:	90 e0       	ldi	r25, 0x00	; 0
    1ee0:	0e 94 29 0a 	call	0x1452	; 0x1452 <servo2_mov>
    1ee4:	8f ef       	ldi	r24, 0xFF	; 255
    1ee6:	9f ef       	ldi	r25, 0xFF	; 255
    1ee8:	ac e2       	ldi	r26, 0x2C	; 44
    1eea:	81 50       	subi	r24, 0x01	; 1
    1eec:	90 40       	sbci	r25, 0x00	; 0
    1eee:	a0 40       	sbci	r26, 0x00	; 0
    1ef0:	e1 f7       	brne	.-8      	; 0x1eea <node_behave+0x77e>
    1ef2:	00 c0       	rjmp	.+0      	; 0x1ef4 <node_behave+0x788>
    1ef4:	00 00       	nop
					_delay_ms(1000);
					servo1_mov(130);
    1ef6:	82 e8       	ldi	r24, 0x82	; 130
    1ef8:	90 e0       	ldi	r25, 0x00	; 0
    1efa:	0e 94 df 09 	call	0x13be	; 0x13be <servo1_mov>
    1efe:	8f ef       	ldi	r24, 0xFF	; 255
    1f00:	9f e7       	ldi	r25, 0x7F	; 127
    1f02:	a1 e3       	ldi	r26, 0x31	; 49
    1f04:	81 50       	subi	r24, 0x01	; 1
    1f06:	90 40       	sbci	r25, 0x00	; 0
    1f08:	a0 40       	sbci	r26, 0x00	; 0
    1f0a:	e1 f7       	brne	.-8      	; 0x1f04 <node_behave+0x798>
    1f0c:	00 c0       	rjmp	.+0      	; 0x1f0e <node_behave+0x7a2>
    1f0e:	00 00       	nop
					_delay_ms(1100);
					servo1_free();
    1f10:	0e 94 50 0a 	call	0x14a0	; 0x14a0 <servo1_free>
    1f14:	34 c0       	rjmp	.+104    	; 0x1f7e <node_behave+0x812>
				}
				else if(weight_block_position_4==1)
    1f16:	81 30       	cpi	r24, 0x01	; 1
    1f18:	91 05       	cpc	r25, r1
    1f1a:	89 f5       	brne	.+98     	; 0x1f7e <node_behave+0x812>
				{
					distance('f',4,'o');
    1f1c:	86 e6       	ldi	r24, 0x66	; 102
    1f1e:	40 e0       	ldi	r20, 0x00	; 0
    1f20:	50 e0       	ldi	r21, 0x00	; 0
    1f22:	60 e8       	ldi	r22, 0x80	; 128
    1f24:	70 e4       	ldi	r23, 0x40	; 64
    1f26:	2f e6       	ldi	r18, 0x6F	; 111
    1f28:	0e 94 a0 07 	call	0xf40	; 0xf40 <distance>
					servo1_mov(11);
    1f2c:	8b e0       	ldi	r24, 0x0B	; 11
    1f2e:	90 e0       	ldi	r25, 0x00	; 0
    1f30:	0e 94 df 09 	call	0x13be	; 0x13be <servo1_mov>
    1f34:	8f ef       	ldi	r24, 0xFF	; 255
    1f36:	9f ef       	ldi	r25, 0xFF	; 255
    1f38:	ac e2       	ldi	r26, 0x2C	; 44
    1f3a:	81 50       	subi	r24, 0x01	; 1
    1f3c:	90 40       	sbci	r25, 0x00	; 0
    1f3e:	a0 40       	sbci	r26, 0x00	; 0
    1f40:	e1 f7       	brne	.-8      	; 0x1f3a <node_behave+0x7ce>
    1f42:	00 c0       	rjmp	.+0      	; 0x1f44 <node_behave+0x7d8>
    1f44:	00 00       	nop
					_delay_ms(1000);
					servo2_mov(1);
    1f46:	81 e0       	ldi	r24, 0x01	; 1
    1f48:	90 e0       	ldi	r25, 0x00	; 0
    1f4a:	0e 94 29 0a 	call	0x1452	; 0x1452 <servo2_mov>
    1f4e:	8f ef       	ldi	r24, 0xFF	; 255
    1f50:	9f ef       	ldi	r25, 0xFF	; 255
    1f52:	ac e2       	ldi	r26, 0x2C	; 44
    1f54:	81 50       	subi	r24, 0x01	; 1
    1f56:	90 40       	sbci	r25, 0x00	; 0
    1f58:	a0 40       	sbci	r26, 0x00	; 0
    1f5a:	e1 f7       	brne	.-8      	; 0x1f54 <node_behave+0x7e8>
    1f5c:	00 c0       	rjmp	.+0      	; 0x1f5e <node_behave+0x7f2>
    1f5e:	00 00       	nop
					_delay_ms(1000);
					servo1_mov(130);
    1f60:	82 e8       	ldi	r24, 0x82	; 130
    1f62:	90 e0       	ldi	r25, 0x00	; 0
    1f64:	0e 94 df 09 	call	0x13be	; 0x13be <servo1_mov>
    1f68:	8f ef       	ldi	r24, 0xFF	; 255
    1f6a:	9f e7       	ldi	r25, 0x7F	; 127
    1f6c:	a1 e3       	ldi	r26, 0x31	; 49
    1f6e:	81 50       	subi	r24, 0x01	; 1
    1f70:	90 40       	sbci	r25, 0x00	; 0
    1f72:	a0 40       	sbci	r26, 0x00	; 0
    1f74:	e1 f7       	brne	.-8      	; 0x1f6e <node_behave+0x802>
    1f76:	00 c0       	rjmp	.+0      	; 0x1f78 <node_behave+0x80c>
    1f78:	00 00       	nop
					_delay_ms(1100);
					servo1_free();
    1f7a:	0e 94 50 0a 	call	0x14a0	; 0x14a0 <servo1_free>
				}
			weight_block_position_4--;
    1f7e:	80 91 2d 02 	lds	r24, 0x022D
    1f82:	90 91 2e 02 	lds	r25, 0x022E
    1f86:	01 97       	sbiw	r24, 0x01	; 1
    1f88:	90 93 2e 02 	sts	0x022E, r25
    1f8c:	80 93 2d 02 	sts	0x022D, r24
			distance('b',14,'o');
    1f90:	82 e6       	ldi	r24, 0x62	; 98
    1f92:	40 e0       	ldi	r20, 0x00	; 0
    1f94:	50 e0       	ldi	r21, 0x00	; 0
    1f96:	60 e6       	ldi	r22, 0x60	; 96
    1f98:	71 e4       	ldi	r23, 0x41	; 65
    1f9a:	2f e6       	ldi	r18, 0x6F	; 111
    1f9c:	0e 94 a0 07 	call	0xf40	; 0xf40 <distance>
			enq_end(14);
    1fa0:	8e e0       	ldi	r24, 0x0E	; 14
    1fa2:	90 e0       	ldi	r25, 0x00	; 0
    1fa4:	0e 94 ee 06 	call	0xddc	; 0xddc <enq_end>
			}
		}

		if(node_number==3)
    1fa8:	80 91 5f 02 	lds	r24, 0x025F
    1fac:	90 91 60 02 	lds	r25, 0x0260
    1fb0:	83 30       	cpi	r24, 0x03	; 3
    1fb2:	91 05       	cpc	r25, r1
    1fb4:	09 f0       	breq	.+2      	; 0x1fb8 <node_behave+0x84c>
    1fb6:	82 c0       	rjmp	.+260    	; 0x20bc <node_behave+0x950>
		{
			distance('f',12.5,'o');
    1fb8:	86 e6       	ldi	r24, 0x66	; 102
    1fba:	40 e0       	ldi	r20, 0x00	; 0
    1fbc:	50 e0       	ldi	r21, 0x00	; 0
    1fbe:	68 e4       	ldi	r22, 0x48	; 72
    1fc0:	71 e4       	ldi	r23, 0x41	; 65
    1fc2:	2f e6       	ldi	r18, 0x6F	; 111
    1fc4:	0e 94 a0 07 	call	0xf40	; 0xf40 <distance>
			if(weight_block_position_2==2)
    1fc8:	80 91 31 02 	lds	r24, 0x0231
    1fcc:	90 91 32 02 	lds	r25, 0x0232
    1fd0:	82 30       	cpi	r24, 0x02	; 2
    1fd2:	91 05       	cpc	r25, r1
    1fd4:	51 f5       	brne	.+84     	; 0x202a <node_behave+0x8be>
			{
				servo1_mov(16);
    1fd6:	80 e1       	ldi	r24, 0x10	; 16
    1fd8:	90 e0       	ldi	r25, 0x00	; 0
    1fda:	0e 94 df 09 	call	0x13be	; 0x13be <servo1_mov>
    1fde:	8f ef       	ldi	r24, 0xFF	; 255
    1fe0:	9f ef       	ldi	r25, 0xFF	; 255
    1fe2:	ac e2       	ldi	r26, 0x2C	; 44
    1fe4:	81 50       	subi	r24, 0x01	; 1
    1fe6:	90 40       	sbci	r25, 0x00	; 0
    1fe8:	a0 40       	sbci	r26, 0x00	; 0
    1fea:	e1 f7       	brne	.-8      	; 0x1fe4 <node_behave+0x878>
    1fec:	00 c0       	rjmp	.+0      	; 0x1fee <node_behave+0x882>
    1fee:	00 00       	nop
				_delay_ms(1000);
				servo2_mov(1);
    1ff0:	81 e0       	ldi	r24, 0x01	; 1
    1ff2:	90 e0       	ldi	r25, 0x00	; 0
    1ff4:	0e 94 29 0a 	call	0x1452	; 0x1452 <servo2_mov>
    1ff8:	8f ef       	ldi	r24, 0xFF	; 255
    1ffa:	9f ef       	ldi	r25, 0xFF	; 255
    1ffc:	ac e2       	ldi	r26, 0x2C	; 44
    1ffe:	81 50       	subi	r24, 0x01	; 1
    2000:	90 40       	sbci	r25, 0x00	; 0
    2002:	a0 40       	sbci	r26, 0x00	; 0
    2004:	e1 f7       	brne	.-8      	; 0x1ffe <node_behave+0x892>
    2006:	00 c0       	rjmp	.+0      	; 0x2008 <node_behave+0x89c>
    2008:	00 00       	nop
				_delay_ms(1000);
				servo1_mov(130);
    200a:	82 e8       	ldi	r24, 0x82	; 130
    200c:	90 e0       	ldi	r25, 0x00	; 0
    200e:	0e 94 df 09 	call	0x13be	; 0x13be <servo1_mov>
    2012:	8f ef       	ldi	r24, 0xFF	; 255
    2014:	9f e7       	ldi	r25, 0x7F	; 127
    2016:	a1 e3       	ldi	r26, 0x31	; 49
    2018:	81 50       	subi	r24, 0x01	; 1
    201a:	90 40       	sbci	r25, 0x00	; 0
    201c:	a0 40       	sbci	r26, 0x00	; 0
    201e:	e1 f7       	brne	.-8      	; 0x2018 <node_behave+0x8ac>
    2020:	00 c0       	rjmp	.+0      	; 0x2022 <node_behave+0x8b6>
    2022:	00 00       	nop
				_delay_ms(1100);
				servo1_free();
    2024:	0e 94 50 0a 	call	0x14a0	; 0x14a0 <servo1_free>
    2028:	34 c0       	rjmp	.+104    	; 0x2092 <node_behave+0x926>
			}
			else if(weight_block_position_2==1)
    202a:	81 30       	cpi	r24, 0x01	; 1
    202c:	91 05       	cpc	r25, r1
    202e:	89 f5       	brne	.+98     	; 0x2092 <node_behave+0x926>
			{
				distance('f',1,'o');
    2030:	86 e6       	ldi	r24, 0x66	; 102
    2032:	40 e0       	ldi	r20, 0x00	; 0
    2034:	50 e0       	ldi	r21, 0x00	; 0
    2036:	60 e8       	ldi	r22, 0x80	; 128
    2038:	7f e3       	ldi	r23, 0x3F	; 63
    203a:	2f e6       	ldi	r18, 0x6F	; 111
    203c:	0e 94 a0 07 	call	0xf40	; 0xf40 <distance>
				servo1_mov(10);
    2040:	8a e0       	ldi	r24, 0x0A	; 10
    2042:	90 e0       	ldi	r25, 0x00	; 0
    2044:	0e 94 df 09 	call	0x13be	; 0x13be <servo1_mov>
    2048:	8f ef       	ldi	r24, 0xFF	; 255
    204a:	9f ef       	ldi	r25, 0xFF	; 255
    204c:	ac e2       	ldi	r26, 0x2C	; 44
    204e:	81 50       	subi	r24, 0x01	; 1
    2050:	90 40       	sbci	r25, 0x00	; 0
    2052:	a0 40       	sbci	r26, 0x00	; 0
    2054:	e1 f7       	brne	.-8      	; 0x204e <node_behave+0x8e2>
    2056:	00 c0       	rjmp	.+0      	; 0x2058 <node_behave+0x8ec>
    2058:	00 00       	nop
				_delay_ms(1000);
				servo2_mov(1);
    205a:	81 e0       	ldi	r24, 0x01	; 1
    205c:	90 e0       	ldi	r25, 0x00	; 0
    205e:	0e 94 29 0a 	call	0x1452	; 0x1452 <servo2_mov>
    2062:	8f ef       	ldi	r24, 0xFF	; 255
    2064:	9f ef       	ldi	r25, 0xFF	; 255
    2066:	ac e2       	ldi	r26, 0x2C	; 44
    2068:	81 50       	subi	r24, 0x01	; 1
    206a:	90 40       	sbci	r25, 0x00	; 0
    206c:	a0 40       	sbci	r26, 0x00	; 0
    206e:	e1 f7       	brne	.-8      	; 0x2068 <node_behave+0x8fc>
    2070:	00 c0       	rjmp	.+0      	; 0x2072 <node_behave+0x906>
    2072:	00 00       	nop
				_delay_ms(1000);
				servo1_mov(130);
    2074:	82 e8       	ldi	r24, 0x82	; 130
    2076:	90 e0       	ldi	r25, 0x00	; 0
    2078:	0e 94 df 09 	call	0x13be	; 0x13be <servo1_mov>
    207c:	8f ef       	ldi	r24, 0xFF	; 255
    207e:	9f e7       	ldi	r25, 0x7F	; 127
    2080:	a1 e3       	ldi	r26, 0x31	; 49
    2082:	81 50       	subi	r24, 0x01	; 1
    2084:	90 40       	sbci	r25, 0x00	; 0
    2086:	a0 40       	sbci	r26, 0x00	; 0
    2088:	e1 f7       	brne	.-8      	; 0x2082 <node_behave+0x916>
    208a:	00 c0       	rjmp	.+0      	; 0x208c <node_behave+0x920>
    208c:	00 00       	nop
				_delay_ms(1100);
				servo1_free();
    208e:	0e 94 50 0a 	call	0x14a0	; 0x14a0 <servo1_free>
			}
			weight_block_position_2--;
    2092:	80 91 31 02 	lds	r24, 0x0231
    2096:	90 91 32 02 	lds	r25, 0x0232
    209a:	01 97       	sbiw	r24, 0x01	; 1
    209c:	90 93 32 02 	sts	0x0232, r25
    20a0:	80 93 31 02 	sts	0x0231, r24
			distance('b',14.5,'o');
    20a4:	82 e6       	ldi	r24, 0x62	; 98
    20a6:	40 e0       	ldi	r20, 0x00	; 0
    20a8:	50 e0       	ldi	r21, 0x00	; 0
    20aa:	68 e6       	ldi	r22, 0x68	; 104
    20ac:	71 e4       	ldi	r23, 0x41	; 65
    20ae:	2f e6       	ldi	r18, 0x6F	; 111
    20b0:	0e 94 a0 07 	call	0xf40	; 0xf40 <distance>
			enq_end(4);              //adding node 4 in priority queue
    20b4:	84 e0       	ldi	r24, 0x04	; 4
    20b6:	90 e0       	ldi	r25, 0x00	; 0
    20b8:	0e 94 ee 06 	call	0xddc	; 0xddc <enq_end>
		}
		if(node_number==12)
    20bc:	80 91 5f 02 	lds	r24, 0x025F
    20c0:	90 91 60 02 	lds	r25, 0x0260
    20c4:	8c 30       	cpi	r24, 0x0C	; 12
    20c6:	91 05       	cpc	r25, r1
    20c8:	09 f0       	breq	.+2      	; 0x20cc <node_behave+0x960>
    20ca:	82 c0       	rjmp	.+260    	; 0x21d0 <node_behave+0xa64>
		{
			distance('f',12,'o');
    20cc:	86 e6       	ldi	r24, 0x66	; 102
    20ce:	40 e0       	ldi	r20, 0x00	; 0
    20d0:	50 e0       	ldi	r21, 0x00	; 0
    20d2:	60 e4       	ldi	r22, 0x40	; 64
    20d4:	71 e4       	ldi	r23, 0x41	; 65
    20d6:	2f e6       	ldi	r18, 0x6F	; 111
    20d8:	0e 94 a0 07 	call	0xf40	; 0xf40 <distance>
			if(weight_block_position_3==2)
    20dc:	80 91 2f 02 	lds	r24, 0x022F
    20e0:	90 91 30 02 	lds	r25, 0x0230
    20e4:	82 30       	cpi	r24, 0x02	; 2
    20e6:	91 05       	cpc	r25, r1
    20e8:	51 f5       	brne	.+84     	; 0x213e <node_behave+0x9d2>
			{
				servo1_mov(16);
    20ea:	80 e1       	ldi	r24, 0x10	; 16
    20ec:	90 e0       	ldi	r25, 0x00	; 0
    20ee:	0e 94 df 09 	call	0x13be	; 0x13be <servo1_mov>
    20f2:	8f ef       	ldi	r24, 0xFF	; 255
    20f4:	9f ef       	ldi	r25, 0xFF	; 255
    20f6:	ac e2       	ldi	r26, 0x2C	; 44
    20f8:	81 50       	subi	r24, 0x01	; 1
    20fa:	90 40       	sbci	r25, 0x00	; 0
    20fc:	a0 40       	sbci	r26, 0x00	; 0
    20fe:	e1 f7       	brne	.-8      	; 0x20f8 <node_behave+0x98c>
    2100:	00 c0       	rjmp	.+0      	; 0x2102 <node_behave+0x996>
    2102:	00 00       	nop
				_delay_ms(1000);
				servo2_mov(1);
    2104:	81 e0       	ldi	r24, 0x01	; 1
    2106:	90 e0       	ldi	r25, 0x00	; 0
    2108:	0e 94 29 0a 	call	0x1452	; 0x1452 <servo2_mov>
    210c:	8f ef       	ldi	r24, 0xFF	; 255
    210e:	9f ef       	ldi	r25, 0xFF	; 255
    2110:	ac e2       	ldi	r26, 0x2C	; 44
    2112:	81 50       	subi	r24, 0x01	; 1
    2114:	90 40       	sbci	r25, 0x00	; 0
    2116:	a0 40       	sbci	r26, 0x00	; 0
    2118:	e1 f7       	brne	.-8      	; 0x2112 <node_behave+0x9a6>
    211a:	00 c0       	rjmp	.+0      	; 0x211c <node_behave+0x9b0>
    211c:	00 00       	nop
				_delay_ms(1000);
				servo1_mov(130);
    211e:	82 e8       	ldi	r24, 0x82	; 130
    2120:	90 e0       	ldi	r25, 0x00	; 0
    2122:	0e 94 df 09 	call	0x13be	; 0x13be <servo1_mov>
    2126:	8f ef       	ldi	r24, 0xFF	; 255
    2128:	9f e7       	ldi	r25, 0x7F	; 127
    212a:	a1 e3       	ldi	r26, 0x31	; 49
    212c:	81 50       	subi	r24, 0x01	; 1
    212e:	90 40       	sbci	r25, 0x00	; 0
    2130:	a0 40       	sbci	r26, 0x00	; 0
    2132:	e1 f7       	brne	.-8      	; 0x212c <node_behave+0x9c0>
    2134:	00 c0       	rjmp	.+0      	; 0x2136 <node_behave+0x9ca>
    2136:	00 00       	nop
				_delay_ms(1100);
				servo1_free();
    2138:	0e 94 50 0a 	call	0x14a0	; 0x14a0 <servo1_free>
    213c:	34 c0       	rjmp	.+104    	; 0x21a6 <node_behave+0xa3a>
			}
			else if(weight_block_position_3==1)
    213e:	81 30       	cpi	r24, 0x01	; 1
    2140:	91 05       	cpc	r25, r1
    2142:	89 f5       	brne	.+98     	; 0x21a6 <node_behave+0xa3a>
			{
				distance('f',1,'o');
    2144:	86 e6       	ldi	r24, 0x66	; 102
    2146:	40 e0       	ldi	r20, 0x00	; 0
    2148:	50 e0       	ldi	r21, 0x00	; 0
    214a:	60 e8       	ldi	r22, 0x80	; 128
    214c:	7f e3       	ldi	r23, 0x3F	; 63
    214e:	2f e6       	ldi	r18, 0x6F	; 111
    2150:	0e 94 a0 07 	call	0xf40	; 0xf40 <distance>
				servo1_mov(11);
    2154:	8b e0       	ldi	r24, 0x0B	; 11
    2156:	90 e0       	ldi	r25, 0x00	; 0
    2158:	0e 94 df 09 	call	0x13be	; 0x13be <servo1_mov>
    215c:	8f ef       	ldi	r24, 0xFF	; 255
    215e:	9f ef       	ldi	r25, 0xFF	; 255
    2160:	ac e2       	ldi	r26, 0x2C	; 44
    2162:	81 50       	subi	r24, 0x01	; 1
    2164:	90 40       	sbci	r25, 0x00	; 0
    2166:	a0 40       	sbci	r26, 0x00	; 0
    2168:	e1 f7       	brne	.-8      	; 0x2162 <node_behave+0x9f6>
    216a:	00 c0       	rjmp	.+0      	; 0x216c <node_behave+0xa00>
    216c:	00 00       	nop
				_delay_ms(1000);
				servo2_mov(1);
    216e:	81 e0       	ldi	r24, 0x01	; 1
    2170:	90 e0       	ldi	r25, 0x00	; 0
    2172:	0e 94 29 0a 	call	0x1452	; 0x1452 <servo2_mov>
    2176:	8f ef       	ldi	r24, 0xFF	; 255
    2178:	9f ef       	ldi	r25, 0xFF	; 255
    217a:	ac e2       	ldi	r26, 0x2C	; 44
    217c:	81 50       	subi	r24, 0x01	; 1
    217e:	90 40       	sbci	r25, 0x00	; 0
    2180:	a0 40       	sbci	r26, 0x00	; 0
    2182:	e1 f7       	brne	.-8      	; 0x217c <node_behave+0xa10>
    2184:	00 c0       	rjmp	.+0      	; 0x2186 <node_behave+0xa1a>
    2186:	00 00       	nop
				_delay_ms(1000);
				servo1_mov(130);
    2188:	82 e8       	ldi	r24, 0x82	; 130
    218a:	90 e0       	ldi	r25, 0x00	; 0
    218c:	0e 94 df 09 	call	0x13be	; 0x13be <servo1_mov>
    2190:	8f ef       	ldi	r24, 0xFF	; 255
    2192:	9f e7       	ldi	r25, 0x7F	; 127
    2194:	a1 e3       	ldi	r26, 0x31	; 49
    2196:	81 50       	subi	r24, 0x01	; 1
    2198:	90 40       	sbci	r25, 0x00	; 0
    219a:	a0 40       	sbci	r26, 0x00	; 0
    219c:	e1 f7       	brne	.-8      	; 0x2196 <node_behave+0xa2a>
    219e:	00 c0       	rjmp	.+0      	; 0x21a0 <node_behave+0xa34>
    21a0:	00 00       	nop
				_delay_ms(1100);
				servo1_free();
    21a2:	0e 94 50 0a 	call	0x14a0	; 0x14a0 <servo1_free>
			}
			weight_block_position_3--;
    21a6:	80 91 2f 02 	lds	r24, 0x022F
    21aa:	90 91 30 02 	lds	r25, 0x0230
    21ae:	01 97       	sbiw	r24, 0x01	; 1
    21b0:	90 93 30 02 	sts	0x0230, r25
    21b4:	80 93 2f 02 	sts	0x022F, r24
			distance('b',14,'o');
    21b8:	82 e6       	ldi	r24, 0x62	; 98
    21ba:	40 e0       	ldi	r20, 0x00	; 0
    21bc:	50 e0       	ldi	r21, 0x00	; 0
    21be:	60 e6       	ldi	r22, 0x60	; 96
    21c0:	71 e4       	ldi	r23, 0x41	; 65
    21c2:	2f e6       	ldi	r18, 0x6F	; 111
    21c4:	0e 94 a0 07 	call	0xf40	; 0xf40 <distance>
			enq_end(14);
    21c8:	8e e0       	ldi	r24, 0x0E	; 14
    21ca:	90 e0       	ldi	r25, 0x00	; 0
    21cc:	0e 94 ee 06 	call	0xddc	; 0xddc <enq_end>
		}
		if(node_number==6)
    21d0:	80 91 5f 02 	lds	r24, 0x025F
    21d4:	90 91 60 02 	lds	r25, 0x0260
    21d8:	86 30       	cpi	r24, 0x06	; 6
    21da:	91 05       	cpc	r25, r1
    21dc:	09 f0       	breq	.+2      	; 0x21e0 <node_behave+0xa74>
    21de:	d2 c1       	rjmp	.+932    	; 0x2584 <__stack+0x385>
		{
			if(IP!=1)
    21e0:	80 91 35 02 	lds	r24, 0x0235
    21e4:	90 91 36 02 	lds	r25, 0x0236
    21e8:	81 30       	cpi	r24, 0x01	; 1
    21ea:	91 05       	cpc	r25, r1
    21ec:	09 f4       	brne	.+2      	; 0x21f0 <node_behave+0xa84>
    21ee:	79 c1       	rjmp	.+754    	; 0x24e2 <__stack+0x2e3>
			{
				distance('b',3,'0');
    21f0:	82 e6       	ldi	r24, 0x62	; 98
    21f2:	40 e0       	ldi	r20, 0x00	; 0
    21f4:	50 e0       	ldi	r21, 0x00	; 0
    21f6:	60 e4       	ldi	r22, 0x40	; 64
    21f8:	70 e4       	ldi	r23, 0x40	; 64
    21fa:	20 e3       	ldi	r18, 0x30	; 48
    21fc:	0e 94 a0 07 	call	0xf40	; 0xf40 <distance>
				if(IP==3)
    2200:	80 91 35 02 	lds	r24, 0x0235
    2204:	90 91 36 02 	lds	r25, 0x0236
    2208:	83 30       	cpi	r24, 0x03	; 3
    220a:	91 05       	cpc	r25, r1
    220c:	09 f0       	breq	.+2      	; 0x2210 <__stack+0x11>
    220e:	82 c0       	rjmp	.+260    	; 0x2314 <__stack+0x115>
				{
					distance('f',2,'0');
    2210:	86 e6       	ldi	r24, 0x66	; 102
    2212:	40 e0       	ldi	r20, 0x00	; 0
    2214:	50 e0       	ldi	r21, 0x00	; 0
    2216:	60 e0       	ldi	r22, 0x00	; 0
    2218:	70 e4       	ldi	r23, 0x40	; 64
    221a:	20 e3       	ldi	r18, 0x30	; 48
    221c:	0e 94 a0 07 	call	0xf40	; 0xf40 <distance>
					servo1_mov(37);
    2220:	85 e2       	ldi	r24, 0x25	; 37
    2222:	90 e0       	ldi	r25, 0x00	; 0
    2224:	0e 94 df 09 	call	0x13be	; 0x13be <servo1_mov>
    2228:	8f ef       	ldi	r24, 0xFF	; 255
    222a:	9f ef       	ldi	r25, 0xFF	; 255
    222c:	ac e2       	ldi	r26, 0x2C	; 44
    222e:	81 50       	subi	r24, 0x01	; 1
    2230:	90 40       	sbci	r25, 0x00	; 0
    2232:	a0 40       	sbci	r26, 0x00	; 0
    2234:	e1 f7       	brne	.-8      	; 0x222e <__stack+0x2f>
    2236:	00 c0       	rjmp	.+0      	; 0x2238 <__stack+0x39>
    2238:	00 00       	nop
					_delay_ms(1000);
					pick_waste();
    223a:	0e 94 5e 0a 	call	0x14bc	; 0x14bc <pick_waste>
					servo1_mov(80);
    223e:	80 e5       	ldi	r24, 0x50	; 80
    2240:	90 e0       	ldi	r25, 0x00	; 0
    2242:	0e 94 df 09 	call	0x13be	; 0x13be <servo1_mov>
    2246:	8f ef       	ldi	r24, 0xFF	; 255
    2248:	9f ef       	ldi	r25, 0xFF	; 255
    224a:	ac e2       	ldi	r26, 0x2C	; 44
    224c:	81 50       	subi	r24, 0x01	; 1
    224e:	90 40       	sbci	r25, 0x00	; 0
    2250:	a0 40       	sbci	r26, 0x00	; 0
    2252:	e1 f7       	brne	.-8      	; 0x224c <__stack+0x4d>
    2254:	00 c0       	rjmp	.+0      	; 0x2256 <__stack+0x57>
    2256:	00 00       	nop
					_delay_ms(1000);
					left_degrees(180);
    2258:	84 eb       	ldi	r24, 0xB4	; 180
    225a:	90 e0       	ldi	r25, 0x00	; 0
    225c:	0e 94 af 08 	call	0x115e	; 0x115e <left_degrees>
					servo1_mov(0);
    2260:	80 e0       	ldi	r24, 0x00	; 0
    2262:	90 e0       	ldi	r25, 0x00	; 0
    2264:	0e 94 df 09 	call	0x13be	; 0x13be <servo1_mov>
    2268:	8f ef       	ldi	r24, 0xFF	; 255
    226a:	9f ef       	ldi	r25, 0xFF	; 255
    226c:	ac e2       	ldi	r26, 0x2C	; 44
    226e:	81 50       	subi	r24, 0x01	; 1
    2270:	90 40       	sbci	r25, 0x00	; 0
    2272:	a0 40       	sbci	r26, 0x00	; 0
    2274:	e1 f7       	brne	.-8      	; 0x226e <__stack+0x6f>
    2276:	00 c0       	rjmp	.+0      	; 0x2278 <__stack+0x79>
    2278:	00 00       	nop
					_delay_ms(1000);
					color_sensor();
    227a:	0e 94 59 16 	call	0x2cb2	; 0x2cb2 <color_sensor>
					color[color_index]=color_identified;
    227e:	e0 91 52 02 	lds	r30, 0x0252
    2282:	f0 91 53 02 	lds	r31, 0x0253
    2286:	eb 5c       	subi	r30, 0xCB	; 203
    2288:	fa 4f       	sbci	r31, 0xFA	; 250
    228a:	80 91 54 02 	lds	r24, 0x0254
    228e:	80 83       	st	Z, r24
					servo1_mov(80);
    2290:	80 e5       	ldi	r24, 0x50	; 80
    2292:	90 e0       	ldi	r25, 0x00	; 0
    2294:	0e 94 df 09 	call	0x13be	; 0x13be <servo1_mov>
    2298:	8f ef       	ldi	r24, 0xFF	; 255
    229a:	9f e7       	ldi	r25, 0x7F	; 127
    229c:	a4 e0       	ldi	r26, 0x04	; 4
    229e:	81 50       	subi	r24, 0x01	; 1
    22a0:	90 40       	sbci	r25, 0x00	; 0
    22a2:	a0 40       	sbci	r26, 0x00	; 0
    22a4:	e1 f7       	brne	.-8      	; 0x229e <__stack+0x9f>
    22a6:	00 c0       	rjmp	.+0      	; 0x22a8 <__stack+0xa9>
    22a8:	00 00       	nop
					_delay_ms(100);
					if(deposition_zone_B==1)
    22aa:	80 91 39 02 	lds	r24, 0x0239
    22ae:	90 91 3a 02 	lds	r25, 0x023A
    22b2:	81 30       	cpi	r24, 0x01	; 1
    22b4:	91 05       	cpc	r25, r1
    22b6:	29 f4       	brne	.+10     	; 0x22c2 <__stack+0xc3>
					path_find(16);
    22b8:	80 e1       	ldi	r24, 0x10	; 16
    22ba:	90 e0       	ldi	r25, 0x00	; 0
    22bc:	0e 94 f9 05 	call	0xbf2	; 0xbf2 <path_find>
    22c0:	17 c0       	rjmp	.+46     	; 0x22f0 <__stack+0xf1>
					else if(deposition_zone_A==1)
    22c2:	80 91 3b 02 	lds	r24, 0x023B
    22c6:	90 91 3c 02 	lds	r25, 0x023C
    22ca:	81 30       	cpi	r24, 0x01	; 1
    22cc:	91 05       	cpc	r25, r1
    22ce:	29 f4       	brne	.+10     	; 0x22da <__stack+0xdb>
					path_find(15);
    22d0:	8f e0       	ldi	r24, 0x0F	; 15
    22d2:	90 e0       	ldi	r25, 0x00	; 0
    22d4:	0e 94 f9 05 	call	0xbf2	; 0xbf2 <path_find>
    22d8:	0b c0       	rjmp	.+22     	; 0x22f0 <__stack+0xf1>
					else if(deposition_zone_C==1)
    22da:	80 91 37 02 	lds	r24, 0x0237
    22de:	90 91 38 02 	lds	r25, 0x0238
    22e2:	81 30       	cpi	r24, 0x01	; 1
    22e4:	91 05       	cpc	r25, r1
    22e6:	21 f4       	brne	.+8      	; 0x22f0 <__stack+0xf1>
					path_find(17);
    22e8:	81 e1       	ldi	r24, 0x11	; 17
    22ea:	90 e0       	ldi	r25, 0x00	; 0
    22ec:	0e 94 f9 05 	call	0xbf2	; 0xbf2 <path_find>
					path_index++;
    22f0:	80 91 59 02 	lds	r24, 0x0259
    22f4:	90 91 5a 02 	lds	r25, 0x025A
    22f8:	01 96       	adiw	r24, 0x01	; 1
    22fa:	90 93 5a 02 	sts	0x025A, r25
    22fe:	80 93 59 02 	sts	0x0259, r24
					color_index++;
    2302:	80 91 52 02 	lds	r24, 0x0252
    2306:	90 91 53 02 	lds	r25, 0x0253
    230a:	01 96       	adiw	r24, 0x01	; 1
    230c:	90 93 53 02 	sts	0x0253, r25
    2310:	80 93 52 02 	sts	0x0252, r24
				}
			if(IP==2)
    2314:	80 91 35 02 	lds	r24, 0x0235
    2318:	90 91 36 02 	lds	r25, 0x0236
    231c:	82 30       	cpi	r24, 0x02	; 2
    231e:	91 05       	cpc	r25, r1
    2320:	09 f0       	breq	.+2      	; 0x2324 <__stack+0x125>
    2322:	d5 c0       	rjmp	.+426    	; 0x24ce <__stack+0x2cf>
				{
					distance('f',2,'o');
    2324:	86 e6       	ldi	r24, 0x66	; 102
    2326:	40 e0       	ldi	r20, 0x00	; 0
    2328:	50 e0       	ldi	r21, 0x00	; 0
    232a:	60 e0       	ldi	r22, 0x00	; 0
    232c:	70 e4       	ldi	r23, 0x40	; 64
    232e:	2f e6       	ldi	r18, 0x6F	; 111
    2330:	0e 94 a0 07 	call	0xf40	; 0xf40 <distance>
					servo1_mov(25);
    2334:	89 e1       	ldi	r24, 0x19	; 25
    2336:	90 e0       	ldi	r25, 0x00	; 0
    2338:	0e 94 df 09 	call	0x13be	; 0x13be <servo1_mov>
    233c:	8f ef       	ldi	r24, 0xFF	; 255
    233e:	9f ef       	ldi	r25, 0xFF	; 255
    2340:	ac e2       	ldi	r26, 0x2C	; 44
    2342:	81 50       	subi	r24, 0x01	; 1
    2344:	90 40       	sbci	r25, 0x00	; 0
    2346:	a0 40       	sbci	r26, 0x00	; 0
    2348:	e1 f7       	brne	.-8      	; 0x2342 <__stack+0x143>
    234a:	00 c0       	rjmp	.+0      	; 0x234c <__stack+0x14d>
    234c:	00 00       	nop
					_delay_ms(1000);
					pick_waste();
    234e:	0e 94 5e 0a 	call	0x14bc	; 0x14bc <pick_waste>
					servo1_mov(80);
    2352:	80 e5       	ldi	r24, 0x50	; 80
    2354:	90 e0       	ldi	r25, 0x00	; 0
    2356:	0e 94 df 09 	call	0x13be	; 0x13be <servo1_mov>
    235a:	8f ef       	ldi	r24, 0xFF	; 255
    235c:	9f ef       	ldi	r25, 0xFF	; 255
    235e:	ac e2       	ldi	r26, 0x2C	; 44
    2360:	81 50       	subi	r24, 0x01	; 1
    2362:	90 40       	sbci	r25, 0x00	; 0
    2364:	a0 40       	sbci	r26, 0x00	; 0
    2366:	e1 f7       	brne	.-8      	; 0x2360 <__stack+0x161>
    2368:	00 c0       	rjmp	.+0      	; 0x236a <__stack+0x16b>
    236a:	00 00       	nop
					_delay_ms(1000);
					left_degrees(180);
    236c:	84 eb       	ldi	r24, 0xB4	; 180
    236e:	90 e0       	ldi	r25, 0x00	; 0
    2370:	0e 94 af 08 	call	0x115e	; 0x115e <left_degrees>
					servo1_mov(0);
    2374:	80 e0       	ldi	r24, 0x00	; 0
    2376:	90 e0       	ldi	r25, 0x00	; 0
    2378:	0e 94 df 09 	call	0x13be	; 0x13be <servo1_mov>
    237c:	8f ef       	ldi	r24, 0xFF	; 255
    237e:	9f ef       	ldi	r25, 0xFF	; 255
    2380:	ac e2       	ldi	r26, 0x2C	; 44
    2382:	81 50       	subi	r24, 0x01	; 1
    2384:	90 40       	sbci	r25, 0x00	; 0
    2386:	a0 40       	sbci	r26, 0x00	; 0
    2388:	e1 f7       	brne	.-8      	; 0x2382 <__stack+0x183>
    238a:	00 c0       	rjmp	.+0      	; 0x238c <__stack+0x18d>
    238c:	00 00       	nop
					_delay_ms(1000);
					color_sensor();
    238e:	0e 94 59 16 	call	0x2cb2	; 0x2cb2 <color_sensor>
					color[color_index]=color_identified;
    2392:	e0 91 52 02 	lds	r30, 0x0252
    2396:	f0 91 53 02 	lds	r31, 0x0253
    239a:	eb 5c       	subi	r30, 0xCB	; 203
    239c:	fa 4f       	sbci	r31, 0xFA	; 250
    239e:	80 91 54 02 	lds	r24, 0x0254
    23a2:	80 83       	st	Z, r24
					servo1_mov(80);
    23a4:	80 e5       	ldi	r24, 0x50	; 80
    23a6:	90 e0       	ldi	r25, 0x00	; 0
    23a8:	0e 94 df 09 	call	0x13be	; 0x13be <servo1_mov>
    23ac:	8f ef       	ldi	r24, 0xFF	; 255
    23ae:	9f e7       	ldi	r25, 0x7F	; 127
    23b0:	a4 e0       	ldi	r26, 0x04	; 4
    23b2:	81 50       	subi	r24, 0x01	; 1
    23b4:	90 40       	sbci	r25, 0x00	; 0
    23b6:	a0 40       	sbci	r26, 0x00	; 0
    23b8:	e1 f7       	brne	.-8      	; 0x23b2 <__stack+0x1b3>
    23ba:	00 c0       	rjmp	.+0      	; 0x23bc <__stack+0x1bd>
    23bc:	00 00       	nop
    23be:	c4 ea       	ldi	r28, 0xA4	; 164
    23c0:	d2 e0       	ldi	r29, 0x02	; 2
    23c2:	0f e0       	ldi	r16, 0x0F	; 15
    23c4:	10 e0       	ldi	r17, 0x00	; 0
					_delay_ms(100);
					int a=0;             //summing variable
    23c6:	cc 24       	eor	r12, r12
    23c8:	dd 24       	eor	r13, r13
					for(i=0;i<4;i++)
					{
						if(color[color_index]==color_deposited[i])
    23ca:	0f 2e       	mov	r0, r31
    23cc:	f5 e3       	ldi	r31, 0x35	; 53
    23ce:	af 2e       	mov	r10, r31
    23d0:	f5 e0       	ldi	r31, 0x05	; 5
    23d2:	bf 2e       	mov	r11, r31
    23d4:	f0 2d       	mov	r31, r0
							             
* Example Call:				node_behave(); 
*
*/

void node_behave(void) 
    23d6:	7e 01       	movw	r14, r28
					servo1_mov(80);
					_delay_ms(100);
					int a=0;             //summing variable
					for(i=0;i<4;i++)
					{
						if(color[color_index]==color_deposited[i])
    23d8:	80 91 52 02 	lds	r24, 0x0252
    23dc:	90 91 53 02 	lds	r25, 0x0253
    23e0:	8a 0d       	add	r24, r10
    23e2:	9b 1d       	adc	r25, r11
    23e4:	dc 01       	movw	r26, r24
    23e6:	9c 91       	ld	r25, X
    23e8:	88 81       	ld	r24, Y
    23ea:	98 17       	cp	r25, r24
    23ec:	61 f4       	brne	.+24     	; 0x2406 <__stack+0x207>
						{
							color_found++;
    23ee:	80 91 5b 02 	lds	r24, 0x025B
    23f2:	90 91 5c 02 	lds	r25, 0x025C
    23f6:	01 96       	adiw	r24, 0x01	; 1
    23f8:	90 93 5c 02 	sts	0x025C, r25
    23fc:	80 93 5b 02 	sts	0x025B, r24
							path_find(15+i);
    2400:	c8 01       	movw	r24, r16
    2402:	0e 94 f9 05 	call	0xbf2	; 0xbf2 <path_find>
    2406:	21 96       	adiw	r28, 0x01	; 1
						}
						if(color_deposited[i]!='\0')
    2408:	f7 01       	movw	r30, r14
    240a:	80 81       	ld	r24, Z
    240c:	88 23       	and	r24, r24
    240e:	19 f0       	breq	.+6      	; 0x2416 <__stack+0x217>
						a++;
    2410:	08 94       	sec
    2412:	c1 1c       	adc	r12, r1
    2414:	d1 1c       	adc	r13, r1
    2416:	0f 5f       	subi	r16, 0xFF	; 255
    2418:	1f 4f       	sbci	r17, 0xFF	; 255
					color_sensor();
					color[color_index]=color_identified;
					servo1_mov(80);
					_delay_ms(100);
					int a=0;             //summing variable
					for(i=0;i<4;i++)
    241a:	03 31       	cpi	r16, 0x13	; 19
    241c:	11 05       	cpc	r17, r1
    241e:	d9 f6       	brne	.-74     	; 0x23d6 <__stack+0x1d7>
							path_find(15+i);
						}
						if(color_deposited[i]!='\0')
						a++;
					}
					if(a>2)
    2420:	f3 e0       	ldi	r31, 0x03	; 3
    2422:	cf 16       	cp	r12, r31
    2424:	d1 04       	cpc	r13, r1
    2426:	4c f0       	brlt	.+18     	; 0x243a <__stack+0x23b>
					color_found++;
    2428:	80 91 5b 02 	lds	r24, 0x025B
    242c:	90 91 5c 02 	lds	r25, 0x025C
    2430:	01 96       	adiw	r24, 0x01	; 1
    2432:	90 93 5c 02 	sts	0x025C, r25
    2436:	80 93 5b 02 	sts	0x025B, r24
					if(path[path_index]=='\0')
    243a:	e0 91 59 02 	lds	r30, 0x0259
    243e:	f0 91 5a 02 	lds	r31, 0x025A
    2442:	e1 59       	subi	r30, 0x91	; 145
    2444:	fd 4f       	sbci	r31, 0xFD	; 253
    2446:	80 81       	ld	r24, Z
    2448:	88 23       	and	r24, r24
    244a:	79 f5       	brne	.+94     	; 0x24aa <__stack+0x2ab>
					{
						if(deposition_zone_B==1 && color_deposited[1]=='\0')
    244c:	80 91 39 02 	lds	r24, 0x0239
    2450:	90 91 3a 02 	lds	r25, 0x023A
    2454:	81 30       	cpi	r24, 0x01	; 1
    2456:	91 05       	cpc	r25, r1
    2458:	49 f4       	brne	.+18     	; 0x246c <__stack+0x26d>
    245a:	80 91 a5 02 	lds	r24, 0x02A5
    245e:	88 23       	and	r24, r24
    2460:	29 f4       	brne	.+10     	; 0x246c <__stack+0x26d>
						path_find(16);
    2462:	80 e1       	ldi	r24, 0x10	; 16
    2464:	90 e0       	ldi	r25, 0x00	; 0
    2466:	0e 94 f9 05 	call	0xbf2	; 0xbf2 <path_find>
    246a:	1f c0       	rjmp	.+62     	; 0x24aa <__stack+0x2ab>
						else if(deposition_zone_A==1 && color_deposited[0]=='\0')
    246c:	80 91 3b 02 	lds	r24, 0x023B
    2470:	90 91 3c 02 	lds	r25, 0x023C
    2474:	81 30       	cpi	r24, 0x01	; 1
    2476:	91 05       	cpc	r25, r1
    2478:	49 f4       	brne	.+18     	; 0x248c <__stack+0x28d>
    247a:	80 91 a4 02 	lds	r24, 0x02A4
    247e:	88 23       	and	r24, r24
    2480:	29 f4       	brne	.+10     	; 0x248c <__stack+0x28d>
						path_find(15);
    2482:	8f e0       	ldi	r24, 0x0F	; 15
    2484:	90 e0       	ldi	r25, 0x00	; 0
    2486:	0e 94 f9 05 	call	0xbf2	; 0xbf2 <path_find>
    248a:	0f c0       	rjmp	.+30     	; 0x24aa <__stack+0x2ab>
						else if(deposition_zone_C==1 && color_deposited[2]=='\0')
    248c:	80 91 37 02 	lds	r24, 0x0237
    2490:	90 91 38 02 	lds	r25, 0x0238
    2494:	81 30       	cpi	r24, 0x01	; 1
    2496:	91 05       	cpc	r25, r1
    2498:	41 f4       	brne	.+16     	; 0x24aa <__stack+0x2ab>
    249a:	80 91 a6 02 	lds	r24, 0x02A6
    249e:	88 23       	and	r24, r24
    24a0:	21 f4       	brne	.+8      	; 0x24aa <__stack+0x2ab>
						path_find(17);
    24a2:	81 e1       	ldi	r24, 0x11	; 17
    24a4:	90 e0       	ldi	r25, 0x00	; 0
    24a6:	0e 94 f9 05 	call	0xbf2	; 0xbf2 <path_find>
					}
					path_index++;
    24aa:	80 91 59 02 	lds	r24, 0x0259
    24ae:	90 91 5a 02 	lds	r25, 0x025A
    24b2:	01 96       	adiw	r24, 0x01	; 1
    24b4:	90 93 5a 02 	sts	0x025A, r25
    24b8:	80 93 59 02 	sts	0x0259, r24
					color_index++;
    24bc:	80 91 52 02 	lds	r24, 0x0252
    24c0:	90 91 53 02 	lds	r25, 0x0253
    24c4:	01 96       	adiw	r24, 0x01	; 1
    24c6:	90 93 53 02 	sts	0x0253, r25
    24ca:	80 93 52 02 	sts	0x0252, r24
				}
					IP--;
    24ce:	80 91 35 02 	lds	r24, 0x0235
    24d2:	90 91 36 02 	lds	r25, 0x0236
    24d6:	01 97       	sbiw	r24, 0x01	; 1
    24d8:	90 93 36 02 	sts	0x0236, r25
    24dc:	80 93 35 02 	sts	0x0235, r24
    24e0:	51 c0       	rjmp	.+162    	; 0x2584 <__stack+0x385>
			}
			else
			{
				color_found++;
    24e2:	80 91 5b 02 	lds	r24, 0x025B
    24e6:	90 91 5c 02 	lds	r25, 0x025C
    24ea:	01 96       	adiw	r24, 0x01	; 1
    24ec:	90 93 5c 02 	sts	0x025C, r25
    24f0:	80 93 5b 02 	sts	0x025B, r24
				servo1_mov(0);
    24f4:	80 e0       	ldi	r24, 0x00	; 0
    24f6:	90 e0       	ldi	r25, 0x00	; 0
    24f8:	0e 94 df 09 	call	0x13be	; 0x13be <servo1_mov>
    24fc:	8f ef       	ldi	r24, 0xFF	; 255
    24fe:	9f ef       	ldi	r25, 0xFF	; 255
    2500:	ac e2       	ldi	r26, 0x2C	; 44
    2502:	81 50       	subi	r24, 0x01	; 1
    2504:	90 40       	sbci	r25, 0x00	; 0
    2506:	a0 40       	sbci	r26, 0x00	; 0
    2508:	e1 f7       	brne	.-8      	; 0x2502 <__stack+0x303>
    250a:	00 c0       	rjmp	.+0      	; 0x250c <__stack+0x30d>
    250c:	00 00       	nop
				_delay_ms(1000);
				pick_waste();
    250e:	0e 94 5e 0a 	call	0x14bc	; 0x14bc <pick_waste>
				servo1_mov(80);
    2512:	80 e5       	ldi	r24, 0x50	; 80
    2514:	90 e0       	ldi	r25, 0x00	; 0
    2516:	0e 94 df 09 	call	0x13be	; 0x13be <servo1_mov>
    251a:	8f ef       	ldi	r24, 0xFF	; 255
    251c:	9f ef       	ldi	r25, 0xFF	; 255
    251e:	ac e2       	ldi	r26, 0x2C	; 44
    2520:	81 50       	subi	r24, 0x01	; 1
    2522:	90 40       	sbci	r25, 0x00	; 0
    2524:	a0 40       	sbci	r26, 0x00	; 0
    2526:	e1 f7       	brne	.-8      	; 0x2520 <__stack+0x321>
    2528:	00 c0       	rjmp	.+0      	; 0x252a <__stack+0x32b>
    252a:	00 00       	nop
				_delay_ms(1000);
				if(deposition_zone_B==1)
    252c:	80 91 39 02 	lds	r24, 0x0239
    2530:	90 91 3a 02 	lds	r25, 0x023A
    2534:	81 30       	cpi	r24, 0x01	; 1
    2536:	91 05       	cpc	r25, r1
    2538:	29 f4       	brne	.+10     	; 0x2544 <__stack+0x345>
				path_find(16);
    253a:	80 e1       	ldi	r24, 0x10	; 16
    253c:	90 e0       	ldi	r25, 0x00	; 0
    253e:	0e 94 f9 05 	call	0xbf2	; 0xbf2 <path_find>
    2542:	17 c0       	rjmp	.+46     	; 0x2572 <__stack+0x373>
				else if(deposition_zone_A==1)
    2544:	80 91 3b 02 	lds	r24, 0x023B
    2548:	90 91 3c 02 	lds	r25, 0x023C
    254c:	81 30       	cpi	r24, 0x01	; 1
    254e:	91 05       	cpc	r25, r1
    2550:	29 f4       	brne	.+10     	; 0x255c <__stack+0x35d>
				path_find(15);
    2552:	8f e0       	ldi	r24, 0x0F	; 15
    2554:	90 e0       	ldi	r25, 0x00	; 0
    2556:	0e 94 f9 05 	call	0xbf2	; 0xbf2 <path_find>
    255a:	0b c0       	rjmp	.+22     	; 0x2572 <__stack+0x373>
				else if(deposition_zone_C==1)
    255c:	80 91 37 02 	lds	r24, 0x0237
    2560:	90 91 38 02 	lds	r25, 0x0238
    2564:	81 30       	cpi	r24, 0x01	; 1
    2566:	91 05       	cpc	r25, r1
    2568:	21 f4       	brne	.+8      	; 0x2572 <__stack+0x373>
				path_find(17);
    256a:	81 e1       	ldi	r24, 0x11	; 17
    256c:	90 e0       	ldi	r25, 0x00	; 0
    256e:	0e 94 f9 05 	call	0xbf2	; 0xbf2 <path_find>
				color_index++;
    2572:	80 91 52 02 	lds	r24, 0x0252
    2576:	90 91 53 02 	lds	r25, 0x0253
    257a:	01 96       	adiw	r24, 0x01	; 1
    257c:	90 93 53 02 	sts	0x0253, r25
    2580:	80 93 52 02 	sts	0x0252, r24
			}

		}
				if(node_number==4)
    2584:	80 91 5f 02 	lds	r24, 0x025F
    2588:	90 91 60 02 	lds	r25, 0x0260
    258c:	84 30       	cpi	r24, 0x04	; 4
    258e:	91 05       	cpc	r25, r1
    2590:	09 f0       	breq	.+2      	; 0x2594 <__stack+0x395>
    2592:	4b c0       	rjmp	.+150    	; 0x262a <__stack+0x42b>
		{
			distance('b',4,'o');
    2594:	82 e6       	ldi	r24, 0x62	; 98
    2596:	40 e0       	ldi	r20, 0x00	; 0
    2598:	50 e0       	ldi	r21, 0x00	; 0
    259a:	60 e8       	ldi	r22, 0x80	; 128
    259c:	70 e4       	ldi	r23, 0x40	; 64
    259e:	2f e6       	ldi	r18, 0x6F	; 111
    25a0:	0e 94 a0 07 	call	0xf40	; 0xf40 <distance>
			servo1_mov(66);
    25a4:	82 e4       	ldi	r24, 0x42	; 66
    25a6:	90 e0       	ldi	r25, 0x00	; 0
    25a8:	0e 94 df 09 	call	0x13be	; 0x13be <servo1_mov>
    25ac:	8f ef       	ldi	r24, 0xFF	; 255
    25ae:	9f ef       	ldi	r25, 0xFF	; 255
    25b0:	ac e2       	ldi	r26, 0x2C	; 44
    25b2:	81 50       	subi	r24, 0x01	; 1
    25b4:	90 40       	sbci	r25, 0x00	; 0
    25b6:	a0 40       	sbci	r26, 0x00	; 0
    25b8:	e1 f7       	brne	.-8      	; 0x25b2 <__stack+0x3b3>
    25ba:	00 c0       	rjmp	.+0      	; 0x25bc <__stack+0x3bd>
    25bc:	00 00       	nop
			_delay_ms(1000);
			servo2_mov(45);
    25be:	8d e2       	ldi	r24, 0x2D	; 45
    25c0:	90 e0       	ldi	r25, 0x00	; 0
    25c2:	0e 94 29 0a 	call	0x1452	; 0x1452 <servo2_mov>
    25c6:	8f ef       	ldi	r24, 0xFF	; 255
    25c8:	9f e7       	ldi	r25, 0x7F	; 127
    25ca:	a6 e1       	ldi	r26, 0x16	; 22
    25cc:	81 50       	subi	r24, 0x01	; 1
    25ce:	90 40       	sbci	r25, 0x00	; 0
    25d0:	a0 40       	sbci	r26, 0x00	; 0
    25d2:	e1 f7       	brne	.-8      	; 0x25cc <__stack+0x3cd>
    25d4:	00 c0       	rjmp	.+0      	; 0x25d6 <__stack+0x3d7>
    25d6:	00 00       	nop
			_delay_ms(500);
			servo1_mov(90);
    25d8:	8a e5       	ldi	r24, 0x5A	; 90
    25da:	90 e0       	ldi	r25, 0x00	; 0
    25dc:	0e 94 df 09 	call	0x13be	; 0x13be <servo1_mov>
			left();
    25e0:	0e 94 2a 08 	call	0x1054	; 0x1054 <left>
			navigation_in_degrees=navigation_in_degrees+180;
    25e4:	80 91 3d 02 	lds	r24, 0x023D
    25e8:	90 91 3e 02 	lds	r25, 0x023E
    25ec:	8c 54       	subi	r24, 0x4C	; 76
    25ee:	9f 4f       	sbci	r25, 0xFF	; 255
    25f0:	90 93 3e 02 	sts	0x023E, r25
    25f4:	80 93 3d 02 	sts	0x023D, r24
			angle_rotate(180);
    25f8:	84 eb       	ldi	r24, 0xB4	; 180
    25fa:	90 e0       	ldi	r25, 0x00	; 0
    25fc:	0e 94 3a 08 	call	0x1074	; 0x1074 <angle_rotate>
			path_find(0);
    2600:	80 e0       	ldi	r24, 0x00	; 0
    2602:	90 e0       	ldi	r25, 0x00	; 0
    2604:	0e 94 f9 05 	call	0xbf2	; 0xbf2 <path_find>
			path_index++;
    2608:	80 91 59 02 	lds	r24, 0x0259
    260c:	90 91 5a 02 	lds	r25, 0x025A
    2610:	01 96       	adiw	r24, 0x01	; 1
    2612:	90 93 5a 02 	sts	0x025A, r25
    2616:	80 93 59 02 	sts	0x0259, r24
			distance('b',4,'o');
    261a:	82 e6       	ldi	r24, 0x62	; 98
    261c:	40 e0       	ldi	r20, 0x00	; 0
    261e:	50 e0       	ldi	r21, 0x00	; 0
    2620:	60 e8       	ldi	r22, 0x80	; 128
    2622:	70 e4       	ldi	r23, 0x40	; 64
    2624:	2f e6       	ldi	r18, 0x6F	; 111
    2626:	0e 94 a0 07 	call	0xf40	; 0xf40 <distance>

		}
		if(node_number==14)
    262a:	80 91 5f 02 	lds	r24, 0x025F
    262e:	90 91 60 02 	lds	r25, 0x0260
    2632:	8e 30       	cpi	r24, 0x0E	; 14
    2634:	91 05       	cpc	r25, r1
    2636:	09 f0       	breq	.+2      	; 0x263a <__stack+0x43b>
    2638:	4b c0       	rjmp	.+150    	; 0x26d0 <__stack+0x4d1>
		{
			distance('b',4,'o');
    263a:	82 e6       	ldi	r24, 0x62	; 98
    263c:	40 e0       	ldi	r20, 0x00	; 0
    263e:	50 e0       	ldi	r21, 0x00	; 0
    2640:	60 e8       	ldi	r22, 0x80	; 128
    2642:	70 e4       	ldi	r23, 0x40	; 64
    2644:	2f e6       	ldi	r18, 0x6F	; 111
    2646:	0e 94 a0 07 	call	0xf40	; 0xf40 <distance>
			servo1_mov(66);
    264a:	82 e4       	ldi	r24, 0x42	; 66
    264c:	90 e0       	ldi	r25, 0x00	; 0
    264e:	0e 94 df 09 	call	0x13be	; 0x13be <servo1_mov>
    2652:	8f ef       	ldi	r24, 0xFF	; 255
    2654:	9f ef       	ldi	r25, 0xFF	; 255
    2656:	ac e2       	ldi	r26, 0x2C	; 44
    2658:	81 50       	subi	r24, 0x01	; 1
    265a:	90 40       	sbci	r25, 0x00	; 0
    265c:	a0 40       	sbci	r26, 0x00	; 0
    265e:	e1 f7       	brne	.-8      	; 0x2658 <__stack+0x459>
    2660:	00 c0       	rjmp	.+0      	; 0x2662 <__stack+0x463>
    2662:	00 00       	nop
			_delay_ms(1000);
			servo2_mov(45);
    2664:	8d e2       	ldi	r24, 0x2D	; 45
    2666:	90 e0       	ldi	r25, 0x00	; 0
    2668:	0e 94 29 0a 	call	0x1452	; 0x1452 <servo2_mov>
    266c:	8f ef       	ldi	r24, 0xFF	; 255
    266e:	9f e7       	ldi	r25, 0x7F	; 127
    2670:	a6 e1       	ldi	r26, 0x16	; 22
    2672:	81 50       	subi	r24, 0x01	; 1
    2674:	90 40       	sbci	r25, 0x00	; 0
    2676:	a0 40       	sbci	r26, 0x00	; 0
    2678:	e1 f7       	brne	.-8      	; 0x2672 <__stack+0x473>
    267a:	00 c0       	rjmp	.+0      	; 0x267c <__stack+0x47d>
    267c:	00 00       	nop
			_delay_ms(500);
			servo1_mov(90);
    267e:	8a e5       	ldi	r24, 0x5A	; 90
    2680:	90 e0       	ldi	r25, 0x00	; 0
    2682:	0e 94 df 09 	call	0x13be	; 0x13be <servo1_mov>
			left();
    2686:	0e 94 2a 08 	call	0x1054	; 0x1054 <left>
			navigation_in_degrees=navigation_in_degrees+180;
    268a:	80 91 3d 02 	lds	r24, 0x023D
    268e:	90 91 3e 02 	lds	r25, 0x023E
    2692:	8c 54       	subi	r24, 0x4C	; 76
    2694:	9f 4f       	sbci	r25, 0xFF	; 255
    2696:	90 93 3e 02 	sts	0x023E, r25
    269a:	80 93 3d 02 	sts	0x023D, r24
			angle_rotate(180);
    269e:	84 eb       	ldi	r24, 0xB4	; 180
    26a0:	90 e0       	ldi	r25, 0x00	; 0
    26a2:	0e 94 3a 08 	call	0x1074	; 0x1074 <angle_rotate>
			path_find(10);
    26a6:	8a e0       	ldi	r24, 0x0A	; 10
    26a8:	90 e0       	ldi	r25, 0x00	; 0
    26aa:	0e 94 f9 05 	call	0xbf2	; 0xbf2 <path_find>
			path_index++;
    26ae:	80 91 59 02 	lds	r24, 0x0259
    26b2:	90 91 5a 02 	lds	r25, 0x025A
    26b6:	01 96       	adiw	r24, 0x01	; 1
    26b8:	90 93 5a 02 	sts	0x025A, r25
    26bc:	80 93 59 02 	sts	0x0259, r24
			distance('b',4,'o');
    26c0:	82 e6       	ldi	r24, 0x62	; 98
    26c2:	40 e0       	ldi	r20, 0x00	; 0
    26c4:	50 e0       	ldi	r21, 0x00	; 0
    26c6:	60 e8       	ldi	r22, 0x80	; 128
    26c8:	70 e4       	ldi	r23, 0x40	; 64
    26ca:	2f e6       	ldi	r18, 0x6F	; 111
    26cc:	0e 94 a0 07 	call	0xf40	; 0xf40 <distance>
		}
		if(node_number==0)
    26d0:	80 91 5f 02 	lds	r24, 0x025F
    26d4:	90 91 60 02 	lds	r25, 0x0260
    26d8:	00 97       	sbiw	r24, 0x00	; 0
    26da:	09 f0       	breq	.+2      	; 0x26de <__stack+0x4df>
    26dc:	91 c0       	rjmp	.+290    	; 0x2800 <__stack+0x601>
		{
			if(*navigation_pointer!='W')
    26de:	e0 91 ac 02 	lds	r30, 0x02AC
    26e2:	f0 91 ad 02 	lds	r31, 0x02AD
    26e6:	80 81       	ld	r24, Z
    26e8:	87 35       	cpi	r24, 0x57	; 87
    26ea:	09 f4       	brne	.+2      	; 0x26ee <__stack+0x4ef>
    26ec:	52 c0       	rjmp	.+164    	; 0x2792 <__stack+0x593>
			{
				distance('f',11,'o');
    26ee:	86 e6       	ldi	r24, 0x66	; 102
    26f0:	40 e0       	ldi	r20, 0x00	; 0
    26f2:	50 e0       	ldi	r21, 0x00	; 0
    26f4:	60 e3       	ldi	r22, 0x30	; 48
    26f6:	71 e4       	ldi	r23, 0x41	; 65
    26f8:	2f e6       	ldi	r18, 0x6F	; 111
    26fa:	0e 94 a0 07 	call	0xf40	; 0xf40 <distance>
				if((*navigation_pointer-'W'==-9) || (*navigation_pointer-'W')==4 || (*navigation_pointer-'W')==14) //-9,4,14 are ASCII values for 270 degree while rotating in rightwards
    26fe:	e0 91 ac 02 	lds	r30, 0x02AC
    2702:	f0 91 ad 02 	lds	r31, 0x02AD
    2706:	20 81       	ld	r18, Z
    2708:	2e 34       	cpi	r18, 0x4E	; 78
    270a:	21 f0       	breq	.+8      	; 0x2714 <__stack+0x515>
    270c:	2b 35       	cpi	r18, 0x5B	; 91
    270e:	11 f0       	breq	.+4      	; 0x2714 <__stack+0x515>
    2710:	25 36       	cpi	r18, 0x65	; 101
    2712:	61 f4       	brne	.+24     	; 0x272c <__stack+0x52d>
				while(*navigation_pointer!='W')
				left_degrees(90);
    2714:	8a e5       	ldi	r24, 0x5A	; 90
    2716:	90 e0       	ldi	r25, 0x00	; 0
    2718:	0e 94 af 08 	call	0x115e	; 0x115e <left_degrees>
		{
			if(*navigation_pointer!='W')
			{
				distance('f',11,'o');
				if((*navigation_pointer-'W'==-9) || (*navigation_pointer-'W')==4 || (*navigation_pointer-'W')==14) //-9,4,14 are ASCII values for 270 degree while rotating in rightwards
				while(*navigation_pointer!='W')
    271c:	e0 91 ac 02 	lds	r30, 0x02AC
    2720:	f0 91 ad 02 	lds	r31, 0x02AD
    2724:	80 81       	ld	r24, Z
    2726:	87 35       	cpi	r24, 0x57	; 87
    2728:	a9 f7       	brne	.-22     	; 0x2714 <__stack+0x515>
    272a:	2b c0       	rjmp	.+86     	; 0x2782 <__stack+0x583>
				left_degrees(90);
				else if(abs(*navigation_pointer-'W')==5 || abs(*navigation_pointer-'W')==18)
    272c:	82 2f       	mov	r24, r18
    272e:	90 e0       	ldi	r25, 0x00	; 0
    2730:	87 55       	subi	r24, 0x57	; 87
    2732:	90 40       	sbci	r25, 0x00	; 0
    2734:	1a f4       	brpl	.+6      	; 0x273c <__stack+0x53d>
    2736:	90 95       	com	r25
    2738:	81 95       	neg	r24
    273a:	9f 4f       	sbci	r25, 0xFF	; 255
    273c:	85 30       	cpi	r24, 0x05	; 5
    273e:	91 05       	cpc	r25, r1
    2740:	19 f4       	brne	.+6      	; 0x2748 <__stack+0x549>
				while(*navigation_pointer!='W')
    2742:	27 35       	cpi	r18, 0x57	; 87
    2744:	39 f4       	brne	.+14     	; 0x2754 <__stack+0x555>
    2746:	1d c0       	rjmp	.+58     	; 0x2782 <__stack+0x583>
			{
				distance('f',11,'o');
				if((*navigation_pointer-'W'==-9) || (*navigation_pointer-'W')==4 || (*navigation_pointer-'W')==14) //-9,4,14 are ASCII values for 270 degree while rotating in rightwards
				while(*navigation_pointer!='W')
				left_degrees(90);
				else if(abs(*navigation_pointer-'W')==5 || abs(*navigation_pointer-'W')==18)
    2748:	82 31       	cpi	r24, 0x12	; 18
    274a:	91 05       	cpc	r25, r1
    274c:	d1 f3       	breq	.-12     	; 0x2742 <__stack+0x543>
				while(*navigation_pointer!='W')
				right_degrees(180);
				else
				while(*navigation_pointer!='W')
    274e:	27 35       	cpi	r18, 0x57	; 87
    2750:	69 f4       	brne	.+26     	; 0x276c <__stack+0x56d>
    2752:	17 c0       	rjmp	.+46     	; 0x2782 <__stack+0x583>
				if((*navigation_pointer-'W'==-9) || (*navigation_pointer-'W')==4 || (*navigation_pointer-'W')==14) //-9,4,14 are ASCII values for 270 degree while rotating in rightwards
				while(*navigation_pointer!='W')
				left_degrees(90);
				else if(abs(*navigation_pointer-'W')==5 || abs(*navigation_pointer-'W')==18)
				while(*navigation_pointer!='W')
				right_degrees(180);
    2754:	84 eb       	ldi	r24, 0xB4	; 180
    2756:	90 e0       	ldi	r25, 0x00	; 0
    2758:	0e 94 16 09 	call	0x122c	; 0x122c <right_degrees>
				distance('f',11,'o');
				if((*navigation_pointer-'W'==-9) || (*navigation_pointer-'W')==4 || (*navigation_pointer-'W')==14) //-9,4,14 are ASCII values for 270 degree while rotating in rightwards
				while(*navigation_pointer!='W')
				left_degrees(90);
				else if(abs(*navigation_pointer-'W')==5 || abs(*navigation_pointer-'W')==18)
				while(*navigation_pointer!='W')
    275c:	e0 91 ac 02 	lds	r30, 0x02AC
    2760:	f0 91 ad 02 	lds	r31, 0x02AD
    2764:	80 81       	ld	r24, Z
    2766:	87 35       	cpi	r24, 0x57	; 87
    2768:	a9 f7       	brne	.-22     	; 0x2754 <__stack+0x555>
    276a:	0b c0       	rjmp	.+22     	; 0x2782 <__stack+0x583>
				right_degrees(180);
				else
				while(*navigation_pointer!='W')
				right_degrees(90);
    276c:	8a e5       	ldi	r24, 0x5A	; 90
    276e:	90 e0       	ldi	r25, 0x00	; 0
    2770:	0e 94 16 09 	call	0x122c	; 0x122c <right_degrees>
				left_degrees(90);
				else if(abs(*navigation_pointer-'W')==5 || abs(*navigation_pointer-'W')==18)
				while(*navigation_pointer!='W')
				right_degrees(180);
				else
				while(*navigation_pointer!='W')
    2774:	e0 91 ac 02 	lds	r30, 0x02AC
    2778:	f0 91 ad 02 	lds	r31, 0x02AD
    277c:	80 81       	ld	r24, Z
    277e:	87 35       	cpi	r24, 0x57	; 87
    2780:	a9 f7       	brne	.-22     	; 0x276c <__stack+0x56d>
				right_degrees(90);
				distance('b',11,'o');
    2782:	82 e6       	ldi	r24, 0x62	; 98
    2784:	40 e0       	ldi	r20, 0x00	; 0
    2786:	50 e0       	ldi	r21, 0x00	; 0
    2788:	60 e3       	ldi	r22, 0x30	; 48
    278a:	71 e4       	ldi	r23, 0x41	; 65
    278c:	2f e6       	ldi	r18, 0x6F	; 111
    278e:	0e 94 a0 07 	call	0xf40	; 0xf40 <distance>
			}
			if(sharp(digital[11])>300)
    2792:	80 91 50 05 	lds	r24, 0x0550
    2796:	90 91 51 05 	lds	r25, 0x0551
    279a:	0e 94 74 0b 	call	0x16e8	; 0x16e8 <sharp>
    279e:	a1 e0       	ldi	r26, 0x01	; 1
    27a0:	8d 32       	cpi	r24, 0x2D	; 45
    27a2:	9a 07       	cpc	r25, r26
    27a4:	2c f0       	brlt	.+10     	; 0x27b0 <__stack+0x5b1>
			{
				bridge=Area;
    27a6:	80 91 56 02 	lds	r24, 0x0256
    27aa:	80 93 55 02 	sts	0x0255, r24
    27ae:	12 c0       	rjmp	.+36     	; 0x27d4 <__stack+0x5d5>
			}
			else
			{
				bridge='I';
    27b0:	89 e4       	ldi	r24, 0x49	; 73
    27b2:	80 93 55 02 	sts	0x0255, r24
				if(weight_block_position_2==0)
    27b6:	80 91 31 02 	lds	r24, 0x0231
    27ba:	90 91 32 02 	lds	r25, 0x0232
    27be:	00 97       	sbiw	r24, 0x00	; 0
    27c0:	29 f4       	brne	.+10     	; 0x27cc <__stack+0x5cd>
				enq_end(1);
    27c2:	81 e0       	ldi	r24, 0x01	; 1
    27c4:	90 e0       	ldi	r25, 0x00	; 0
    27c6:	0e 94 ee 06 	call	0xddc	; 0xddc <enq_end>
    27ca:	04 c0       	rjmp	.+8      	; 0x27d4 <__stack+0x5d5>
				else
				enq_end(3);
    27cc:	83 e0       	ldi	r24, 0x03	; 3
    27ce:	90 e0       	ldi	r25, 0x00	; 0
    27d0:	0e 94 ee 06 	call	0xddc	; 0xddc <enq_end>
			}
			navigate();
    27d4:	0e 94 6b 04 	call	0x8d6	; 0x8d6 <navigate>
			if(servo_angle_1!=180)
    27d8:	80 91 41 02 	lds	r24, 0x0241
    27dc:	90 91 42 02 	lds	r25, 0x0242
    27e0:	84 3b       	cpi	r24, 0xB4	; 180
    27e2:	91 05       	cpc	r25, r1
    27e4:	69 f0       	breq	.+26     	; 0x2800 <__stack+0x601>
			{
				servo1_mov(80);
    27e6:	80 e5       	ldi	r24, 0x50	; 80
    27e8:	90 e0       	ldi	r25, 0x00	; 0
    27ea:	0e 94 df 09 	call	0x13be	; 0x13be <servo1_mov>
    27ee:	8f ef       	ldi	r24, 0xFF	; 255
    27f0:	9f ef       	ldi	r25, 0xFF	; 255
    27f2:	a3 e2       	ldi	r26, 0x23	; 35
    27f4:	81 50       	subi	r24, 0x01	; 1
    27f6:	90 40       	sbci	r25, 0x00	; 0
    27f8:	a0 40       	sbci	r26, 0x00	; 0
    27fa:	e1 f7       	brne	.-8      	; 0x27f4 <__stack+0x5f5>
    27fc:	00 c0       	rjmp	.+0      	; 0x27fe <__stack+0x5ff>
    27fe:	00 00       	nop
				_delay_ms(800);
			}
		}
		if(node_number==10)
    2800:	80 91 5f 02 	lds	r24, 0x025F
    2804:	90 91 60 02 	lds	r25, 0x0260
    2808:	8a 30       	cpi	r24, 0x0A	; 10
    280a:	91 05       	cpc	r25, r1
    280c:	09 f0       	breq	.+2      	; 0x2810 <__stack+0x611>
    280e:	91 c0       	rjmp	.+290    	; 0x2932 <__stack+0x733>
		{
			if(*navigation_pointer!='E')
    2810:	e0 91 ac 02 	lds	r30, 0x02AC
    2814:	f0 91 ad 02 	lds	r31, 0x02AD
    2818:	80 81       	ld	r24, Z
    281a:	85 34       	cpi	r24, 0x45	; 69
    281c:	09 f4       	brne	.+2      	; 0x2820 <__stack+0x621>
    281e:	52 c0       	rjmp	.+164    	; 0x28c4 <__stack+0x6c5>
			{
				distance('f',11,'o');
    2820:	86 e6       	ldi	r24, 0x66	; 102
    2822:	40 e0       	ldi	r20, 0x00	; 0
    2824:	50 e0       	ldi	r21, 0x00	; 0
    2826:	60 e3       	ldi	r22, 0x30	; 48
    2828:	71 e4       	ldi	r23, 0x41	; 65
    282a:	2f e6       	ldi	r18, 0x6F	; 111
    282c:	0e 94 a0 07 	call	0xf40	; 0xf40 <distance>
				if((*navigation_pointer-'E'==-9) || (*navigation_pointer-'E')==4 || (*navigation_pointer-'E')==14) //-9,4,14 are ASCII values for 270 degree while rotating in rightwards
    2830:	e0 91 ac 02 	lds	r30, 0x02AC
    2834:	f0 91 ad 02 	lds	r31, 0x02AD
    2838:	20 81       	ld	r18, Z
    283a:	2c 33       	cpi	r18, 0x3C	; 60
    283c:	21 f0       	breq	.+8      	; 0x2846 <__stack+0x647>
    283e:	29 34       	cpi	r18, 0x49	; 73
    2840:	11 f0       	breq	.+4      	; 0x2846 <__stack+0x647>
    2842:	23 35       	cpi	r18, 0x53	; 83
    2844:	61 f4       	brne	.+24     	; 0x285e <__stack+0x65f>
				while(*navigation_pointer!='E')
				left_degrees(90);
    2846:	8a e5       	ldi	r24, 0x5A	; 90
    2848:	90 e0       	ldi	r25, 0x00	; 0
    284a:	0e 94 af 08 	call	0x115e	; 0x115e <left_degrees>
		{
			if(*navigation_pointer!='E')
			{
				distance('f',11,'o');
				if((*navigation_pointer-'E'==-9) || (*navigation_pointer-'E')==4 || (*navigation_pointer-'E')==14) //-9,4,14 are ASCII values for 270 degree while rotating in rightwards
				while(*navigation_pointer!='E')
    284e:	e0 91 ac 02 	lds	r30, 0x02AC
    2852:	f0 91 ad 02 	lds	r31, 0x02AD
    2856:	80 81       	ld	r24, Z
    2858:	85 34       	cpi	r24, 0x45	; 69
    285a:	a9 f7       	brne	.-22     	; 0x2846 <__stack+0x647>
    285c:	2b c0       	rjmp	.+86     	; 0x28b4 <__stack+0x6b5>
				left_degrees(90);
				else if(abs(*navigation_pointer-'E')==5 || abs(*navigation_pointer-'E')==18)
    285e:	82 2f       	mov	r24, r18
    2860:	90 e0       	ldi	r25, 0x00	; 0
    2862:	85 54       	subi	r24, 0x45	; 69
    2864:	90 40       	sbci	r25, 0x00	; 0
    2866:	1a f4       	brpl	.+6      	; 0x286e <__stack+0x66f>
    2868:	90 95       	com	r25
    286a:	81 95       	neg	r24
    286c:	9f 4f       	sbci	r25, 0xFF	; 255
    286e:	85 30       	cpi	r24, 0x05	; 5
    2870:	91 05       	cpc	r25, r1
    2872:	19 f4       	brne	.+6      	; 0x287a <__stack+0x67b>
				while(*navigation_pointer!='E')
    2874:	25 34       	cpi	r18, 0x45	; 69
    2876:	39 f4       	brne	.+14     	; 0x2886 <__stack+0x687>
    2878:	1d c0       	rjmp	.+58     	; 0x28b4 <__stack+0x6b5>
			{
				distance('f',11,'o');
				if((*navigation_pointer-'E'==-9) || (*navigation_pointer-'E')==4 || (*navigation_pointer-'E')==14) //-9,4,14 are ASCII values for 270 degree while rotating in rightwards
				while(*navigation_pointer!='E')
				left_degrees(90);
				else if(abs(*navigation_pointer-'E')==5 || abs(*navigation_pointer-'E')==18)
    287a:	82 31       	cpi	r24, 0x12	; 18
    287c:	91 05       	cpc	r25, r1
    287e:	d1 f3       	breq	.-12     	; 0x2874 <__stack+0x675>
				while(*navigation_pointer!='E')
				right_degrees(180);
				else
				while(*navigation_pointer!='E')
    2880:	25 34       	cpi	r18, 0x45	; 69
    2882:	69 f4       	brne	.+26     	; 0x289e <__stack+0x69f>
    2884:	17 c0       	rjmp	.+46     	; 0x28b4 <__stack+0x6b5>
				if((*navigation_pointer-'E'==-9) || (*navigation_pointer-'E')==4 || (*navigation_pointer-'E')==14) //-9,4,14 are ASCII values for 270 degree while rotating in rightwards
				while(*navigation_pointer!='E')
				left_degrees(90);
				else if(abs(*navigation_pointer-'E')==5 || abs(*navigation_pointer-'E')==18)
				while(*navigation_pointer!='E')
				right_degrees(180);
    2886:	84 eb       	ldi	r24, 0xB4	; 180
    2888:	90 e0       	ldi	r25, 0x00	; 0
    288a:	0e 94 16 09 	call	0x122c	; 0x122c <right_degrees>
				distance('f',11,'o');
				if((*navigation_pointer-'E'==-9) || (*navigation_pointer-'E')==4 || (*navigation_pointer-'E')==14) //-9,4,14 are ASCII values for 270 degree while rotating in rightwards
				while(*navigation_pointer!='E')
				left_degrees(90);
				else if(abs(*navigation_pointer-'E')==5 || abs(*navigation_pointer-'E')==18)
				while(*navigation_pointer!='E')
    288e:	e0 91 ac 02 	lds	r30, 0x02AC
    2892:	f0 91 ad 02 	lds	r31, 0x02AD
    2896:	80 81       	ld	r24, Z
    2898:	85 34       	cpi	r24, 0x45	; 69
    289a:	a9 f7       	brne	.-22     	; 0x2886 <__stack+0x687>
    289c:	0b c0       	rjmp	.+22     	; 0x28b4 <__stack+0x6b5>
				right_degrees(180);
				else
				while(*navigation_pointer!='E')
				right_degrees(90);
    289e:	8a e5       	ldi	r24, 0x5A	; 90
    28a0:	90 e0       	ldi	r25, 0x00	; 0
    28a2:	0e 94 16 09 	call	0x122c	; 0x122c <right_degrees>
				left_degrees(90);
				else if(abs(*navigation_pointer-'E')==5 || abs(*navigation_pointer-'E')==18)
				while(*navigation_pointer!='E')
				right_degrees(180);
				else
				while(*navigation_pointer!='E')
    28a6:	e0 91 ac 02 	lds	r30, 0x02AC
    28aa:	f0 91 ad 02 	lds	r31, 0x02AD
    28ae:	80 81       	ld	r24, Z
    28b0:	85 34       	cpi	r24, 0x45	; 69
    28b2:	a9 f7       	brne	.-22     	; 0x289e <__stack+0x69f>
				right_degrees(90);
				distance('b',12,'o');
    28b4:	82 e6       	ldi	r24, 0x62	; 98
    28b6:	40 e0       	ldi	r20, 0x00	; 0
    28b8:	50 e0       	ldi	r21, 0x00	; 0
    28ba:	60 e4       	ldi	r22, 0x40	; 64
    28bc:	71 e4       	ldi	r23, 0x41	; 65
    28be:	2f e6       	ldi	r18, 0x6F	; 111
    28c0:	0e 94 a0 07 	call	0xf40	; 0xf40 <distance>
			}
			if(sharp(digital[11])>300)
    28c4:	80 91 50 05 	lds	r24, 0x0550
    28c8:	90 91 51 05 	lds	r25, 0x0551
    28cc:	0e 94 74 0b 	call	0x16e8	; 0x16e8 <sharp>
    28d0:	a1 e0       	ldi	r26, 0x01	; 1
    28d2:	8d 32       	cpi	r24, 0x2D	; 45
    28d4:	9a 07       	cpc	r25, r26
    28d6:	2c f0       	brlt	.+10     	; 0x28e2 <__stack+0x6e3>
			bridge=Area;
    28d8:	80 91 56 02 	lds	r24, 0x0256
    28dc:	80 93 55 02 	sts	0x0255, r24
    28e0:	12 c0       	rjmp	.+36     	; 0x2906 <__stack+0x707>
			else
			{
				bridge='C';
    28e2:	83 e4       	ldi	r24, 0x43	; 67
    28e4:	80 93 55 02 	sts	0x0255, r24
				if(weight_block_position_3!=0)
    28e8:	80 91 2f 02 	lds	r24, 0x022F
    28ec:	90 91 30 02 	lds	r25, 0x0230
    28f0:	00 97       	sbiw	r24, 0x00	; 0
    28f2:	29 f0       	breq	.+10     	; 0x28fe <__stack+0x6ff>
				enq_end(12);
    28f4:	8c e0       	ldi	r24, 0x0C	; 12
    28f6:	90 e0       	ldi	r25, 0x00	; 0
    28f8:	0e 94 ee 06 	call	0xddc	; 0xddc <enq_end>
    28fc:	04 c0       	rjmp	.+8      	; 0x2906 <__stack+0x707>
				else
				enq_end(13);
    28fe:	8d e0       	ldi	r24, 0x0D	; 13
    2900:	90 e0       	ldi	r25, 0x00	; 0
    2902:	0e 94 ee 06 	call	0xddc	; 0xddc <enq_end>
			}
			navigate();
    2906:	0e 94 6b 04 	call	0x8d6	; 0x8d6 <navigate>
			if(servo_angle_1!=180)
    290a:	80 91 41 02 	lds	r24, 0x0241
    290e:	90 91 42 02 	lds	r25, 0x0242
    2912:	84 3b       	cpi	r24, 0xB4	; 180
    2914:	91 05       	cpc	r25, r1
    2916:	69 f0       	breq	.+26     	; 0x2932 <__stack+0x733>
			{
				servo1_mov(80);
    2918:	80 e5       	ldi	r24, 0x50	; 80
    291a:	90 e0       	ldi	r25, 0x00	; 0
    291c:	0e 94 df 09 	call	0x13be	; 0x13be <servo1_mov>
    2920:	8f ef       	ldi	r24, 0xFF	; 255
    2922:	9f ef       	ldi	r25, 0xFF	; 255
    2924:	a3 e2       	ldi	r26, 0x23	; 35
    2926:	81 50       	subi	r24, 0x01	; 1
    2928:	90 40       	sbci	r25, 0x00	; 0
    292a:	a0 40       	sbci	r26, 0x00	; 0
    292c:	e1 f7       	brne	.-8      	; 0x2926 <__stack+0x727>
    292e:	00 c0       	rjmp	.+0      	; 0x2930 <__stack+0x731>
    2930:	00 00       	nop
				_delay_ms(800);
			}
		}

		if(que_length!=0 && path[path_index]=='\0')
    2932:	80 91 57 02 	lds	r24, 0x0257
    2936:	90 91 58 02 	lds	r25, 0x0258
    293a:	00 97       	sbiw	r24, 0x00	; 0
    293c:	a1 f0       	breq	.+40     	; 0x2966 <__stack+0x767>
    293e:	e0 91 59 02 	lds	r30, 0x0259
    2942:	f0 91 5a 02 	lds	r31, 0x025A
    2946:	e1 59       	subi	r30, 0x91	; 145
    2948:	fd 4f       	sbci	r31, 0xFD	; 253
    294a:	80 81       	ld	r24, Z
    294c:	88 23       	and	r24, r24
    294e:	49 f5       	brne	.+82     	; 0x29a2 <__stack+0x7a3>
		{
			path_find(end->num);
    2950:	e0 91 4a 02 	lds	r30, 0x024A
    2954:	f0 91 4b 02 	lds	r31, 0x024B
    2958:	84 81       	ldd	r24, Z+4	; 0x04
    295a:	95 81       	ldd	r25, Z+5	; 0x05
    295c:	0e 94 f9 05 	call	0xbf2	; 0xbf2 <path_find>
			dequeue();
    2960:	0e 94 30 07 	call	0xe60	; 0xe60 <dequeue>
    2964:	1e c0       	rjmp	.+60     	; 0x29a2 <__stack+0x7a3>
		}
		else if(path[path_index]=='\0')
    2966:	e0 91 59 02 	lds	r30, 0x0259
    296a:	f0 91 5a 02 	lds	r31, 0x025A
    296e:	e1 59       	subi	r30, 0x91	; 145
    2970:	fd 4f       	sbci	r31, 0xFD	; 253
    2972:	80 81       	ld	r24, Z
    2974:	88 23       	and	r24, r24
    2976:	a9 f4       	brne	.+42     	; 0x29a2 <__stack+0x7a3>
		{
			buzzer(1);
    2978:	81 e0       	ldi	r24, 0x01	; 1
    297a:	90 e0       	ldi	r25, 0x00	; 0
    297c:	0e 94 4d 07 	call	0xe9a	; 0xe9a <buzzer>
    2980:	8f ef       	ldi	r24, 0xFF	; 255
    2982:	9f ef       	ldi	r25, 0xFF	; 255
    2984:	a9 e5       	ldi	r26, 0x59	; 89
    2986:	81 50       	subi	r24, 0x01	; 1
    2988:	90 40       	sbci	r25, 0x00	; 0
    298a:	a0 40       	sbci	r26, 0x00	; 0
    298c:	e1 f7       	brne	.-8      	; 0x2986 <__stack+0x787>
    298e:	00 c0       	rjmp	.+0      	; 0x2990 <__stack+0x791>
    2990:	00 00       	nop
			_delay_ms(2000);
			buzzer(0);
    2992:	80 e0       	ldi	r24, 0x00	; 0
    2994:	90 e0       	ldi	r25, 0x00	; 0
    2996:	0e 94 4d 07 	call	0xe9a	; 0xe9a <buzzer>
			exit(1);
    299a:	81 e0       	ldi	r24, 0x01	; 1
    299c:	90 e0       	ldi	r25, 0x00	; 0
    299e:	0e 94 b4 1c 	call	0x3968	; 0x3968 <_exit>
		}
	}
}
    29a2:	df 91       	pop	r29
    29a4:	cf 91       	pop	r28
    29a6:	1f 91       	pop	r17
    29a8:	0f 91       	pop	r16
    29aa:	ff 90       	pop	r15
    29ac:	ef 90       	pop	r14
    29ae:	df 90       	pop	r13
    29b0:	cf 90       	pop	r12
    29b2:	bf 90       	pop	r11
    29b4:	af 90       	pop	r10
    29b6:	08 95       	ret

000029b8 <__vector_35>:
* Example Call:								NONE
*
*/

ISR(TIMER3_OVF_vect) // Timer 3overflow interrupt to get digital value
{
    29b8:	1f 92       	push	r1
    29ba:	0f 92       	push	r0
    29bc:	0f b6       	in	r0, 0x3f	; 63
    29be:	0f 92       	push	r0
    29c0:	0b b6       	in	r0, 0x3b	; 59
    29c2:	0f 92       	push	r0
    29c4:	11 24       	eor	r1, r1
    29c6:	2f 93       	push	r18
    29c8:	3f 93       	push	r19
    29ca:	4f 93       	push	r20
    29cc:	5f 93       	push	r21
    29ce:	6f 93       	push	r22
    29d0:	7f 93       	push	r23
    29d2:	8f 93       	push	r24
    29d4:	9f 93       	push	r25
    29d6:	af 93       	push	r26
    29d8:	bf 93       	push	r27
    29da:	ef 93       	push	r30
    29dc:	ff 93       	push	r31
	int i=0;
	for(i=1;i<4;i++)
	digital[i]=getdata(i);
    29de:	81 e0       	ldi	r24, 0x01	; 1
    29e0:	90 e0       	ldi	r25, 0x00	; 0
    29e2:	0e 94 8a 0a 	call	0x1514	; 0x1514 <getdata>
    29e6:	28 2f       	mov	r18, r24
    29e8:	39 2f       	mov	r19, r25
    29ea:	30 93 3d 05 	sts	0x053D, r19
    29ee:	20 93 3c 05 	sts	0x053C, r18
    29f2:	82 e0       	ldi	r24, 0x02	; 2
    29f4:	90 e0       	ldi	r25, 0x00	; 0
    29f6:	0e 94 8a 0a 	call	0x1514	; 0x1514 <getdata>
    29fa:	28 2f       	mov	r18, r24
    29fc:	39 2f       	mov	r19, r25
    29fe:	30 93 3f 05 	sts	0x053F, r19
    2a02:	20 93 3e 05 	sts	0x053E, r18
    2a06:	83 e0       	ldi	r24, 0x03	; 3
    2a08:	90 e0       	ldi	r25, 0x00	; 0
    2a0a:	0e 94 8a 0a 	call	0x1514	; 0x1514 <getdata>
    2a0e:	28 2f       	mov	r18, r24
    2a10:	39 2f       	mov	r19, r25
    2a12:	30 93 41 05 	sts	0x0541, r19
    2a16:	20 93 40 05 	sts	0x0540, r18
	digital[11]=getdata(11);
    2a1a:	8b e0       	ldi	r24, 0x0B	; 11
    2a1c:	90 e0       	ldi	r25, 0x00	; 0
    2a1e:	0e 94 8a 0a 	call	0x1514	; 0x1514 <getdata>
    2a22:	28 2f       	mov	r18, r24
    2a24:	39 2f       	mov	r19, r25
    2a26:	30 93 51 05 	sts	0x0551, r19
    2a2a:	20 93 50 05 	sts	0x0550, r18
	if(node_number<10)
    2a2e:	80 91 5f 02 	lds	r24, 0x025F
    2a32:	90 91 60 02 	lds	r25, 0x0260
    2a36:	8a 30       	cpi	r24, 0x0A	; 10
    2a38:	91 05       	cpc	r25, r1
    2a3a:	24 f4       	brge	.+8      	; 0x2a44 <__vector_35+0x8c>
	Area='C';
    2a3c:	83 e4       	ldi	r24, 0x43	; 67
    2a3e:	80 93 56 02 	sts	0x0256, r24
    2a42:	03 c0       	rjmp	.+6      	; 0x2a4a <__vector_35+0x92>
	else
	Area='I';
    2a44:	89 e4       	ldi	r24, 0x49	; 73
    2a46:	80 93 56 02 	sts	0x0256, r24
}
    2a4a:	ff 91       	pop	r31
    2a4c:	ef 91       	pop	r30
    2a4e:	bf 91       	pop	r27
    2a50:	af 91       	pop	r26
    2a52:	9f 91       	pop	r25
    2a54:	8f 91       	pop	r24
    2a56:	7f 91       	pop	r23
    2a58:	6f 91       	pop	r22
    2a5a:	5f 91       	pop	r21
    2a5c:	4f 91       	pop	r20
    2a5e:	3f 91       	pop	r19
    2a60:	2f 91       	pop	r18
    2a62:	0f 90       	pop	r0
    2a64:	0b be       	out	0x3b, r0	; 59
    2a66:	0f 90       	pop	r0
    2a68:	0f be       	out	0x3f, r0	; 63
    2a6a:	0f 90       	pop	r0
    2a6c:	1f 90       	pop	r1
    2a6e:	18 95       	reti

00002a70 <line_following>:
*
*/

void line_following(void)
{
	if (digital[2]>60 || (digital[1]>15 && digital[2]>15))
    2a70:	80 91 3e 05 	lds	r24, 0x053E
    2a74:	90 91 3f 05 	lds	r25, 0x053F
    2a78:	8d 33       	cpi	r24, 0x3D	; 61
    2a7a:	91 05       	cpc	r25, r1
    2a7c:	70 f4       	brcc	.+28     	; 0x2a9a <line_following+0x2a>
    2a7e:	80 91 3c 05 	lds	r24, 0x053C
    2a82:	90 91 3d 05 	lds	r25, 0x053D
    2a86:	80 31       	cpi	r24, 0x10	; 16
    2a88:	91 05       	cpc	r25, r1
    2a8a:	60 f0       	brcs	.+24     	; 0x2aa4 <line_following+0x34>
    2a8c:	80 91 3e 05 	lds	r24, 0x053E
    2a90:	90 91 3f 05 	lds	r25, 0x053F
    2a94:	80 31       	cpi	r24, 0x10	; 16
    2a96:	91 05       	cpc	r25, r1
    2a98:	28 f0       	brcs	.+10     	; 0x2aa4 <line_following+0x34>
	{
		stop();
    2a9a:	0e 94 26 08 	call	0x104c	; 0x104c <stop>
		node_behave();
    2a9e:	0e 94 b6 0b 	call	0x176c	; 0x176c <node_behave>
*/

void line_following(void)
{
	if (digital[2]>60 || (digital[1]>15 && digital[2]>15))
	{
    2aa2:	08 95       	ret
		stop();
		node_behave();
	}
	else if(digital[2]>15 && (digital[1]>15 || digital[3]>15))
    2aa4:	80 91 3e 05 	lds	r24, 0x053E
    2aa8:	90 91 3f 05 	lds	r25, 0x053F
    2aac:	80 31       	cpi	r24, 0x10	; 16
    2aae:	91 05       	cpc	r25, r1
    2ab0:	98 f0       	brcs	.+38     	; 0x2ad8 <line_following+0x68>
    2ab2:	80 91 3c 05 	lds	r24, 0x053C
    2ab6:	90 91 3d 05 	lds	r25, 0x053D
    2aba:	80 31       	cpi	r24, 0x10	; 16
    2abc:	91 05       	cpc	r25, r1
    2abe:	38 f4       	brcc	.+14     	; 0x2ace <line_following+0x5e>
    2ac0:	80 91 40 05 	lds	r24, 0x0540
    2ac4:	90 91 41 05 	lds	r25, 0x0541
    2ac8:	80 31       	cpi	r24, 0x10	; 16
    2aca:	91 05       	cpc	r25, r1
    2acc:	28 f0       	brcs	.+10     	; 0x2ad8 <line_following+0x68>
	{	stop();
    2ace:	0e 94 26 08 	call	0x104c	; 0x104c <stop>
		node_behave();
    2ad2:	0e 94 b6 0b 	call	0x176c	; 0x176c <node_behave>
	{
		stop();
		node_behave();
	}
	else if(digital[2]>15 && (digital[1]>15 || digital[3]>15))
	{	stop();
    2ad6:	08 95       	ret
		node_behave();
	}
	else if(digital[1]>15 && digital[3]<15)
    2ad8:	80 91 3c 05 	lds	r24, 0x053C
    2adc:	90 91 3d 05 	lds	r25, 0x053D
    2ae0:	80 31       	cpi	r24, 0x10	; 16
    2ae2:	91 05       	cpc	r25, r1
    2ae4:	80 f0       	brcs	.+32     	; 0x2b06 <line_following+0x96>
    2ae6:	80 91 40 05 	lds	r24, 0x0540
    2aea:	90 91 41 05 	lds	r25, 0x0541
    2aee:	8f 30       	cpi	r24, 0x0F	; 15
    2af0:	91 05       	cpc	r25, r1
    2af2:	48 f4       	brcc	.+18     	; 0x2b06 <line_following+0x96>
	{
		sppeed(180,174);
    2af4:	84 eb       	ldi	r24, 0xB4	; 180
    2af6:	90 e0       	ldi	r25, 0x00	; 0
    2af8:	6e ea       	ldi	r22, 0xAE	; 174
    2afa:	70 e0       	ldi	r23, 0x00	; 0
    2afc:	0e 94 f7 00 	call	0x1ee	; 0x1ee <sppeed>
		right();
    2b00:	0e 94 2e 08 	call	0x105c	; 0x105c <right>
    2b04:	08 95       	ret
	}
	else if(digital[1]<15 && digital[3]>15)
    2b06:	80 91 3c 05 	lds	r24, 0x053C
    2b0a:	90 91 3d 05 	lds	r25, 0x053D
    2b0e:	8f 30       	cpi	r24, 0x0F	; 15
    2b10:	91 05       	cpc	r25, r1
    2b12:	80 f4       	brcc	.+32     	; 0x2b34 <line_following+0xc4>
    2b14:	80 91 40 05 	lds	r24, 0x0540
    2b18:	90 91 41 05 	lds	r25, 0x0541
    2b1c:	80 31       	cpi	r24, 0x10	; 16
    2b1e:	91 05       	cpc	r25, r1
    2b20:	48 f0       	brcs	.+18     	; 0x2b34 <line_following+0xc4>
	{
		sppeed(180,174);
    2b22:	84 eb       	ldi	r24, 0xB4	; 180
    2b24:	90 e0       	ldi	r25, 0x00	; 0
    2b26:	6e ea       	ldi	r22, 0xAE	; 174
    2b28:	70 e0       	ldi	r23, 0x00	; 0
    2b2a:	0e 94 f7 00 	call	0x1ee	; 0x1ee <sppeed>
		left();
    2b2e:	0e 94 2a 08 	call	0x1054	; 0x1054 <left>
    2b32:	08 95       	ret
	}
	else
	{
		sppeed(255,249);
    2b34:	8f ef       	ldi	r24, 0xFF	; 255
    2b36:	90 e0       	ldi	r25, 0x00	; 0
    2b38:	69 ef       	ldi	r22, 0xF9	; 249
    2b3a:	70 e0       	ldi	r23, 0x00	; 0
    2b3c:	0e 94 f7 00 	call	0x1ee	; 0x1ee <sppeed>
		motion('f');
    2b40:	86 e6       	ldi	r24, 0x66	; 102
    2b42:	0e 94 61 07 	call	0xec2	; 0xec2 <motion>
    2b46:	08 95       	ret

00002b48 <color_sensor_pin_config>:
*
*/

void color_sensor_pin_config(void)
{
	DDRD  = DDRD | 0xFE; //set PD0 as input for color sensor output
    2b48:	8a b1       	in	r24, 0x0a	; 10
    2b4a:	8e 6f       	ori	r24, 0xFE	; 254
    2b4c:	8a b9       	out	0x0a, r24	; 10
	PORTD = PORTD | 0x01;//Enable internal pull-up for PORTD 0 pin
    2b4e:	58 9a       	sbi	0x0b, 0	; 11
}
    2b50:	08 95       	ret

00002b52 <clrport_init>:
*
*/

void clrport_init(void)
{
	color_sensor_pin_config();//color sensor pin configuration
    2b52:	0e 94 a4 15 	call	0x2b48	; 0x2b48 <color_sensor_pin_config>
}
    2b56:	08 95       	ret

00002b58 <color_sensor_pin_interrupt_init>:
*
*/

void color_sensor_pin_interrupt_init(void) //Interrupt 0 enable
{
	cli(); //Clears the global interrupt
    2b58:	f8 94       	cli
	EICRA = EICRA | 0x02; // INT0 is set to trigger with falling edge
    2b5a:	e9 e6       	ldi	r30, 0x69	; 105
    2b5c:	f0 e0       	ldi	r31, 0x00	; 0
    2b5e:	80 81       	ld	r24, Z
    2b60:	82 60       	ori	r24, 0x02	; 2
    2b62:	80 83       	st	Z, r24
	EIMSK = EIMSK | 0x01; // Enable Interrupt INT0 for color sensor
    2b64:	e8 9a       	sbi	0x1d, 0	; 29
	sei(); // Enables the global interrupt
    2b66:	78 94       	sei
}
    2b68:	08 95       	ret

00002b6a <__vector_1>:
*
*/

//ISR for color sensor
ISR(INT0_vect)
{
    2b6a:	1f 92       	push	r1
    2b6c:	0f 92       	push	r0
    2b6e:	0f b6       	in	r0, 0x3f	; 63
    2b70:	0f 92       	push	r0
    2b72:	11 24       	eor	r1, r1
    2b74:	8f 93       	push	r24
    2b76:	9f 93       	push	r25
    2b78:	af 93       	push	r26
    2b7a:	bf 93       	push	r27
	pulse++; //increment on receiving pulse from the color sensor
    2b7c:	80 91 4e 02 	lds	r24, 0x024E
    2b80:	90 91 4f 02 	lds	r25, 0x024F
    2b84:	a0 91 50 02 	lds	r26, 0x0250
    2b88:	b0 91 51 02 	lds	r27, 0x0251
    2b8c:	01 96       	adiw	r24, 0x01	; 1
    2b8e:	a1 1d       	adc	r26, r1
    2b90:	b1 1d       	adc	r27, r1
    2b92:	80 93 4e 02 	sts	0x024E, r24
    2b96:	90 93 4f 02 	sts	0x024F, r25
    2b9a:	a0 93 50 02 	sts	0x0250, r26
    2b9e:	b0 93 51 02 	sts	0x0251, r27
}
    2ba2:	bf 91       	pop	r27
    2ba4:	af 91       	pop	r26
    2ba6:	9f 91       	pop	r25
    2ba8:	8f 91       	pop	r24
    2baa:	0f 90       	pop	r0
    2bac:	0f be       	out	0x3f, r0	; 63
    2bae:	0f 90       	pop	r0
    2bb0:	1f 90       	pop	r1
    2bb2:	18 95       	reti

00002bb4 <init_devices>:
*
*/

void init_devices(void)
{
	cli(); //Clears the global interrupt
    2bb4:	f8 94       	cli
	clrport_init();  //Initializes all the ports
    2bb6:	0e 94 a9 15 	call	0x2b52	; 0x2b52 <clrport_init>
	color_sensor_pin_interrupt_init();
    2bba:	0e 94 ac 15 	call	0x2b58	; 0x2b58 <color_sensor_pin_interrupt_init>
	sei();   // Enables the global interrupt
    2bbe:	78 94       	sei
}
    2bc0:	08 95       	ret

00002bc2 <filter_red>:

//Filter Selection
void filter_red(void)    //Used to select red filter
{
	//Filter Select - red filter
	PORTD = PORTD & 0xBF; //set S2 low
    2bc2:	5e 98       	cbi	0x0b, 6	; 11
	PORTD = PORTD & 0x7F; //set S3 low
    2bc4:	5f 98       	cbi	0x0b, 7	; 11
}
    2bc6:	08 95       	ret

00002bc8 <filter_green>:
*/

void filter_green(void)	//Used to select green filter
{
	//Filter Select - green filter
	PORTD = PORTD | 0x40; //set S2 High
    2bc8:	5e 9a       	sbi	0x0b, 6	; 11
	PORTD = PORTD | 0x80; //set S3 High
    2bca:	5f 9a       	sbi	0x0b, 7	; 11
}
    2bcc:	08 95       	ret

00002bce <filter_blue>:
*/

void filter_blue(void)	//Used to select blue filter
{
	//Filter Select - blue filter
	PORTD = PORTD & 0xBF; //set S2 low
    2bce:	5e 98       	cbi	0x0b, 6	; 11
	PORTD = PORTD | 0x80; //set S3 High
    2bd0:	5f 9a       	sbi	0x0b, 7	; 11
}
    2bd2:	08 95       	ret

00002bd4 <color_sensor_scaling>:
//Color Sensing Scaling
void color_sensor_scaling()		//This function is used to select the scaled down version of the original frequency of the output generated by the color sensor, generally 20% scaling is preferable, though you can change the values as per your application by referring datasheet
{
	//Output Scaling 20% from data sheet
	//PORTD = PORTD & 0xEF;
	PORTD = PORTD | 0x10; //set S0 high
    2bd4:	5c 9a       	sbi	0x0b, 4	; 11
	//PORTD = PORTD & 0xDF; //set S1 low
	PORTD = PORTD | 0x20; //set S1 high
    2bd6:	5d 9a       	sbi	0x0b, 5	; 11
}
    2bd8:	08 95       	ret

00002bda <red_read>:
*/

void red_read(void) // function to select red filter and display the count generated by the sensor on LCD. The count will be more if the color is red. The count will be very less if its blue or green.
{
	//Red
	filter_red(); //select red filter
    2bda:	0e 94 e1 15 	call	0x2bc2	; 0x2bc2 <filter_red>
	pulse=0; //reset the count to 0
    2bde:	10 92 4e 02 	sts	0x024E, r1
    2be2:	10 92 4f 02 	sts	0x024F, r1
    2be6:	10 92 50 02 	sts	0x0250, r1
    2bea:	10 92 51 02 	sts	0x0251, r1
    2bee:	8f ef       	ldi	r24, 0xFF	; 255
    2bf0:	9f e7       	ldi	r25, 0x7F	; 127
    2bf2:	a4 e0       	ldi	r26, 0x04	; 4
    2bf4:	81 50       	subi	r24, 0x01	; 1
    2bf6:	90 40       	sbci	r25, 0x00	; 0
    2bf8:	a0 40       	sbci	r26, 0x00	; 0
    2bfa:	e1 f7       	brne	.-8      	; 0x2bf4 <red_read+0x1a>
    2bfc:	00 c0       	rjmp	.+0      	; 0x2bfe <red_read+0x24>
    2bfe:	00 00       	nop
	_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	red = pulse;  //store the count in variable called red
    2c00:	80 91 4e 02 	lds	r24, 0x024E
    2c04:	90 91 4f 02 	lds	r25, 0x024F
    2c08:	a0 91 50 02 	lds	r26, 0x0250
    2c0c:	b0 91 51 02 	lds	r27, 0x0251
    2c10:	80 93 b8 02 	sts	0x02B8, r24
    2c14:	90 93 b9 02 	sts	0x02B9, r25
    2c18:	a0 93 ba 02 	sts	0x02BA, r26
    2c1c:	b0 93 bb 02 	sts	0x02BB, r27
}
    2c20:	08 95       	ret

00002c22 <green_read>:
*/

void green_read(void) // function to select green filter and display the count generated by the sensor on LCD. The count will be more if the color is green. The count will be very less if its blue or red.
{
	//Green
	filter_green(); //select green filter
    2c22:	0e 94 e4 15 	call	0x2bc8	; 0x2bc8 <filter_green>
	pulse=0; //reset the count to 0
    2c26:	10 92 4e 02 	sts	0x024E, r1
    2c2a:	10 92 4f 02 	sts	0x024F, r1
    2c2e:	10 92 50 02 	sts	0x0250, r1
    2c32:	10 92 51 02 	sts	0x0251, r1
    2c36:	8f ef       	ldi	r24, 0xFF	; 255
    2c38:	9f e7       	ldi	r25, 0x7F	; 127
    2c3a:	a4 e0       	ldi	r26, 0x04	; 4
    2c3c:	81 50       	subi	r24, 0x01	; 1
    2c3e:	90 40       	sbci	r25, 0x00	; 0
    2c40:	a0 40       	sbci	r26, 0x00	; 0
    2c42:	e1 f7       	brne	.-8      	; 0x2c3c <green_read+0x1a>
    2c44:	00 c0       	rjmp	.+0      	; 0x2c46 <green_read+0x24>
    2c46:	00 00       	nop
	_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	green = pulse;  //store the count in variable called green
    2c48:	80 91 4e 02 	lds	r24, 0x024E
    2c4c:	90 91 4f 02 	lds	r25, 0x024F
    2c50:	a0 91 50 02 	lds	r26, 0x0250
    2c54:	b0 91 51 02 	lds	r27, 0x0251
    2c58:	80 93 b3 02 	sts	0x02B3, r24
    2c5c:	90 93 b4 02 	sts	0x02B4, r25
    2c60:	a0 93 b5 02 	sts	0x02B5, r26
    2c64:	b0 93 b6 02 	sts	0x02B6, r27
}
    2c68:	08 95       	ret

00002c6a <blue_read>:
*/

void blue_read(void) // function to select blue filter and display the count generated by the sensor on LCD. The count will be more if the color is blue. The count will be very less if its red or green.
{
	//Blue
	filter_blue(); //select blue filter
    2c6a:	0e 94 e7 15 	call	0x2bce	; 0x2bce <filter_blue>
	pulse=0; //reset the count to 0
    2c6e:	10 92 4e 02 	sts	0x024E, r1
    2c72:	10 92 4f 02 	sts	0x024F, r1
    2c76:	10 92 50 02 	sts	0x0250, r1
    2c7a:	10 92 51 02 	sts	0x0251, r1
    2c7e:	8f ef       	ldi	r24, 0xFF	; 255
    2c80:	9f e7       	ldi	r25, 0x7F	; 127
    2c82:	a4 e0       	ldi	r26, 0x04	; 4
    2c84:	81 50       	subi	r24, 0x01	; 1
    2c86:	90 40       	sbci	r25, 0x00	; 0
    2c88:	a0 40       	sbci	r26, 0x00	; 0
    2c8a:	e1 f7       	brne	.-8      	; 0x2c84 <blue_read+0x1a>
    2c8c:	00 c0       	rjmp	.+0      	; 0x2c8e <blue_read+0x24>
    2c8e:	00 00       	nop
	_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	blue = pulse;  //store the count in variable called blue
    2c90:	80 91 4e 02 	lds	r24, 0x024E
    2c94:	90 91 4f 02 	lds	r25, 0x024F
    2c98:	a0 91 50 02 	lds	r26, 0x0250
    2c9c:	b0 91 51 02 	lds	r27, 0x0251
    2ca0:	80 93 a7 02 	sts	0x02A7, r24
    2ca4:	90 93 a8 02 	sts	0x02A8, r25
    2ca8:	a0 93 a9 02 	sts	0x02A9, r26
    2cac:	b0 93 aa 02 	sts	0x02AA, r27

}
    2cb0:	08 95       	ret

00002cb2 <color_sensor>:
*
*/

void color_sensor(void)
{
	red_read();
    2cb2:	0e 94 ed 15 	call	0x2bda	; 0x2bda <red_read>
	blue_read();
    2cb6:	0e 94 35 16 	call	0x2c6a	; 0x2c6a <blue_read>
	green_read();
    2cba:	0e 94 11 16 	call	0x2c22	; 0x2c22 <green_read>
	if(red<threshold_color_value && blue<threshold_color_value && green<threshold_color_value)
    2cbe:	80 91 b8 02 	lds	r24, 0x02B8
    2cc2:	90 91 b9 02 	lds	r25, 0x02B9
    2cc6:	a0 91 ba 02 	lds	r26, 0x02BA
    2cca:	b0 91 bb 02 	lds	r27, 0x02BB
    2cce:	84 31       	cpi	r24, 0x14	; 20
    2cd0:	25 e0       	ldi	r18, 0x05	; 5
    2cd2:	92 07       	cpc	r25, r18
    2cd4:	20 e0       	ldi	r18, 0x00	; 0
    2cd6:	a2 07       	cpc	r26, r18
    2cd8:	20 e0       	ldi	r18, 0x00	; 0
    2cda:	b2 07       	cpc	r27, r18
    2cdc:	18 f5       	brcc	.+70     	; 0x2d24 <color_sensor+0x72>
    2cde:	80 91 a7 02 	lds	r24, 0x02A7
    2ce2:	90 91 a8 02 	lds	r25, 0x02A8
    2ce6:	a0 91 a9 02 	lds	r26, 0x02A9
    2cea:	b0 91 aa 02 	lds	r27, 0x02AA
    2cee:	84 31       	cpi	r24, 0x14	; 20
    2cf0:	25 e0       	ldi	r18, 0x05	; 5
    2cf2:	92 07       	cpc	r25, r18
    2cf4:	20 e0       	ldi	r18, 0x00	; 0
    2cf6:	a2 07       	cpc	r26, r18
    2cf8:	20 e0       	ldi	r18, 0x00	; 0
    2cfa:	b2 07       	cpc	r27, r18
    2cfc:	98 f4       	brcc	.+38     	; 0x2d24 <color_sensor+0x72>
    2cfe:	80 91 b3 02 	lds	r24, 0x02B3
    2d02:	90 91 b4 02 	lds	r25, 0x02B4
    2d06:	a0 91 b5 02 	lds	r26, 0x02B5
    2d0a:	b0 91 b6 02 	lds	r27, 0x02B6
    2d0e:	84 31       	cpi	r24, 0x14	; 20
    2d10:	25 e0       	ldi	r18, 0x05	; 5
    2d12:	92 07       	cpc	r25, r18
    2d14:	20 e0       	ldi	r18, 0x00	; 0
    2d16:	a2 07       	cpc	r26, r18
    2d18:	20 e0       	ldi	r18, 0x00	; 0
    2d1a:	b2 07       	cpc	r27, r18
    2d1c:	18 f4       	brcc	.+6      	; 0x2d24 <color_sensor+0x72>
	color_identified='\0';
    2d1e:	10 92 54 02 	sts	0x0254, r1
    2d22:	89 c0       	rjmp	.+274    	; 0x2e36 <color_sensor+0x184>
	else
	{
		if(red>blue && red>green)
    2d24:	40 91 b8 02 	lds	r20, 0x02B8
    2d28:	50 91 b9 02 	lds	r21, 0x02B9
    2d2c:	60 91 ba 02 	lds	r22, 0x02BA
    2d30:	70 91 bb 02 	lds	r23, 0x02BB
    2d34:	80 91 a7 02 	lds	r24, 0x02A7
    2d38:	90 91 a8 02 	lds	r25, 0x02A8
    2d3c:	a0 91 a9 02 	lds	r26, 0x02A9
    2d40:	b0 91 aa 02 	lds	r27, 0x02AA
    2d44:	84 17       	cp	r24, r20
    2d46:	95 07       	cpc	r25, r21
    2d48:	a6 07       	cpc	r26, r22
    2d4a:	b7 07       	cpc	r27, r23
    2d4c:	c8 f4       	brcc	.+50     	; 0x2d80 <color_sensor+0xce>
    2d4e:	40 91 b8 02 	lds	r20, 0x02B8
    2d52:	50 91 b9 02 	lds	r21, 0x02B9
    2d56:	60 91 ba 02 	lds	r22, 0x02BA
    2d5a:	70 91 bb 02 	lds	r23, 0x02BB
    2d5e:	80 91 b3 02 	lds	r24, 0x02B3
    2d62:	90 91 b4 02 	lds	r25, 0x02B4
    2d66:	a0 91 b5 02 	lds	r26, 0x02B5
    2d6a:	b0 91 b6 02 	lds	r27, 0x02B6
    2d6e:	84 17       	cp	r24, r20
    2d70:	95 07       	cpc	r25, r21
    2d72:	a6 07       	cpc	r26, r22
    2d74:	b7 07       	cpc	r27, r23
    2d76:	20 f4       	brcc	.+8      	; 0x2d80 <color_sensor+0xce>
		color_identified='R';
    2d78:	82 e5       	ldi	r24, 0x52	; 82
    2d7a:	80 93 54 02 	sts	0x0254, r24
    2d7e:	5b c0       	rjmp	.+182    	; 0x2e36 <color_sensor+0x184>
		else if(blue>red && blue>green)
    2d80:	40 91 a7 02 	lds	r20, 0x02A7
    2d84:	50 91 a8 02 	lds	r21, 0x02A8
    2d88:	60 91 a9 02 	lds	r22, 0x02A9
    2d8c:	70 91 aa 02 	lds	r23, 0x02AA
    2d90:	80 91 b8 02 	lds	r24, 0x02B8
    2d94:	90 91 b9 02 	lds	r25, 0x02B9
    2d98:	a0 91 ba 02 	lds	r26, 0x02BA
    2d9c:	b0 91 bb 02 	lds	r27, 0x02BB
    2da0:	84 17       	cp	r24, r20
    2da2:	95 07       	cpc	r25, r21
    2da4:	a6 07       	cpc	r26, r22
    2da6:	b7 07       	cpc	r27, r23
    2da8:	c8 f4       	brcc	.+50     	; 0x2ddc <color_sensor+0x12a>
    2daa:	40 91 a7 02 	lds	r20, 0x02A7
    2dae:	50 91 a8 02 	lds	r21, 0x02A8
    2db2:	60 91 a9 02 	lds	r22, 0x02A9
    2db6:	70 91 aa 02 	lds	r23, 0x02AA
    2dba:	80 91 b3 02 	lds	r24, 0x02B3
    2dbe:	90 91 b4 02 	lds	r25, 0x02B4
    2dc2:	a0 91 b5 02 	lds	r26, 0x02B5
    2dc6:	b0 91 b6 02 	lds	r27, 0x02B6
    2dca:	84 17       	cp	r24, r20
    2dcc:	95 07       	cpc	r25, r21
    2dce:	a6 07       	cpc	r26, r22
    2dd0:	b7 07       	cpc	r27, r23
    2dd2:	20 f4       	brcc	.+8      	; 0x2ddc <color_sensor+0x12a>
		color_identified='B';
    2dd4:	82 e4       	ldi	r24, 0x42	; 66
    2dd6:	80 93 54 02 	sts	0x0254, r24
    2dda:	2d c0       	rjmp	.+90     	; 0x2e36 <color_sensor+0x184>
		else if(green>red && green>blue)
    2ddc:	40 91 b3 02 	lds	r20, 0x02B3
    2de0:	50 91 b4 02 	lds	r21, 0x02B4
    2de4:	60 91 b5 02 	lds	r22, 0x02B5
    2de8:	70 91 b6 02 	lds	r23, 0x02B6
    2dec:	80 91 b8 02 	lds	r24, 0x02B8
    2df0:	90 91 b9 02 	lds	r25, 0x02B9
    2df4:	a0 91 ba 02 	lds	r26, 0x02BA
    2df8:	b0 91 bb 02 	lds	r27, 0x02BB
    2dfc:	84 17       	cp	r24, r20
    2dfe:	95 07       	cpc	r25, r21
    2e00:	a6 07       	cpc	r26, r22
    2e02:	b7 07       	cpc	r27, r23
    2e04:	c0 f4       	brcc	.+48     	; 0x2e36 <color_sensor+0x184>
    2e06:	40 91 b3 02 	lds	r20, 0x02B3
    2e0a:	50 91 b4 02 	lds	r21, 0x02B4
    2e0e:	60 91 b5 02 	lds	r22, 0x02B5
    2e12:	70 91 b6 02 	lds	r23, 0x02B6
    2e16:	80 91 a7 02 	lds	r24, 0x02A7
    2e1a:	90 91 a8 02 	lds	r25, 0x02A8
    2e1e:	a0 91 a9 02 	lds	r26, 0x02A9
    2e22:	b0 91 aa 02 	lds	r27, 0x02AA
    2e26:	84 17       	cp	r24, r20
    2e28:	95 07       	cpc	r25, r21
    2e2a:	a6 07       	cpc	r26, r22
    2e2c:	b7 07       	cpc	r27, r23
    2e2e:	18 f4       	brcc	.+6      	; 0x2e36 <color_sensor+0x184>
		color_identified='G';
    2e30:	87 e4       	ldi	r24, 0x47	; 71
    2e32:	80 93 54 02 	sts	0x0254, r24
	}
	lcd_cursor(2,10);
    2e36:	82 e0       	ldi	r24, 0x02	; 2
    2e38:	6a e0       	ldi	r22, 0x0A	; 10
    2e3a:	0e 94 be 03 	call	0x77c	; 0x77c <lcd_cursor>
	lcd_wr_char(color_identified);
    2e3e:	80 91 54 02 	lds	r24, 0x0254
    2e42:	0e 94 86 03 	call	0x70c	; 0x70c <lcd_wr_char>
}
    2e46:	08 95       	ret

00002e48 <main>:
*
*/

int main(void)
{
	struct_config();
    2e48:	0e 94 18 05 	call	0xa30	; 0xa30 <struct_config>
	lcd_port_config();
    2e4c:	0e 94 58 07 	call	0xeb0	; 0xeb0 <lcd_port_config>
	lcd_init();
    2e50:	0e 94 6f 03 	call	0x6de	; 0x6de <lcd_init>
	INT_position();
    2e54:	0e 94 ab 09 	call	0x1356	; 0x1356 <INT_position>
	sppeed_config();
    2e58:	0e 94 7a 07 	call	0xef4	; 0xef4 <sppeed_config>
	servo_config();
    2e5c:	0e 94 ba 09 	call	0x1374	; 0x1374 <servo_config>
	ADC_config();
    2e60:	0e 94 6c 0a 	call	0x14d8	; 0x14d8 <ADC_config>
	init_devices();
    2e64:	0e 94 da 15 	call	0x2bb4	; 0x2bb4 <init_devices>
	_start_collection();//for state collection
    2e68:	0e 94 f9 02 	call	0x5f2	; 0x5f2 <_start_collection>
	color_sensor_scaling();
    2e6c:	0e 94 ea 15 	call	0x2bd4	; 0x2bd4 <color_sensor_scaling>
	navigate();			//navigate the bot at starting
    2e70:	0e 94 6b 04 	call	0x8d6	; 0x8d6 <navigate>
	servo1_mov(80);		//move arm to its initial position
    2e74:	80 e5       	ldi	r24, 0x50	; 80
    2e76:	90 e0       	ldi	r25, 0x00	; 0
    2e78:	0e 94 df 09 	call	0x13be	; 0x13be <servo1_mov>
    2e7c:	8f ef       	ldi	r24, 0xFF	; 255
    2e7e:	9f e7       	ldi	r25, 0x7F	; 127
    2e80:	a6 e1       	ldi	r26, 0x16	; 22
    2e82:	81 50       	subi	r24, 0x01	; 1
    2e84:	90 40       	sbci	r25, 0x00	; 0
    2e86:	a0 40       	sbci	r26, 0x00	; 0
    2e88:	e1 f7       	brne	.-8      	; 0x2e82 <main+0x3a>
    2e8a:	00 c0       	rjmp	.+0      	; 0x2e8c <main+0x44>
    2e8c:	00 00       	nop
	_delay_ms(500);
	servo2_mov(45);
    2e8e:	8d e2       	ldi	r24, 0x2D	; 45
    2e90:	90 e0       	ldi	r25, 0x00	; 0
    2e92:	0e 94 29 0a 	call	0x1452	; 0x1452 <servo2_mov>
    2e96:	8f ef       	ldi	r24, 0xFF	; 255
    2e98:	9f e7       	ldi	r25, 0x7F	; 127
    2e9a:	a6 e1       	ldi	r26, 0x16	; 22
    2e9c:	81 50       	subi	r24, 0x01	; 1
    2e9e:	90 40       	sbci	r25, 0x00	; 0
    2ea0:	a0 40       	sbci	r26, 0x00	; 0
    2ea2:	e1 f7       	brne	.-8      	; 0x2e9c <main+0x54>
    2ea4:	00 c0       	rjmp	.+0      	; 0x2ea6 <main+0x5e>
    2ea6:	00 00       	nop
	_delay_ms(500);
	servo2_free();
    2ea8:	0e 94 57 0a 	call	0x14ae	; 0x14ae <servo2_free>
	enqueue(6);     // main 6 tasks of the bot
    2eac:	86 e0       	ldi	r24, 0x06	; 6
    2eae:	90 e0       	ldi	r25, 0x00	; 0
    2eb0:	0e 94 02 01 	call	0x204	; 0x204 <enqueue>
	enqueue(0);
    2eb4:	80 e0       	ldi	r24, 0x00	; 0
    2eb6:	90 e0       	ldi	r25, 0x00	; 0
    2eb8:	0e 94 02 01 	call	0x204	; 0x204 <enqueue>
	enqueue(6);
    2ebc:	86 e0       	ldi	r24, 0x06	; 6
    2ebe:	90 e0       	ldi	r25, 0x00	; 0
    2ec0:	0e 94 02 01 	call	0x204	; 0x204 <enqueue>
	enqueue(0);
    2ec4:	80 e0       	ldi	r24, 0x00	; 0
    2ec6:	90 e0       	ldi	r25, 0x00	; 0
    2ec8:	0e 94 02 01 	call	0x204	; 0x204 <enqueue>
	enqueue(6);
    2ecc:	86 e0       	ldi	r24, 0x06	; 6
    2ece:	90 e0       	ldi	r25, 0x00	; 0
    2ed0:	0e 94 02 01 	call	0x204	; 0x204 <enqueue>
	_start_collection();/********************initialization of state collection program***************/
    2ed4:	0e 94 f9 02 	call	0x5f2	; 0x5f2 <_start_collection>
	while(1)				// Bot is instructed to follow line continuously 
	{
		line_following();
    2ed8:	0e 94 38 15 	call	0x2a70	; 0x2a70 <line_following>
		if(deposition_zone_A+deposition_zone_B+deposition_zone_C==0)		// When all the three wastes are deposited at the deposition zone the bot																	  
    2edc:	80 91 3b 02 	lds	r24, 0x023B
    2ee0:	90 91 3c 02 	lds	r25, 0x023C
    2ee4:	20 91 39 02 	lds	r18, 0x0239
    2ee8:	30 91 3a 02 	lds	r19, 0x023A
    2eec:	82 0f       	add	r24, r18
    2eee:	93 1f       	adc	r25, r19
    2ef0:	20 91 37 02 	lds	r18, 0x0237
    2ef4:	30 91 38 02 	lds	r19, 0x0238
    2ef8:	82 0f       	add	r24, r18
    2efa:	93 1f       	adc	r25, r19
    2efc:	00 97       	sbiw	r24, 0x00	; 0
    2efe:	61 f7       	brne	.-40     	; 0x2ed8 <main+0x90>
		{																	// will beep the buzzer for 5 sec and then exits from the program.
			buzzer(1);
    2f00:	81 e0       	ldi	r24, 0x01	; 1
    2f02:	90 e0       	ldi	r25, 0x00	; 0
    2f04:	0e 94 4d 07 	call	0xe9a	; 0xe9a <buzzer>
    2f08:	8f ef       	ldi	r24, 0xFF	; 255
    2f0a:	9f ef       	ldi	r25, 0xFF	; 255
    2f0c:	a0 ee       	ldi	r26, 0xE0	; 224
    2f0e:	81 50       	subi	r24, 0x01	; 1
    2f10:	90 40       	sbci	r25, 0x00	; 0
    2f12:	a0 40       	sbci	r26, 0x00	; 0
    2f14:	e1 f7       	brne	.-8      	; 0x2f0e <main+0xc6>
    2f16:	00 c0       	rjmp	.+0      	; 0x2f18 <main+0xd0>
    2f18:	00 00       	nop
			_delay_ms(5000);
			buzzer(0);
    2f1a:	80 e0       	ldi	r24, 0x00	; 0
    2f1c:	90 e0       	ldi	r25, 0x00	; 0
    2f1e:	0e 94 4d 07 	call	0xe9a	; 0xe9a <buzzer>
    2f22:	8f ef       	ldi	r24, 0xFF	; 255
    2f24:	9f e7       	ldi	r25, 0x7F	; 127
    2f26:	a6 e1       	ldi	r26, 0x16	; 22
    2f28:	81 50       	subi	r24, 0x01	; 1
    2f2a:	90 40       	sbci	r25, 0x00	; 0
    2f2c:	a0 40       	sbci	r26, 0x00	; 0
    2f2e:	e1 f7       	brne	.-8      	; 0x2f28 <main+0xe0>
    2f30:	00 c0       	rjmp	.+0      	; 0x2f32 <main+0xea>
    2f32:	00 00       	nop
			_delay_ms(500);
			break;
		}
	}
}
    2f34:	80 e0       	ldi	r24, 0x00	; 0
    2f36:	90 e0       	ldi	r25, 0x00	; 0
    2f38:	08 95       	ret

00002f3a <__subsf3>:
    2f3a:	50 58       	subi	r21, 0x80	; 128

00002f3c <__addsf3>:
    2f3c:	bb 27       	eor	r27, r27
    2f3e:	aa 27       	eor	r26, r26
    2f40:	0e d0       	rcall	.+28     	; 0x2f5e <__addsf3x>
    2f42:	b1 c1       	rjmp	.+866    	; 0x32a6 <__fp_round>
    2f44:	a2 d1       	rcall	.+836    	; 0x328a <__fp_pscA>
    2f46:	30 f0       	brcs	.+12     	; 0x2f54 <__addsf3+0x18>
    2f48:	a7 d1       	rcall	.+846    	; 0x3298 <__fp_pscB>
    2f4a:	20 f0       	brcs	.+8      	; 0x2f54 <__addsf3+0x18>
    2f4c:	31 f4       	brne	.+12     	; 0x2f5a <__addsf3+0x1e>
    2f4e:	9f 3f       	cpi	r25, 0xFF	; 255
    2f50:	11 f4       	brne	.+4      	; 0x2f56 <__addsf3+0x1a>
    2f52:	1e f4       	brtc	.+6      	; 0x2f5a <__addsf3+0x1e>
    2f54:	97 c1       	rjmp	.+814    	; 0x3284 <__fp_nan>
    2f56:	0e f4       	brtc	.+2      	; 0x2f5a <__addsf3+0x1e>
    2f58:	e0 95       	com	r30
    2f5a:	e7 fb       	bst	r30, 7
    2f5c:	64 c1       	rjmp	.+712    	; 0x3226 <__fp_inf>

00002f5e <__addsf3x>:
    2f5e:	e9 2f       	mov	r30, r25
    2f60:	b3 d1       	rcall	.+870    	; 0x32c8 <__fp_split3>
    2f62:	80 f3       	brcs	.-32     	; 0x2f44 <__addsf3+0x8>
    2f64:	ba 17       	cp	r27, r26
    2f66:	62 07       	cpc	r22, r18
    2f68:	73 07       	cpc	r23, r19
    2f6a:	84 07       	cpc	r24, r20
    2f6c:	95 07       	cpc	r25, r21
    2f6e:	18 f0       	brcs	.+6      	; 0x2f76 <__addsf3x+0x18>
    2f70:	71 f4       	brne	.+28     	; 0x2f8e <__addsf3x+0x30>
    2f72:	9e f5       	brtc	.+102    	; 0x2fda <__addsf3x+0x7c>
    2f74:	e2 c1       	rjmp	.+964    	; 0x333a <__fp_zero>
    2f76:	0e f4       	brtc	.+2      	; 0x2f7a <__addsf3x+0x1c>
    2f78:	e0 95       	com	r30
    2f7a:	0b 2e       	mov	r0, r27
    2f7c:	ba 2f       	mov	r27, r26
    2f7e:	a0 2d       	mov	r26, r0
    2f80:	0b 01       	movw	r0, r22
    2f82:	b9 01       	movw	r22, r18
    2f84:	90 01       	movw	r18, r0
    2f86:	0c 01       	movw	r0, r24
    2f88:	ca 01       	movw	r24, r20
    2f8a:	a0 01       	movw	r20, r0
    2f8c:	11 24       	eor	r1, r1
    2f8e:	ff 27       	eor	r31, r31
    2f90:	59 1b       	sub	r21, r25
    2f92:	99 f0       	breq	.+38     	; 0x2fba <__addsf3x+0x5c>
    2f94:	59 3f       	cpi	r21, 0xF9	; 249
    2f96:	50 f4       	brcc	.+20     	; 0x2fac <__addsf3x+0x4e>
    2f98:	50 3e       	cpi	r21, 0xE0	; 224
    2f9a:	68 f1       	brcs	.+90     	; 0x2ff6 <__addsf3x+0x98>
    2f9c:	1a 16       	cp	r1, r26
    2f9e:	f0 40       	sbci	r31, 0x00	; 0
    2fa0:	a2 2f       	mov	r26, r18
    2fa2:	23 2f       	mov	r18, r19
    2fa4:	34 2f       	mov	r19, r20
    2fa6:	44 27       	eor	r20, r20
    2fa8:	58 5f       	subi	r21, 0xF8	; 248
    2faa:	f3 cf       	rjmp	.-26     	; 0x2f92 <__addsf3x+0x34>
    2fac:	46 95       	lsr	r20
    2fae:	37 95       	ror	r19
    2fb0:	27 95       	ror	r18
    2fb2:	a7 95       	ror	r26
    2fb4:	f0 40       	sbci	r31, 0x00	; 0
    2fb6:	53 95       	inc	r21
    2fb8:	c9 f7       	brne	.-14     	; 0x2fac <__addsf3x+0x4e>
    2fba:	7e f4       	brtc	.+30     	; 0x2fda <__addsf3x+0x7c>
    2fbc:	1f 16       	cp	r1, r31
    2fbe:	ba 0b       	sbc	r27, r26
    2fc0:	62 0b       	sbc	r22, r18
    2fc2:	73 0b       	sbc	r23, r19
    2fc4:	84 0b       	sbc	r24, r20
    2fc6:	ba f0       	brmi	.+46     	; 0x2ff6 <__addsf3x+0x98>
    2fc8:	91 50       	subi	r25, 0x01	; 1
    2fca:	a1 f0       	breq	.+40     	; 0x2ff4 <__addsf3x+0x96>
    2fcc:	ff 0f       	add	r31, r31
    2fce:	bb 1f       	adc	r27, r27
    2fd0:	66 1f       	adc	r22, r22
    2fd2:	77 1f       	adc	r23, r23
    2fd4:	88 1f       	adc	r24, r24
    2fd6:	c2 f7       	brpl	.-16     	; 0x2fc8 <__addsf3x+0x6a>
    2fd8:	0e c0       	rjmp	.+28     	; 0x2ff6 <__addsf3x+0x98>
    2fda:	ba 0f       	add	r27, r26
    2fdc:	62 1f       	adc	r22, r18
    2fde:	73 1f       	adc	r23, r19
    2fe0:	84 1f       	adc	r24, r20
    2fe2:	48 f4       	brcc	.+18     	; 0x2ff6 <__addsf3x+0x98>
    2fe4:	87 95       	ror	r24
    2fe6:	77 95       	ror	r23
    2fe8:	67 95       	ror	r22
    2fea:	b7 95       	ror	r27
    2fec:	f7 95       	ror	r31
    2fee:	9e 3f       	cpi	r25, 0xFE	; 254
    2ff0:	08 f0       	brcs	.+2      	; 0x2ff4 <__addsf3x+0x96>
    2ff2:	b3 cf       	rjmp	.-154    	; 0x2f5a <__addsf3+0x1e>
    2ff4:	93 95       	inc	r25
    2ff6:	88 0f       	add	r24, r24
    2ff8:	08 f0       	brcs	.+2      	; 0x2ffc <__addsf3x+0x9e>
    2ffa:	99 27       	eor	r25, r25
    2ffc:	ee 0f       	add	r30, r30
    2ffe:	97 95       	ror	r25
    3000:	87 95       	ror	r24
    3002:	08 95       	ret

00003004 <ceil>:
    3004:	83 d1       	rcall	.+774    	; 0x330c <__fp_trunc>
    3006:	80 f0       	brcs	.+32     	; 0x3028 <ceil+0x24>
    3008:	9f 37       	cpi	r25, 0x7F	; 127
    300a:	40 f4       	brcc	.+16     	; 0x301c <ceil+0x18>
    300c:	91 11       	cpse	r25, r1
    300e:	0e f4       	brtc	.+2      	; 0x3012 <ceil+0xe>
    3010:	95 c1       	rjmp	.+810    	; 0x333c <__fp_szero>
    3012:	60 e0       	ldi	r22, 0x00	; 0
    3014:	70 e0       	ldi	r23, 0x00	; 0
    3016:	80 e8       	ldi	r24, 0x80	; 128
    3018:	9f e3       	ldi	r25, 0x3F	; 63
    301a:	08 95       	ret
    301c:	26 f0       	brts	.+8      	; 0x3026 <ceil+0x22>
    301e:	1b 16       	cp	r1, r27
    3020:	61 1d       	adc	r22, r1
    3022:	71 1d       	adc	r23, r1
    3024:	81 1d       	adc	r24, r1
    3026:	05 c1       	rjmp	.+522    	; 0x3232 <__fp_mintl>
    3028:	1f c1       	rjmp	.+574    	; 0x3268 <__fp_mpack>

0000302a <__cmpsf2>:
    302a:	d9 d0       	rcall	.+434    	; 0x31de <__fp_cmp>
    302c:	08 f4       	brcc	.+2      	; 0x3030 <__cmpsf2+0x6>
    302e:	81 e0       	ldi	r24, 0x01	; 1
    3030:	08 95       	ret

00003032 <__divsf3>:
    3032:	0c d0       	rcall	.+24     	; 0x304c <__divsf3x>
    3034:	38 c1       	rjmp	.+624    	; 0x32a6 <__fp_round>
    3036:	30 d1       	rcall	.+608    	; 0x3298 <__fp_pscB>
    3038:	40 f0       	brcs	.+16     	; 0x304a <__divsf3+0x18>
    303a:	27 d1       	rcall	.+590    	; 0x328a <__fp_pscA>
    303c:	30 f0       	brcs	.+12     	; 0x304a <__divsf3+0x18>
    303e:	21 f4       	brne	.+8      	; 0x3048 <__divsf3+0x16>
    3040:	5f 3f       	cpi	r21, 0xFF	; 255
    3042:	19 f0       	breq	.+6      	; 0x304a <__divsf3+0x18>
    3044:	f0 c0       	rjmp	.+480    	; 0x3226 <__fp_inf>
    3046:	51 11       	cpse	r21, r1
    3048:	79 c1       	rjmp	.+754    	; 0x333c <__fp_szero>
    304a:	1c c1       	rjmp	.+568    	; 0x3284 <__fp_nan>

0000304c <__divsf3x>:
    304c:	3d d1       	rcall	.+634    	; 0x32c8 <__fp_split3>
    304e:	98 f3       	brcs	.-26     	; 0x3036 <__divsf3+0x4>

00003050 <__divsf3_pse>:
    3050:	99 23       	and	r25, r25
    3052:	c9 f3       	breq	.-14     	; 0x3046 <__divsf3+0x14>
    3054:	55 23       	and	r21, r21
    3056:	b1 f3       	breq	.-20     	; 0x3044 <__divsf3+0x12>
    3058:	95 1b       	sub	r25, r21
    305a:	55 0b       	sbc	r21, r21
    305c:	bb 27       	eor	r27, r27
    305e:	aa 27       	eor	r26, r26
    3060:	62 17       	cp	r22, r18
    3062:	73 07       	cpc	r23, r19
    3064:	84 07       	cpc	r24, r20
    3066:	38 f0       	brcs	.+14     	; 0x3076 <__divsf3_pse+0x26>
    3068:	9f 5f       	subi	r25, 0xFF	; 255
    306a:	5f 4f       	sbci	r21, 0xFF	; 255
    306c:	22 0f       	add	r18, r18
    306e:	33 1f       	adc	r19, r19
    3070:	44 1f       	adc	r20, r20
    3072:	aa 1f       	adc	r26, r26
    3074:	a9 f3       	breq	.-22     	; 0x3060 <__divsf3_pse+0x10>
    3076:	33 d0       	rcall	.+102    	; 0x30de <__divsf3_pse+0x8e>
    3078:	0e 2e       	mov	r0, r30
    307a:	3a f0       	brmi	.+14     	; 0x308a <__divsf3_pse+0x3a>
    307c:	e0 e8       	ldi	r30, 0x80	; 128
    307e:	30 d0       	rcall	.+96     	; 0x30e0 <__divsf3_pse+0x90>
    3080:	91 50       	subi	r25, 0x01	; 1
    3082:	50 40       	sbci	r21, 0x00	; 0
    3084:	e6 95       	lsr	r30
    3086:	00 1c       	adc	r0, r0
    3088:	ca f7       	brpl	.-14     	; 0x307c <__divsf3_pse+0x2c>
    308a:	29 d0       	rcall	.+82     	; 0x30de <__divsf3_pse+0x8e>
    308c:	fe 2f       	mov	r31, r30
    308e:	27 d0       	rcall	.+78     	; 0x30de <__divsf3_pse+0x8e>
    3090:	66 0f       	add	r22, r22
    3092:	77 1f       	adc	r23, r23
    3094:	88 1f       	adc	r24, r24
    3096:	bb 1f       	adc	r27, r27
    3098:	26 17       	cp	r18, r22
    309a:	37 07       	cpc	r19, r23
    309c:	48 07       	cpc	r20, r24
    309e:	ab 07       	cpc	r26, r27
    30a0:	b0 e8       	ldi	r27, 0x80	; 128
    30a2:	09 f0       	breq	.+2      	; 0x30a6 <__divsf3_pse+0x56>
    30a4:	bb 0b       	sbc	r27, r27
    30a6:	80 2d       	mov	r24, r0
    30a8:	bf 01       	movw	r22, r30
    30aa:	ff 27       	eor	r31, r31
    30ac:	93 58       	subi	r25, 0x83	; 131
    30ae:	5f 4f       	sbci	r21, 0xFF	; 255
    30b0:	2a f0       	brmi	.+10     	; 0x30bc <__divsf3_pse+0x6c>
    30b2:	9e 3f       	cpi	r25, 0xFE	; 254
    30b4:	51 05       	cpc	r21, r1
    30b6:	68 f0       	brcs	.+26     	; 0x30d2 <__divsf3_pse+0x82>
    30b8:	b6 c0       	rjmp	.+364    	; 0x3226 <__fp_inf>
    30ba:	40 c1       	rjmp	.+640    	; 0x333c <__fp_szero>
    30bc:	5f 3f       	cpi	r21, 0xFF	; 255
    30be:	ec f3       	brlt	.-6      	; 0x30ba <__divsf3_pse+0x6a>
    30c0:	98 3e       	cpi	r25, 0xE8	; 232
    30c2:	dc f3       	brlt	.-10     	; 0x30ba <__divsf3_pse+0x6a>
    30c4:	86 95       	lsr	r24
    30c6:	77 95       	ror	r23
    30c8:	67 95       	ror	r22
    30ca:	b7 95       	ror	r27
    30cc:	f7 95       	ror	r31
    30ce:	9f 5f       	subi	r25, 0xFF	; 255
    30d0:	c9 f7       	brne	.-14     	; 0x30c4 <__divsf3_pse+0x74>
    30d2:	88 0f       	add	r24, r24
    30d4:	91 1d       	adc	r25, r1
    30d6:	96 95       	lsr	r25
    30d8:	87 95       	ror	r24
    30da:	97 f9       	bld	r25, 7
    30dc:	08 95       	ret
    30de:	e1 e0       	ldi	r30, 0x01	; 1
    30e0:	66 0f       	add	r22, r22
    30e2:	77 1f       	adc	r23, r23
    30e4:	88 1f       	adc	r24, r24
    30e6:	bb 1f       	adc	r27, r27
    30e8:	62 17       	cp	r22, r18
    30ea:	73 07       	cpc	r23, r19
    30ec:	84 07       	cpc	r24, r20
    30ee:	ba 07       	cpc	r27, r26
    30f0:	20 f0       	brcs	.+8      	; 0x30fa <__divsf3_pse+0xaa>
    30f2:	62 1b       	sub	r22, r18
    30f4:	73 0b       	sbc	r23, r19
    30f6:	84 0b       	sbc	r24, r20
    30f8:	ba 0b       	sbc	r27, r26
    30fa:	ee 1f       	adc	r30, r30
    30fc:	88 f7       	brcc	.-30     	; 0x30e0 <__divsf3_pse+0x90>
    30fe:	e0 95       	com	r30
    3100:	08 95       	ret

00003102 <__fixsfsi>:
    3102:	04 d0       	rcall	.+8      	; 0x310c <__fixunssfsi>
    3104:	68 94       	set
    3106:	b1 11       	cpse	r27, r1
    3108:	19 c1       	rjmp	.+562    	; 0x333c <__fp_szero>
    310a:	08 95       	ret

0000310c <__fixunssfsi>:
    310c:	e5 d0       	rcall	.+458    	; 0x32d8 <__fp_splitA>
    310e:	88 f0       	brcs	.+34     	; 0x3132 <__fixunssfsi+0x26>
    3110:	9f 57       	subi	r25, 0x7F	; 127
    3112:	90 f0       	brcs	.+36     	; 0x3138 <__fixunssfsi+0x2c>
    3114:	b9 2f       	mov	r27, r25
    3116:	99 27       	eor	r25, r25
    3118:	b7 51       	subi	r27, 0x17	; 23
    311a:	a0 f0       	brcs	.+40     	; 0x3144 <__fixunssfsi+0x38>
    311c:	d1 f0       	breq	.+52     	; 0x3152 <__fixunssfsi+0x46>
    311e:	66 0f       	add	r22, r22
    3120:	77 1f       	adc	r23, r23
    3122:	88 1f       	adc	r24, r24
    3124:	99 1f       	adc	r25, r25
    3126:	1a f0       	brmi	.+6      	; 0x312e <__fixunssfsi+0x22>
    3128:	ba 95       	dec	r27
    312a:	c9 f7       	brne	.-14     	; 0x311e <__fixunssfsi+0x12>
    312c:	12 c0       	rjmp	.+36     	; 0x3152 <__fixunssfsi+0x46>
    312e:	b1 30       	cpi	r27, 0x01	; 1
    3130:	81 f0       	breq	.+32     	; 0x3152 <__fixunssfsi+0x46>
    3132:	03 d1       	rcall	.+518    	; 0x333a <__fp_zero>
    3134:	b1 e0       	ldi	r27, 0x01	; 1
    3136:	08 95       	ret
    3138:	00 c1       	rjmp	.+512    	; 0x333a <__fp_zero>
    313a:	67 2f       	mov	r22, r23
    313c:	78 2f       	mov	r23, r24
    313e:	88 27       	eor	r24, r24
    3140:	b8 5f       	subi	r27, 0xF8	; 248
    3142:	39 f0       	breq	.+14     	; 0x3152 <__fixunssfsi+0x46>
    3144:	b9 3f       	cpi	r27, 0xF9	; 249
    3146:	cc f3       	brlt	.-14     	; 0x313a <__fixunssfsi+0x2e>
    3148:	86 95       	lsr	r24
    314a:	77 95       	ror	r23
    314c:	67 95       	ror	r22
    314e:	b3 95       	inc	r27
    3150:	d9 f7       	brne	.-10     	; 0x3148 <__fixunssfsi+0x3c>
    3152:	3e f4       	brtc	.+14     	; 0x3162 <__fixunssfsi+0x56>
    3154:	90 95       	com	r25
    3156:	80 95       	com	r24
    3158:	70 95       	com	r23
    315a:	61 95       	neg	r22
    315c:	7f 4f       	sbci	r23, 0xFF	; 255
    315e:	8f 4f       	sbci	r24, 0xFF	; 255
    3160:	9f 4f       	sbci	r25, 0xFF	; 255
    3162:	08 95       	ret

00003164 <__floatunsisf>:
    3164:	e8 94       	clt
    3166:	09 c0       	rjmp	.+18     	; 0x317a <__floatsisf+0x12>

00003168 <__floatsisf>:
    3168:	97 fb       	bst	r25, 7
    316a:	3e f4       	brtc	.+14     	; 0x317a <__floatsisf+0x12>
    316c:	90 95       	com	r25
    316e:	80 95       	com	r24
    3170:	70 95       	com	r23
    3172:	61 95       	neg	r22
    3174:	7f 4f       	sbci	r23, 0xFF	; 255
    3176:	8f 4f       	sbci	r24, 0xFF	; 255
    3178:	9f 4f       	sbci	r25, 0xFF	; 255
    317a:	99 23       	and	r25, r25
    317c:	a9 f0       	breq	.+42     	; 0x31a8 <__floatsisf+0x40>
    317e:	f9 2f       	mov	r31, r25
    3180:	96 e9       	ldi	r25, 0x96	; 150
    3182:	bb 27       	eor	r27, r27
    3184:	93 95       	inc	r25
    3186:	f6 95       	lsr	r31
    3188:	87 95       	ror	r24
    318a:	77 95       	ror	r23
    318c:	67 95       	ror	r22
    318e:	b7 95       	ror	r27
    3190:	f1 11       	cpse	r31, r1
    3192:	f8 cf       	rjmp	.-16     	; 0x3184 <__floatsisf+0x1c>
    3194:	fa f4       	brpl	.+62     	; 0x31d4 <__floatsisf+0x6c>
    3196:	bb 0f       	add	r27, r27
    3198:	11 f4       	brne	.+4      	; 0x319e <__floatsisf+0x36>
    319a:	60 ff       	sbrs	r22, 0
    319c:	1b c0       	rjmp	.+54     	; 0x31d4 <__floatsisf+0x6c>
    319e:	6f 5f       	subi	r22, 0xFF	; 255
    31a0:	7f 4f       	sbci	r23, 0xFF	; 255
    31a2:	8f 4f       	sbci	r24, 0xFF	; 255
    31a4:	9f 4f       	sbci	r25, 0xFF	; 255
    31a6:	16 c0       	rjmp	.+44     	; 0x31d4 <__floatsisf+0x6c>
    31a8:	88 23       	and	r24, r24
    31aa:	11 f0       	breq	.+4      	; 0x31b0 <__floatsisf+0x48>
    31ac:	96 e9       	ldi	r25, 0x96	; 150
    31ae:	11 c0       	rjmp	.+34     	; 0x31d2 <__floatsisf+0x6a>
    31b0:	77 23       	and	r23, r23
    31b2:	21 f0       	breq	.+8      	; 0x31bc <__floatsisf+0x54>
    31b4:	9e e8       	ldi	r25, 0x8E	; 142
    31b6:	87 2f       	mov	r24, r23
    31b8:	76 2f       	mov	r23, r22
    31ba:	05 c0       	rjmp	.+10     	; 0x31c6 <__floatsisf+0x5e>
    31bc:	66 23       	and	r22, r22
    31be:	71 f0       	breq	.+28     	; 0x31dc <__floatsisf+0x74>
    31c0:	96 e8       	ldi	r25, 0x86	; 134
    31c2:	86 2f       	mov	r24, r22
    31c4:	70 e0       	ldi	r23, 0x00	; 0
    31c6:	60 e0       	ldi	r22, 0x00	; 0
    31c8:	2a f0       	brmi	.+10     	; 0x31d4 <__floatsisf+0x6c>
    31ca:	9a 95       	dec	r25
    31cc:	66 0f       	add	r22, r22
    31ce:	77 1f       	adc	r23, r23
    31d0:	88 1f       	adc	r24, r24
    31d2:	da f7       	brpl	.-10     	; 0x31ca <__floatsisf+0x62>
    31d4:	88 0f       	add	r24, r24
    31d6:	96 95       	lsr	r25
    31d8:	87 95       	ror	r24
    31da:	97 f9       	bld	r25, 7
    31dc:	08 95       	ret

000031de <__fp_cmp>:
    31de:	99 0f       	add	r25, r25
    31e0:	00 08       	sbc	r0, r0
    31e2:	55 0f       	add	r21, r21
    31e4:	aa 0b       	sbc	r26, r26
    31e6:	e0 e8       	ldi	r30, 0x80	; 128
    31e8:	fe ef       	ldi	r31, 0xFE	; 254
    31ea:	16 16       	cp	r1, r22
    31ec:	17 06       	cpc	r1, r23
    31ee:	e8 07       	cpc	r30, r24
    31f0:	f9 07       	cpc	r31, r25
    31f2:	c0 f0       	brcs	.+48     	; 0x3224 <__fp_cmp+0x46>
    31f4:	12 16       	cp	r1, r18
    31f6:	13 06       	cpc	r1, r19
    31f8:	e4 07       	cpc	r30, r20
    31fa:	f5 07       	cpc	r31, r21
    31fc:	98 f0       	brcs	.+38     	; 0x3224 <__fp_cmp+0x46>
    31fe:	62 1b       	sub	r22, r18
    3200:	73 0b       	sbc	r23, r19
    3202:	84 0b       	sbc	r24, r20
    3204:	95 0b       	sbc	r25, r21
    3206:	39 f4       	brne	.+14     	; 0x3216 <__fp_cmp+0x38>
    3208:	0a 26       	eor	r0, r26
    320a:	61 f0       	breq	.+24     	; 0x3224 <__fp_cmp+0x46>
    320c:	23 2b       	or	r18, r19
    320e:	24 2b       	or	r18, r20
    3210:	25 2b       	or	r18, r21
    3212:	21 f4       	brne	.+8      	; 0x321c <__fp_cmp+0x3e>
    3214:	08 95       	ret
    3216:	0a 26       	eor	r0, r26
    3218:	09 f4       	brne	.+2      	; 0x321c <__fp_cmp+0x3e>
    321a:	a1 40       	sbci	r26, 0x01	; 1
    321c:	a6 95       	lsr	r26
    321e:	8f ef       	ldi	r24, 0xFF	; 255
    3220:	81 1d       	adc	r24, r1
    3222:	81 1d       	adc	r24, r1
    3224:	08 95       	ret

00003226 <__fp_inf>:
    3226:	97 f9       	bld	r25, 7
    3228:	9f 67       	ori	r25, 0x7F	; 127
    322a:	80 e8       	ldi	r24, 0x80	; 128
    322c:	70 e0       	ldi	r23, 0x00	; 0
    322e:	60 e0       	ldi	r22, 0x00	; 0
    3230:	08 95       	ret

00003232 <__fp_mintl>:
    3232:	88 23       	and	r24, r24
    3234:	71 f4       	brne	.+28     	; 0x3252 <__fp_mintl+0x20>
    3236:	77 23       	and	r23, r23
    3238:	21 f0       	breq	.+8      	; 0x3242 <__fp_mintl+0x10>
    323a:	98 50       	subi	r25, 0x08	; 8
    323c:	87 2b       	or	r24, r23
    323e:	76 2f       	mov	r23, r22
    3240:	07 c0       	rjmp	.+14     	; 0x3250 <__fp_mintl+0x1e>
    3242:	66 23       	and	r22, r22
    3244:	11 f4       	brne	.+4      	; 0x324a <__fp_mintl+0x18>
    3246:	99 27       	eor	r25, r25
    3248:	0d c0       	rjmp	.+26     	; 0x3264 <__fp_mintl+0x32>
    324a:	90 51       	subi	r25, 0x10	; 16
    324c:	86 2b       	or	r24, r22
    324e:	70 e0       	ldi	r23, 0x00	; 0
    3250:	60 e0       	ldi	r22, 0x00	; 0
    3252:	2a f0       	brmi	.+10     	; 0x325e <__fp_mintl+0x2c>
    3254:	9a 95       	dec	r25
    3256:	66 0f       	add	r22, r22
    3258:	77 1f       	adc	r23, r23
    325a:	88 1f       	adc	r24, r24
    325c:	da f7       	brpl	.-10     	; 0x3254 <__fp_mintl+0x22>
    325e:	88 0f       	add	r24, r24
    3260:	96 95       	lsr	r25
    3262:	87 95       	ror	r24
    3264:	97 f9       	bld	r25, 7
    3266:	08 95       	ret

00003268 <__fp_mpack>:
    3268:	9f 3f       	cpi	r25, 0xFF	; 255
    326a:	31 f0       	breq	.+12     	; 0x3278 <__fp_mpack_finite+0xc>

0000326c <__fp_mpack_finite>:
    326c:	91 50       	subi	r25, 0x01	; 1
    326e:	20 f4       	brcc	.+8      	; 0x3278 <__fp_mpack_finite+0xc>
    3270:	87 95       	ror	r24
    3272:	77 95       	ror	r23
    3274:	67 95       	ror	r22
    3276:	b7 95       	ror	r27
    3278:	88 0f       	add	r24, r24
    327a:	91 1d       	adc	r25, r1
    327c:	96 95       	lsr	r25
    327e:	87 95       	ror	r24
    3280:	97 f9       	bld	r25, 7
    3282:	08 95       	ret

00003284 <__fp_nan>:
    3284:	9f ef       	ldi	r25, 0xFF	; 255
    3286:	80 ec       	ldi	r24, 0xC0	; 192
    3288:	08 95       	ret

0000328a <__fp_pscA>:
    328a:	00 24       	eor	r0, r0
    328c:	0a 94       	dec	r0
    328e:	16 16       	cp	r1, r22
    3290:	17 06       	cpc	r1, r23
    3292:	18 06       	cpc	r1, r24
    3294:	09 06       	cpc	r0, r25
    3296:	08 95       	ret

00003298 <__fp_pscB>:
    3298:	00 24       	eor	r0, r0
    329a:	0a 94       	dec	r0
    329c:	12 16       	cp	r1, r18
    329e:	13 06       	cpc	r1, r19
    32a0:	14 06       	cpc	r1, r20
    32a2:	05 06       	cpc	r0, r21
    32a4:	08 95       	ret

000032a6 <__fp_round>:
    32a6:	09 2e       	mov	r0, r25
    32a8:	03 94       	inc	r0
    32aa:	00 0c       	add	r0, r0
    32ac:	11 f4       	brne	.+4      	; 0x32b2 <__fp_round+0xc>
    32ae:	88 23       	and	r24, r24
    32b0:	52 f0       	brmi	.+20     	; 0x32c6 <__fp_round+0x20>
    32b2:	bb 0f       	add	r27, r27
    32b4:	40 f4       	brcc	.+16     	; 0x32c6 <__fp_round+0x20>
    32b6:	bf 2b       	or	r27, r31
    32b8:	11 f4       	brne	.+4      	; 0x32be <__fp_round+0x18>
    32ba:	60 ff       	sbrs	r22, 0
    32bc:	04 c0       	rjmp	.+8      	; 0x32c6 <__fp_round+0x20>
    32be:	6f 5f       	subi	r22, 0xFF	; 255
    32c0:	7f 4f       	sbci	r23, 0xFF	; 255
    32c2:	8f 4f       	sbci	r24, 0xFF	; 255
    32c4:	9f 4f       	sbci	r25, 0xFF	; 255
    32c6:	08 95       	ret

000032c8 <__fp_split3>:
    32c8:	57 fd       	sbrc	r21, 7
    32ca:	90 58       	subi	r25, 0x80	; 128
    32cc:	44 0f       	add	r20, r20
    32ce:	55 1f       	adc	r21, r21
    32d0:	59 f0       	breq	.+22     	; 0x32e8 <__fp_splitA+0x10>
    32d2:	5f 3f       	cpi	r21, 0xFF	; 255
    32d4:	71 f0       	breq	.+28     	; 0x32f2 <__fp_splitA+0x1a>
    32d6:	47 95       	ror	r20

000032d8 <__fp_splitA>:
    32d8:	88 0f       	add	r24, r24
    32da:	97 fb       	bst	r25, 7
    32dc:	99 1f       	adc	r25, r25
    32de:	61 f0       	breq	.+24     	; 0x32f8 <__fp_splitA+0x20>
    32e0:	9f 3f       	cpi	r25, 0xFF	; 255
    32e2:	79 f0       	breq	.+30     	; 0x3302 <__fp_splitA+0x2a>
    32e4:	87 95       	ror	r24
    32e6:	08 95       	ret
    32e8:	12 16       	cp	r1, r18
    32ea:	13 06       	cpc	r1, r19
    32ec:	14 06       	cpc	r1, r20
    32ee:	55 1f       	adc	r21, r21
    32f0:	f2 cf       	rjmp	.-28     	; 0x32d6 <__fp_split3+0xe>
    32f2:	46 95       	lsr	r20
    32f4:	f1 df       	rcall	.-30     	; 0x32d8 <__fp_splitA>
    32f6:	08 c0       	rjmp	.+16     	; 0x3308 <__fp_splitA+0x30>
    32f8:	16 16       	cp	r1, r22
    32fa:	17 06       	cpc	r1, r23
    32fc:	18 06       	cpc	r1, r24
    32fe:	99 1f       	adc	r25, r25
    3300:	f1 cf       	rjmp	.-30     	; 0x32e4 <__fp_splitA+0xc>
    3302:	86 95       	lsr	r24
    3304:	71 05       	cpc	r23, r1
    3306:	61 05       	cpc	r22, r1
    3308:	08 94       	sec
    330a:	08 95       	ret

0000330c <__fp_trunc>:
    330c:	e5 df       	rcall	.-54     	; 0x32d8 <__fp_splitA>
    330e:	a0 f0       	brcs	.+40     	; 0x3338 <__fp_trunc+0x2c>
    3310:	be e7       	ldi	r27, 0x7E	; 126
    3312:	b9 17       	cp	r27, r25
    3314:	88 f4       	brcc	.+34     	; 0x3338 <__fp_trunc+0x2c>
    3316:	bb 27       	eor	r27, r27
    3318:	9f 38       	cpi	r25, 0x8F	; 143
    331a:	60 f4       	brcc	.+24     	; 0x3334 <__fp_trunc+0x28>
    331c:	16 16       	cp	r1, r22
    331e:	b1 1d       	adc	r27, r1
    3320:	67 2f       	mov	r22, r23
    3322:	78 2f       	mov	r23, r24
    3324:	88 27       	eor	r24, r24
    3326:	98 5f       	subi	r25, 0xF8	; 248
    3328:	f7 cf       	rjmp	.-18     	; 0x3318 <__fp_trunc+0xc>
    332a:	86 95       	lsr	r24
    332c:	77 95       	ror	r23
    332e:	67 95       	ror	r22
    3330:	b1 1d       	adc	r27, r1
    3332:	93 95       	inc	r25
    3334:	96 39       	cpi	r25, 0x96	; 150
    3336:	c8 f3       	brcs	.-14     	; 0x332a <__fp_trunc+0x1e>
    3338:	08 95       	ret

0000333a <__fp_zero>:
    333a:	e8 94       	clt

0000333c <__fp_szero>:
    333c:	bb 27       	eor	r27, r27
    333e:	66 27       	eor	r22, r22
    3340:	77 27       	eor	r23, r23
    3342:	cb 01       	movw	r24, r22
    3344:	97 f9       	bld	r25, 7
    3346:	08 95       	ret

00003348 <__mulsf3>:
    3348:	0b d0       	rcall	.+22     	; 0x3360 <__mulsf3x>
    334a:	ad cf       	rjmp	.-166    	; 0x32a6 <__fp_round>
    334c:	9e df       	rcall	.-196    	; 0x328a <__fp_pscA>
    334e:	28 f0       	brcs	.+10     	; 0x335a <__mulsf3+0x12>
    3350:	a3 df       	rcall	.-186    	; 0x3298 <__fp_pscB>
    3352:	18 f0       	brcs	.+6      	; 0x335a <__mulsf3+0x12>
    3354:	95 23       	and	r25, r21
    3356:	09 f0       	breq	.+2      	; 0x335a <__mulsf3+0x12>
    3358:	66 cf       	rjmp	.-308    	; 0x3226 <__fp_inf>
    335a:	94 cf       	rjmp	.-216    	; 0x3284 <__fp_nan>
    335c:	11 24       	eor	r1, r1
    335e:	ee cf       	rjmp	.-36     	; 0x333c <__fp_szero>

00003360 <__mulsf3x>:
    3360:	b3 df       	rcall	.-154    	; 0x32c8 <__fp_split3>
    3362:	a0 f3       	brcs	.-24     	; 0x334c <__mulsf3+0x4>

00003364 <__mulsf3_pse>:
    3364:	95 9f       	mul	r25, r21
    3366:	d1 f3       	breq	.-12     	; 0x335c <__mulsf3+0x14>
    3368:	95 0f       	add	r25, r21
    336a:	50 e0       	ldi	r21, 0x00	; 0
    336c:	55 1f       	adc	r21, r21
    336e:	62 9f       	mul	r22, r18
    3370:	f0 01       	movw	r30, r0
    3372:	72 9f       	mul	r23, r18
    3374:	bb 27       	eor	r27, r27
    3376:	f0 0d       	add	r31, r0
    3378:	b1 1d       	adc	r27, r1
    337a:	63 9f       	mul	r22, r19
    337c:	aa 27       	eor	r26, r26
    337e:	f0 0d       	add	r31, r0
    3380:	b1 1d       	adc	r27, r1
    3382:	aa 1f       	adc	r26, r26
    3384:	64 9f       	mul	r22, r20
    3386:	66 27       	eor	r22, r22
    3388:	b0 0d       	add	r27, r0
    338a:	a1 1d       	adc	r26, r1
    338c:	66 1f       	adc	r22, r22
    338e:	82 9f       	mul	r24, r18
    3390:	22 27       	eor	r18, r18
    3392:	b0 0d       	add	r27, r0
    3394:	a1 1d       	adc	r26, r1
    3396:	62 1f       	adc	r22, r18
    3398:	73 9f       	mul	r23, r19
    339a:	b0 0d       	add	r27, r0
    339c:	a1 1d       	adc	r26, r1
    339e:	62 1f       	adc	r22, r18
    33a0:	83 9f       	mul	r24, r19
    33a2:	a0 0d       	add	r26, r0
    33a4:	61 1d       	adc	r22, r1
    33a6:	22 1f       	adc	r18, r18
    33a8:	74 9f       	mul	r23, r20
    33aa:	33 27       	eor	r19, r19
    33ac:	a0 0d       	add	r26, r0
    33ae:	61 1d       	adc	r22, r1
    33b0:	23 1f       	adc	r18, r19
    33b2:	84 9f       	mul	r24, r20
    33b4:	60 0d       	add	r22, r0
    33b6:	21 1d       	adc	r18, r1
    33b8:	82 2f       	mov	r24, r18
    33ba:	76 2f       	mov	r23, r22
    33bc:	6a 2f       	mov	r22, r26
    33be:	11 24       	eor	r1, r1
    33c0:	9f 57       	subi	r25, 0x7F	; 127
    33c2:	50 40       	sbci	r21, 0x00	; 0
    33c4:	8a f0       	brmi	.+34     	; 0x33e8 <__mulsf3_pse+0x84>
    33c6:	e1 f0       	breq	.+56     	; 0x3400 <__mulsf3_pse+0x9c>
    33c8:	88 23       	and	r24, r24
    33ca:	4a f0       	brmi	.+18     	; 0x33de <__mulsf3_pse+0x7a>
    33cc:	ee 0f       	add	r30, r30
    33ce:	ff 1f       	adc	r31, r31
    33d0:	bb 1f       	adc	r27, r27
    33d2:	66 1f       	adc	r22, r22
    33d4:	77 1f       	adc	r23, r23
    33d6:	88 1f       	adc	r24, r24
    33d8:	91 50       	subi	r25, 0x01	; 1
    33da:	50 40       	sbci	r21, 0x00	; 0
    33dc:	a9 f7       	brne	.-22     	; 0x33c8 <__mulsf3_pse+0x64>
    33de:	9e 3f       	cpi	r25, 0xFE	; 254
    33e0:	51 05       	cpc	r21, r1
    33e2:	70 f0       	brcs	.+28     	; 0x3400 <__mulsf3_pse+0x9c>
    33e4:	20 cf       	rjmp	.-448    	; 0x3226 <__fp_inf>
    33e6:	aa cf       	rjmp	.-172    	; 0x333c <__fp_szero>
    33e8:	5f 3f       	cpi	r21, 0xFF	; 255
    33ea:	ec f3       	brlt	.-6      	; 0x33e6 <__mulsf3_pse+0x82>
    33ec:	98 3e       	cpi	r25, 0xE8	; 232
    33ee:	dc f3       	brlt	.-10     	; 0x33e6 <__mulsf3_pse+0x82>
    33f0:	86 95       	lsr	r24
    33f2:	77 95       	ror	r23
    33f4:	67 95       	ror	r22
    33f6:	b7 95       	ror	r27
    33f8:	f7 95       	ror	r31
    33fa:	e7 95       	ror	r30
    33fc:	9f 5f       	subi	r25, 0xFF	; 255
    33fe:	c1 f7       	brne	.-16     	; 0x33f0 <__mulsf3_pse+0x8c>
    3400:	fe 2b       	or	r31, r30
    3402:	88 0f       	add	r24, r24
    3404:	91 1d       	adc	r25, r1
    3406:	96 95       	lsr	r25
    3408:	87 95       	ror	r24
    340a:	97 f9       	bld	r25, 7
    340c:	08 95       	ret

0000340e <pow>:
    340e:	fa 01       	movw	r30, r20
    3410:	ee 0f       	add	r30, r30
    3412:	ff 1f       	adc	r31, r31
    3414:	30 96       	adiw	r30, 0x00	; 0
    3416:	21 05       	cpc	r18, r1
    3418:	31 05       	cpc	r19, r1
    341a:	99 f1       	breq	.+102    	; 0x3482 <pow+0x74>
    341c:	61 15       	cp	r22, r1
    341e:	71 05       	cpc	r23, r1
    3420:	61 f4       	brne	.+24     	; 0x343a <pow+0x2c>
    3422:	80 38       	cpi	r24, 0x80	; 128
    3424:	bf e3       	ldi	r27, 0x3F	; 63
    3426:	9b 07       	cpc	r25, r27
    3428:	49 f1       	breq	.+82     	; 0x347c <pow+0x6e>
    342a:	68 94       	set
    342c:	90 38       	cpi	r25, 0x80	; 128
    342e:	81 05       	cpc	r24, r1
    3430:	61 f0       	breq	.+24     	; 0x344a <pow+0x3c>
    3432:	80 38       	cpi	r24, 0x80	; 128
    3434:	bf ef       	ldi	r27, 0xFF	; 255
    3436:	9b 07       	cpc	r25, r27
    3438:	41 f0       	breq	.+16     	; 0x344a <pow+0x3c>
    343a:	99 23       	and	r25, r25
    343c:	42 f5       	brpl	.+80     	; 0x348e <pow+0x80>
    343e:	ff 3f       	cpi	r31, 0xFF	; 255
    3440:	e1 05       	cpc	r30, r1
    3442:	31 05       	cpc	r19, r1
    3444:	21 05       	cpc	r18, r1
    3446:	11 f1       	breq	.+68     	; 0x348c <pow+0x7e>
    3448:	e8 94       	clt
    344a:	08 94       	sec
    344c:	e7 95       	ror	r30
    344e:	d9 01       	movw	r26, r18
    3450:	aa 23       	and	r26, r26
    3452:	29 f4       	brne	.+10     	; 0x345e <pow+0x50>
    3454:	ab 2f       	mov	r26, r27
    3456:	be 2f       	mov	r27, r30
    3458:	f8 5f       	subi	r31, 0xF8	; 248
    345a:	d0 f3       	brcs	.-12     	; 0x3450 <pow+0x42>
    345c:	10 c0       	rjmp	.+32     	; 0x347e <pow+0x70>
    345e:	ff 5f       	subi	r31, 0xFF	; 255
    3460:	70 f4       	brcc	.+28     	; 0x347e <pow+0x70>
    3462:	a6 95       	lsr	r26
    3464:	e0 f7       	brcc	.-8      	; 0x345e <pow+0x50>
    3466:	f7 39       	cpi	r31, 0x97	; 151
    3468:	50 f0       	brcs	.+20     	; 0x347e <pow+0x70>
    346a:	19 f0       	breq	.+6      	; 0x3472 <pow+0x64>
    346c:	ff 3a       	cpi	r31, 0xAF	; 175
    346e:	38 f4       	brcc	.+14     	; 0x347e <pow+0x70>
    3470:	9f 77       	andi	r25, 0x7F	; 127
    3472:	9f 93       	push	r25
    3474:	0c d0       	rcall	.+24     	; 0x348e <pow+0x80>
    3476:	0f 90       	pop	r0
    3478:	07 fc       	sbrc	r0, 7
    347a:	90 58       	subi	r25, 0x80	; 128
    347c:	08 95       	ret
    347e:	3e f0       	brts	.+14     	; 0x348e <pow+0x80>
    3480:	01 cf       	rjmp	.-510    	; 0x3284 <__fp_nan>
    3482:	60 e0       	ldi	r22, 0x00	; 0
    3484:	70 e0       	ldi	r23, 0x00	; 0
    3486:	80 e8       	ldi	r24, 0x80	; 128
    3488:	9f e3       	ldi	r25, 0x3F	; 63
    348a:	08 95       	ret
    348c:	4f e7       	ldi	r20, 0x7F	; 127
    348e:	9f 77       	andi	r25, 0x7F	; 127
    3490:	5f 93       	push	r21
    3492:	4f 93       	push	r20
    3494:	3f 93       	push	r19
    3496:	2f 93       	push	r18
    3498:	9e d0       	rcall	.+316    	; 0x35d6 <log>
    349a:	2f 91       	pop	r18
    349c:	3f 91       	pop	r19
    349e:	4f 91       	pop	r20
    34a0:	5f 91       	pop	r21
    34a2:	52 df       	rcall	.-348    	; 0x3348 <__mulsf3>
    34a4:	05 c0       	rjmp	.+10     	; 0x34b0 <exp>
    34a6:	19 f4       	brne	.+6      	; 0x34ae <pow+0xa0>
    34a8:	0e f0       	brts	.+2      	; 0x34ac <pow+0x9e>
    34aa:	bd ce       	rjmp	.-646    	; 0x3226 <__fp_inf>
    34ac:	46 cf       	rjmp	.-372    	; 0x333a <__fp_zero>
    34ae:	ea ce       	rjmp	.-556    	; 0x3284 <__fp_nan>

000034b0 <exp>:
    34b0:	13 df       	rcall	.-474    	; 0x32d8 <__fp_splitA>
    34b2:	c8 f3       	brcs	.-14     	; 0x34a6 <pow+0x98>
    34b4:	96 38       	cpi	r25, 0x86	; 134
    34b6:	c0 f7       	brcc	.-16     	; 0x34a8 <pow+0x9a>
    34b8:	07 f8       	bld	r0, 7
    34ba:	0f 92       	push	r0
    34bc:	e8 94       	clt
    34be:	2b e3       	ldi	r18, 0x3B	; 59
    34c0:	3a ea       	ldi	r19, 0xAA	; 170
    34c2:	48 eb       	ldi	r20, 0xB8	; 184
    34c4:	5f e7       	ldi	r21, 0x7F	; 127
    34c6:	4e df       	rcall	.-356    	; 0x3364 <__mulsf3_pse>
    34c8:	0f 92       	push	r0
    34ca:	0f 92       	push	r0
    34cc:	0f 92       	push	r0
    34ce:	4d b7       	in	r20, 0x3d	; 61
    34d0:	5e b7       	in	r21, 0x3e	; 62
    34d2:	0f 92       	push	r0
    34d4:	c0 d0       	rcall	.+384    	; 0x3656 <modf>
    34d6:	e4 ee       	ldi	r30, 0xE4	; 228
    34d8:	f0 e0       	ldi	r31, 0x00	; 0
    34da:	16 d0       	rcall	.+44     	; 0x3508 <__fp_powser>
    34dc:	4f 91       	pop	r20
    34de:	5f 91       	pop	r21
    34e0:	ef 91       	pop	r30
    34e2:	ff 91       	pop	r31
    34e4:	e5 95       	asr	r30
    34e6:	ee 1f       	adc	r30, r30
    34e8:	ff 1f       	adc	r31, r31
    34ea:	49 f0       	breq	.+18     	; 0x34fe <exp+0x4e>
    34ec:	fe 57       	subi	r31, 0x7E	; 126
    34ee:	e0 68       	ori	r30, 0x80	; 128
    34f0:	44 27       	eor	r20, r20
    34f2:	ee 0f       	add	r30, r30
    34f4:	44 1f       	adc	r20, r20
    34f6:	fa 95       	dec	r31
    34f8:	e1 f7       	brne	.-8      	; 0x34f2 <exp+0x42>
    34fa:	41 95       	neg	r20
    34fc:	55 0b       	sbc	r21, r21
    34fe:	32 d0       	rcall	.+100    	; 0x3564 <ldexp>
    3500:	0f 90       	pop	r0
    3502:	07 fe       	sbrs	r0, 7
    3504:	26 c0       	rjmp	.+76     	; 0x3552 <inverse>
    3506:	08 95       	ret

00003508 <__fp_powser>:
    3508:	df 93       	push	r29
    350a:	cf 93       	push	r28
    350c:	1f 93       	push	r17
    350e:	0f 93       	push	r16
    3510:	ff 92       	push	r15
    3512:	ef 92       	push	r14
    3514:	df 92       	push	r13
    3516:	7b 01       	movw	r14, r22
    3518:	8c 01       	movw	r16, r24
    351a:	68 94       	set
    351c:	05 c0       	rjmp	.+10     	; 0x3528 <__fp_powser+0x20>
    351e:	da 2e       	mov	r13, r26
    3520:	ef 01       	movw	r28, r30
    3522:	1e df       	rcall	.-452    	; 0x3360 <__mulsf3x>
    3524:	fe 01       	movw	r30, r28
    3526:	e8 94       	clt
    3528:	a5 91       	lpm	r26, Z+
    352a:	25 91       	lpm	r18, Z+
    352c:	35 91       	lpm	r19, Z+
    352e:	45 91       	lpm	r20, Z+
    3530:	55 91       	lpm	r21, Z+
    3532:	ae f3       	brts	.-22     	; 0x351e <__fp_powser+0x16>
    3534:	ef 01       	movw	r28, r30
    3536:	13 dd       	rcall	.-1498   	; 0x2f5e <__addsf3x>
    3538:	fe 01       	movw	r30, r28
    353a:	97 01       	movw	r18, r14
    353c:	a8 01       	movw	r20, r16
    353e:	da 94       	dec	r13
    3540:	79 f7       	brne	.-34     	; 0x3520 <__fp_powser+0x18>
    3542:	df 90       	pop	r13
    3544:	ef 90       	pop	r14
    3546:	ff 90       	pop	r15
    3548:	0f 91       	pop	r16
    354a:	1f 91       	pop	r17
    354c:	cf 91       	pop	r28
    354e:	df 91       	pop	r29
    3550:	08 95       	ret

00003552 <inverse>:
    3552:	9b 01       	movw	r18, r22
    3554:	ac 01       	movw	r20, r24
    3556:	60 e0       	ldi	r22, 0x00	; 0
    3558:	70 e0       	ldi	r23, 0x00	; 0
    355a:	80 e8       	ldi	r24, 0x80	; 128
    355c:	9f e3       	ldi	r25, 0x3F	; 63
    355e:	69 cd       	rjmp	.-1326   	; 0x3032 <__divsf3>
    3560:	62 ce       	rjmp	.-828    	; 0x3226 <__fp_inf>
    3562:	82 ce       	rjmp	.-764    	; 0x3268 <__fp_mpack>

00003564 <ldexp>:
    3564:	b9 de       	rcall	.-654    	; 0x32d8 <__fp_splitA>
    3566:	e8 f3       	brcs	.-6      	; 0x3562 <inverse+0x10>
    3568:	99 23       	and	r25, r25
    356a:	d9 f3       	breq	.-10     	; 0x3562 <inverse+0x10>
    356c:	94 0f       	add	r25, r20
    356e:	51 1d       	adc	r21, r1
    3570:	bb f3       	brvs	.-18     	; 0x3560 <inverse+0xe>
    3572:	91 50       	subi	r25, 0x01	; 1
    3574:	50 40       	sbci	r21, 0x00	; 0
    3576:	94 f0       	brlt	.+36     	; 0x359c <ldexp+0x38>
    3578:	59 f0       	breq	.+22     	; 0x3590 <ldexp+0x2c>
    357a:	88 23       	and	r24, r24
    357c:	32 f0       	brmi	.+12     	; 0x358a <ldexp+0x26>
    357e:	66 0f       	add	r22, r22
    3580:	77 1f       	adc	r23, r23
    3582:	88 1f       	adc	r24, r24
    3584:	91 50       	subi	r25, 0x01	; 1
    3586:	50 40       	sbci	r21, 0x00	; 0
    3588:	c1 f7       	brne	.-16     	; 0x357a <ldexp+0x16>
    358a:	9e 3f       	cpi	r25, 0xFE	; 254
    358c:	51 05       	cpc	r21, r1
    358e:	44 f7       	brge	.-48     	; 0x3560 <inverse+0xe>
    3590:	88 0f       	add	r24, r24
    3592:	91 1d       	adc	r25, r1
    3594:	96 95       	lsr	r25
    3596:	87 95       	ror	r24
    3598:	97 f9       	bld	r25, 7
    359a:	08 95       	ret
    359c:	5f 3f       	cpi	r21, 0xFF	; 255
    359e:	ac f0       	brlt	.+42     	; 0x35ca <ldexp+0x66>
    35a0:	98 3e       	cpi	r25, 0xE8	; 232
    35a2:	9c f0       	brlt	.+38     	; 0x35ca <ldexp+0x66>
    35a4:	bb 27       	eor	r27, r27
    35a6:	86 95       	lsr	r24
    35a8:	77 95       	ror	r23
    35aa:	67 95       	ror	r22
    35ac:	b7 95       	ror	r27
    35ae:	08 f4       	brcc	.+2      	; 0x35b2 <ldexp+0x4e>
    35b0:	b1 60       	ori	r27, 0x01	; 1
    35b2:	93 95       	inc	r25
    35b4:	c1 f7       	brne	.-16     	; 0x35a6 <ldexp+0x42>
    35b6:	bb 0f       	add	r27, r27
    35b8:	58 f7       	brcc	.-42     	; 0x3590 <ldexp+0x2c>
    35ba:	11 f4       	brne	.+4      	; 0x35c0 <ldexp+0x5c>
    35bc:	60 ff       	sbrs	r22, 0
    35be:	e8 cf       	rjmp	.-48     	; 0x3590 <ldexp+0x2c>
    35c0:	6f 5f       	subi	r22, 0xFF	; 255
    35c2:	7f 4f       	sbci	r23, 0xFF	; 255
    35c4:	8f 4f       	sbci	r24, 0xFF	; 255
    35c6:	9f 4f       	sbci	r25, 0xFF	; 255
    35c8:	e3 cf       	rjmp	.-58     	; 0x3590 <ldexp+0x2c>
    35ca:	b8 ce       	rjmp	.-656    	; 0x333c <__fp_szero>
    35cc:	0e f0       	brts	.+2      	; 0x35d0 <ldexp+0x6c>
    35ce:	4c ce       	rjmp	.-872    	; 0x3268 <__fp_mpack>
    35d0:	59 ce       	rjmp	.-846    	; 0x3284 <__fp_nan>
    35d2:	68 94       	set
    35d4:	28 ce       	rjmp	.-944    	; 0x3226 <__fp_inf>

000035d6 <log>:
    35d6:	80 de       	rcall	.-768    	; 0x32d8 <__fp_splitA>
    35d8:	c8 f3       	brcs	.-14     	; 0x35cc <ldexp+0x68>
    35da:	99 23       	and	r25, r25
    35dc:	d1 f3       	breq	.-12     	; 0x35d2 <ldexp+0x6e>
    35de:	c6 f3       	brts	.-16     	; 0x35d0 <ldexp+0x6c>
    35e0:	df 93       	push	r29
    35e2:	cf 93       	push	r28
    35e4:	1f 93       	push	r17
    35e6:	0f 93       	push	r16
    35e8:	ff 92       	push	r15
    35ea:	c9 2f       	mov	r28, r25
    35ec:	dd 27       	eor	r29, r29
    35ee:	88 23       	and	r24, r24
    35f0:	2a f0       	brmi	.+10     	; 0x35fc <log+0x26>
    35f2:	21 97       	sbiw	r28, 0x01	; 1
    35f4:	66 0f       	add	r22, r22
    35f6:	77 1f       	adc	r23, r23
    35f8:	88 1f       	adc	r24, r24
    35fa:	da f7       	brpl	.-10     	; 0x35f2 <log+0x1c>
    35fc:	20 e0       	ldi	r18, 0x00	; 0
    35fe:	30 e0       	ldi	r19, 0x00	; 0
    3600:	40 e8       	ldi	r20, 0x80	; 128
    3602:	5f eb       	ldi	r21, 0xBF	; 191
    3604:	9f e3       	ldi	r25, 0x3F	; 63
    3606:	88 39       	cpi	r24, 0x98	; 152
    3608:	20 f0       	brcs	.+8      	; 0x3612 <log+0x3c>
    360a:	80 3e       	cpi	r24, 0xE0	; 224
    360c:	30 f0       	brcs	.+12     	; 0x361a <log+0x44>
    360e:	21 96       	adiw	r28, 0x01	; 1
    3610:	8f 77       	andi	r24, 0x7F	; 127
    3612:	94 dc       	rcall	.-1752   	; 0x2f3c <__addsf3>
    3614:	ec e0       	ldi	r30, 0x0C	; 12
    3616:	f1 e0       	ldi	r31, 0x01	; 1
    3618:	03 c0       	rjmp	.+6      	; 0x3620 <log+0x4a>
    361a:	90 dc       	rcall	.-1760   	; 0x2f3c <__addsf3>
    361c:	e9 e3       	ldi	r30, 0x39	; 57
    361e:	f1 e0       	ldi	r31, 0x01	; 1
    3620:	73 df       	rcall	.-282    	; 0x3508 <__fp_powser>
    3622:	8b 01       	movw	r16, r22
    3624:	be 01       	movw	r22, r28
    3626:	ec 01       	movw	r28, r24
    3628:	fb 2e       	mov	r15, r27
    362a:	6f 57       	subi	r22, 0x7F	; 127
    362c:	71 09       	sbc	r23, r1
    362e:	75 95       	asr	r23
    3630:	77 1f       	adc	r23, r23
    3632:	88 0b       	sbc	r24, r24
    3634:	99 0b       	sbc	r25, r25
    3636:	98 dd       	rcall	.-1232   	; 0x3168 <__floatsisf>
    3638:	28 e1       	ldi	r18, 0x18	; 24
    363a:	32 e7       	ldi	r19, 0x72	; 114
    363c:	41 e3       	ldi	r20, 0x31	; 49
    363e:	5f e3       	ldi	r21, 0x3F	; 63
    3640:	8f de       	rcall	.-738    	; 0x3360 <__mulsf3x>
    3642:	af 2d       	mov	r26, r15
    3644:	98 01       	movw	r18, r16
    3646:	ae 01       	movw	r20, r28
    3648:	ff 90       	pop	r15
    364a:	0f 91       	pop	r16
    364c:	1f 91       	pop	r17
    364e:	cf 91       	pop	r28
    3650:	df 91       	pop	r29
    3652:	85 dc       	rcall	.-1782   	; 0x2f5e <__addsf3x>
    3654:	28 ce       	rjmp	.-944    	; 0x32a6 <__fp_round>

00003656 <modf>:
    3656:	fa 01       	movw	r30, r20
    3658:	dc 01       	movw	r26, r24
    365a:	aa 0f       	add	r26, r26
    365c:	bb 1f       	adc	r27, r27
    365e:	9b 01       	movw	r18, r22
    3660:	ac 01       	movw	r20, r24
    3662:	bf 57       	subi	r27, 0x7F	; 127
    3664:	28 f4       	brcc	.+10     	; 0x3670 <modf+0x1a>
    3666:	22 27       	eor	r18, r18
    3668:	33 27       	eor	r19, r19
    366a:	44 27       	eor	r20, r20
    366c:	50 78       	andi	r21, 0x80	; 128
    366e:	1f c0       	rjmp	.+62     	; 0x36ae <modf+0x58>
    3670:	b7 51       	subi	r27, 0x17	; 23
    3672:	88 f4       	brcc	.+34     	; 0x3696 <modf+0x40>
    3674:	ab 2f       	mov	r26, r27
    3676:	00 24       	eor	r0, r0
    3678:	46 95       	lsr	r20
    367a:	37 95       	ror	r19
    367c:	27 95       	ror	r18
    367e:	01 1c       	adc	r0, r1
    3680:	a3 95       	inc	r26
    3682:	d2 f3       	brmi	.-12     	; 0x3678 <modf+0x22>
    3684:	00 20       	and	r0, r0
    3686:	69 f0       	breq	.+26     	; 0x36a2 <modf+0x4c>
    3688:	22 0f       	add	r18, r18
    368a:	33 1f       	adc	r19, r19
    368c:	44 1f       	adc	r20, r20
    368e:	b3 95       	inc	r27
    3690:	da f3       	brmi	.-10     	; 0x3688 <modf+0x32>
    3692:	0d d0       	rcall	.+26     	; 0x36ae <modf+0x58>
    3694:	52 cc       	rjmp	.-1884   	; 0x2f3a <__subsf3>
    3696:	61 30       	cpi	r22, 0x01	; 1
    3698:	71 05       	cpc	r23, r1
    369a:	a0 e8       	ldi	r26, 0x80	; 128
    369c:	8a 07       	cpc	r24, r26
    369e:	b9 46       	sbci	r27, 0x69	; 105
    36a0:	30 f4       	brcc	.+12     	; 0x36ae <modf+0x58>
    36a2:	9b 01       	movw	r18, r22
    36a4:	ac 01       	movw	r20, r24
    36a6:	66 27       	eor	r22, r22
    36a8:	77 27       	eor	r23, r23
    36aa:	88 27       	eor	r24, r24
    36ac:	90 78       	andi	r25, 0x80	; 128
    36ae:	30 96       	adiw	r30, 0x00	; 0
    36b0:	21 f0       	breq	.+8      	; 0x36ba <modf+0x64>
    36b2:	20 83       	st	Z, r18
    36b4:	31 83       	std	Z+1, r19	; 0x01
    36b6:	42 83       	std	Z+2, r20	; 0x02
    36b8:	53 83       	std	Z+3, r21	; 0x03
    36ba:	08 95       	ret

000036bc <__udivmodhi4>:
    36bc:	aa 1b       	sub	r26, r26
    36be:	bb 1b       	sub	r27, r27
    36c0:	51 e1       	ldi	r21, 0x11	; 17
    36c2:	07 c0       	rjmp	.+14     	; 0x36d2 <__udivmodhi4_ep>

000036c4 <__udivmodhi4_loop>:
    36c4:	aa 1f       	adc	r26, r26
    36c6:	bb 1f       	adc	r27, r27
    36c8:	a6 17       	cp	r26, r22
    36ca:	b7 07       	cpc	r27, r23
    36cc:	10 f0       	brcs	.+4      	; 0x36d2 <__udivmodhi4_ep>
    36ce:	a6 1b       	sub	r26, r22
    36d0:	b7 0b       	sbc	r27, r23

000036d2 <__udivmodhi4_ep>:
    36d2:	88 1f       	adc	r24, r24
    36d4:	99 1f       	adc	r25, r25
    36d6:	5a 95       	dec	r21
    36d8:	a9 f7       	brne	.-22     	; 0x36c4 <__udivmodhi4_loop>
    36da:	80 95       	com	r24
    36dc:	90 95       	com	r25
    36de:	bc 01       	movw	r22, r24
    36e0:	cd 01       	movw	r24, r26
    36e2:	08 95       	ret

000036e4 <__divmodhi4>:
    36e4:	97 fb       	bst	r25, 7
    36e6:	09 2e       	mov	r0, r25
    36e8:	07 26       	eor	r0, r23
    36ea:	0a d0       	rcall	.+20     	; 0x3700 <__divmodhi4_neg1>
    36ec:	77 fd       	sbrc	r23, 7
    36ee:	04 d0       	rcall	.+8      	; 0x36f8 <__divmodhi4_neg2>
    36f0:	e5 df       	rcall	.-54     	; 0x36bc <__udivmodhi4>
    36f2:	06 d0       	rcall	.+12     	; 0x3700 <__divmodhi4_neg1>
    36f4:	00 20       	and	r0, r0
    36f6:	1a f4       	brpl	.+6      	; 0x36fe <__divmodhi4_exit>

000036f8 <__divmodhi4_neg2>:
    36f8:	70 95       	com	r23
    36fa:	61 95       	neg	r22
    36fc:	7f 4f       	sbci	r23, 0xFF	; 255

000036fe <__divmodhi4_exit>:
    36fe:	08 95       	ret

00003700 <__divmodhi4_neg1>:
    3700:	f6 f7       	brtc	.-4      	; 0x36fe <__divmodhi4_exit>
    3702:	90 95       	com	r25
    3704:	81 95       	neg	r24
    3706:	9f 4f       	sbci	r25, 0xFF	; 255
    3708:	08 95       	ret

0000370a <malloc>:
    370a:	cf 93       	push	r28
    370c:	df 93       	push	r29
    370e:	ac 01       	movw	r20, r24
    3710:	82 30       	cpi	r24, 0x02	; 2
    3712:	91 05       	cpc	r25, r1
    3714:	10 f4       	brcc	.+4      	; 0x371a <malloc+0x10>
    3716:	42 e0       	ldi	r20, 0x02	; 2
    3718:	50 e0       	ldi	r21, 0x00	; 0
    371a:	e0 91 66 05 	lds	r30, 0x0566
    371e:	f0 91 67 05 	lds	r31, 0x0567
    3722:	20 e0       	ldi	r18, 0x00	; 0
    3724:	30 e0       	ldi	r19, 0x00	; 0
    3726:	a0 e0       	ldi	r26, 0x00	; 0
    3728:	b0 e0       	ldi	r27, 0x00	; 0
    372a:	24 c0       	rjmp	.+72     	; 0x3774 <malloc+0x6a>
    372c:	80 81       	ld	r24, Z
    372e:	91 81       	ldd	r25, Z+1	; 0x01
    3730:	84 17       	cp	r24, r20
    3732:	95 07       	cpc	r25, r21
    3734:	d0 f0       	brcs	.+52     	; 0x376a <malloc+0x60>
    3736:	84 17       	cp	r24, r20
    3738:	95 07       	cpc	r25, r21
    373a:	71 f4       	brne	.+28     	; 0x3758 <malloc+0x4e>
    373c:	82 81       	ldd	r24, Z+2	; 0x02
    373e:	93 81       	ldd	r25, Z+3	; 0x03
    3740:	10 97       	sbiw	r26, 0x00	; 0
    3742:	29 f0       	breq	.+10     	; 0x374e <malloc+0x44>
    3744:	13 96       	adiw	r26, 0x03	; 3
    3746:	9c 93       	st	X, r25
    3748:	8e 93       	st	-X, r24
    374a:	12 97       	sbiw	r26, 0x02	; 2
    374c:	2c c0       	rjmp	.+88     	; 0x37a6 <malloc+0x9c>
    374e:	90 93 67 05 	sts	0x0567, r25
    3752:	80 93 66 05 	sts	0x0566, r24
    3756:	27 c0       	rjmp	.+78     	; 0x37a6 <malloc+0x9c>
    3758:	21 15       	cp	r18, r1
    375a:	31 05       	cpc	r19, r1
    375c:	19 f0       	breq	.+6      	; 0x3764 <malloc+0x5a>
    375e:	82 17       	cp	r24, r18
    3760:	93 07       	cpc	r25, r19
    3762:	18 f4       	brcc	.+6      	; 0x376a <malloc+0x60>
    3764:	9c 01       	movw	r18, r24
    3766:	bd 01       	movw	r22, r26
    3768:	ef 01       	movw	r28, r30
    376a:	92 81       	ldd	r25, Z+2	; 0x02
    376c:	83 81       	ldd	r24, Z+3	; 0x03
    376e:	df 01       	movw	r26, r30
    3770:	e9 2f       	mov	r30, r25
    3772:	f8 2f       	mov	r31, r24
    3774:	30 97       	sbiw	r30, 0x00	; 0
    3776:	d1 f6       	brne	.-76     	; 0x372c <malloc+0x22>
    3778:	21 15       	cp	r18, r1
    377a:	31 05       	cpc	r19, r1
    377c:	f9 f0       	breq	.+62     	; 0x37bc <malloc+0xb2>
    377e:	c9 01       	movw	r24, r18
    3780:	84 1b       	sub	r24, r20
    3782:	95 0b       	sbc	r25, r21
    3784:	84 30       	cpi	r24, 0x04	; 4
    3786:	91 05       	cpc	r25, r1
    3788:	80 f4       	brcc	.+32     	; 0x37aa <malloc+0xa0>
    378a:	8a 81       	ldd	r24, Y+2	; 0x02
    378c:	9b 81       	ldd	r25, Y+3	; 0x03
    378e:	61 15       	cp	r22, r1
    3790:	71 05       	cpc	r23, r1
    3792:	21 f0       	breq	.+8      	; 0x379c <malloc+0x92>
    3794:	fb 01       	movw	r30, r22
    3796:	93 83       	std	Z+3, r25	; 0x03
    3798:	82 83       	std	Z+2, r24	; 0x02
    379a:	04 c0       	rjmp	.+8      	; 0x37a4 <malloc+0x9a>
    379c:	90 93 67 05 	sts	0x0567, r25
    37a0:	80 93 66 05 	sts	0x0566, r24
    37a4:	fe 01       	movw	r30, r28
    37a6:	32 96       	adiw	r30, 0x02	; 2
    37a8:	42 c0       	rjmp	.+132    	; 0x382e <malloc+0x124>
    37aa:	fe 01       	movw	r30, r28
    37ac:	e8 0f       	add	r30, r24
    37ae:	f9 1f       	adc	r31, r25
    37b0:	41 93       	st	Z+, r20
    37b2:	51 93       	st	Z+, r21
    37b4:	02 97       	sbiw	r24, 0x02	; 2
    37b6:	99 83       	std	Y+1, r25	; 0x01
    37b8:	88 83       	st	Y, r24
    37ba:	39 c0       	rjmp	.+114    	; 0x382e <malloc+0x124>
    37bc:	80 91 64 05 	lds	r24, 0x0564
    37c0:	90 91 65 05 	lds	r25, 0x0565
    37c4:	00 97       	sbiw	r24, 0x00	; 0
    37c6:	41 f4       	brne	.+16     	; 0x37d8 <malloc+0xce>
    37c8:	80 91 45 02 	lds	r24, 0x0245
    37cc:	90 91 46 02 	lds	r25, 0x0246
    37d0:	90 93 65 05 	sts	0x0565, r25
    37d4:	80 93 64 05 	sts	0x0564, r24
    37d8:	20 91 43 02 	lds	r18, 0x0243
    37dc:	30 91 44 02 	lds	r19, 0x0244
    37e0:	21 15       	cp	r18, r1
    37e2:	31 05       	cpc	r19, r1
    37e4:	41 f4       	brne	.+16     	; 0x37f6 <malloc+0xec>
    37e6:	2d b7       	in	r18, 0x3d	; 61
    37e8:	3e b7       	in	r19, 0x3e	; 62
    37ea:	80 91 47 02 	lds	r24, 0x0247
    37ee:	90 91 48 02 	lds	r25, 0x0248
    37f2:	28 1b       	sub	r18, r24
    37f4:	39 0b       	sbc	r19, r25
    37f6:	e0 91 64 05 	lds	r30, 0x0564
    37fa:	f0 91 65 05 	lds	r31, 0x0565
    37fe:	e2 17       	cp	r30, r18
    3800:	f3 07       	cpc	r31, r19
    3802:	98 f4       	brcc	.+38     	; 0x382a <malloc+0x120>
    3804:	2e 1b       	sub	r18, r30
    3806:	3f 0b       	sbc	r19, r31
    3808:	24 17       	cp	r18, r20
    380a:	35 07       	cpc	r19, r21
    380c:	70 f0       	brcs	.+28     	; 0x382a <malloc+0x120>
    380e:	ca 01       	movw	r24, r20
    3810:	02 96       	adiw	r24, 0x02	; 2
    3812:	28 17       	cp	r18, r24
    3814:	39 07       	cpc	r19, r25
    3816:	48 f0       	brcs	.+18     	; 0x382a <malloc+0x120>
    3818:	8e 0f       	add	r24, r30
    381a:	9f 1f       	adc	r25, r31
    381c:	90 93 65 05 	sts	0x0565, r25
    3820:	80 93 64 05 	sts	0x0564, r24
    3824:	41 93       	st	Z+, r20
    3826:	51 93       	st	Z+, r21
    3828:	02 c0       	rjmp	.+4      	; 0x382e <malloc+0x124>
    382a:	e0 e0       	ldi	r30, 0x00	; 0
    382c:	f0 e0       	ldi	r31, 0x00	; 0
    382e:	cf 01       	movw	r24, r30
    3830:	df 91       	pop	r29
    3832:	cf 91       	pop	r28
    3834:	08 95       	ret

00003836 <free>:
    3836:	0f 93       	push	r16
    3838:	1f 93       	push	r17
    383a:	cf 93       	push	r28
    383c:	df 93       	push	r29
    383e:	9c 01       	movw	r18, r24
    3840:	00 97       	sbiw	r24, 0x00	; 0
    3842:	09 f4       	brne	.+2      	; 0x3846 <free+0x10>
    3844:	8c c0       	rjmp	.+280    	; 0x395e <free+0x128>
    3846:	dc 01       	movw	r26, r24
    3848:	12 97       	sbiw	r26, 0x02	; 2
    384a:	13 96       	adiw	r26, 0x03	; 3
    384c:	1c 92       	st	X, r1
    384e:	1e 92       	st	-X, r1
    3850:	12 97       	sbiw	r26, 0x02	; 2
    3852:	60 91 66 05 	lds	r22, 0x0566
    3856:	70 91 67 05 	lds	r23, 0x0567
    385a:	61 15       	cp	r22, r1
    385c:	71 05       	cpc	r23, r1
    385e:	89 f4       	brne	.+34     	; 0x3882 <free+0x4c>
    3860:	8d 91       	ld	r24, X+
    3862:	9c 91       	ld	r25, X
    3864:	11 97       	sbiw	r26, 0x01	; 1
    3866:	82 0f       	add	r24, r18
    3868:	93 1f       	adc	r25, r19
    386a:	20 91 64 05 	lds	r18, 0x0564
    386e:	30 91 65 05 	lds	r19, 0x0565
    3872:	28 17       	cp	r18, r24
    3874:	39 07       	cpc	r19, r25
    3876:	69 f5       	brne	.+90     	; 0x38d2 <free+0x9c>
    3878:	b0 93 65 05 	sts	0x0565, r27
    387c:	a0 93 64 05 	sts	0x0564, r26
    3880:	6e c0       	rjmp	.+220    	; 0x395e <free+0x128>
    3882:	fb 01       	movw	r30, r22
    3884:	40 e0       	ldi	r20, 0x00	; 0
    3886:	50 e0       	ldi	r21, 0x00	; 0
    3888:	01 c0       	rjmp	.+2      	; 0x388c <free+0x56>
    388a:	fc 01       	movw	r30, r24
    388c:	ea 17       	cp	r30, r26
    388e:	fb 07       	cpc	r31, r27
    3890:	30 f4       	brcc	.+12     	; 0x389e <free+0x68>
    3892:	82 81       	ldd	r24, Z+2	; 0x02
    3894:	93 81       	ldd	r25, Z+3	; 0x03
    3896:	af 01       	movw	r20, r30
    3898:	00 97       	sbiw	r24, 0x00	; 0
    389a:	b9 f7       	brne	.-18     	; 0x388a <free+0x54>
    389c:	1f c0       	rjmp	.+62     	; 0x38dc <free+0xa6>
    389e:	e9 01       	movw	r28, r18
    38a0:	22 97       	sbiw	r28, 0x02	; 2
    38a2:	fb 83       	std	Y+3, r31	; 0x03
    38a4:	ea 83       	std	Y+2, r30	; 0x02
    38a6:	08 81       	ld	r16, Y
    38a8:	19 81       	ldd	r17, Y+1	; 0x01
    38aa:	c9 01       	movw	r24, r18
    38ac:	80 0f       	add	r24, r16
    38ae:	91 1f       	adc	r25, r17
    38b0:	8e 17       	cp	r24, r30
    38b2:	9f 07       	cpc	r25, r31
    38b4:	59 f4       	brne	.+22     	; 0x38cc <free+0x96>
    38b6:	80 81       	ld	r24, Z
    38b8:	91 81       	ldd	r25, Z+1	; 0x01
    38ba:	80 0f       	add	r24, r16
    38bc:	91 1f       	adc	r25, r17
    38be:	02 96       	adiw	r24, 0x02	; 2
    38c0:	99 83       	std	Y+1, r25	; 0x01
    38c2:	88 83       	st	Y, r24
    38c4:	82 81       	ldd	r24, Z+2	; 0x02
    38c6:	93 81       	ldd	r25, Z+3	; 0x03
    38c8:	9b 83       	std	Y+3, r25	; 0x03
    38ca:	8a 83       	std	Y+2, r24	; 0x02
    38cc:	41 15       	cp	r20, r1
    38ce:	51 05       	cpc	r21, r1
    38d0:	29 f4       	brne	.+10     	; 0x38dc <free+0xa6>
    38d2:	b0 93 67 05 	sts	0x0567, r27
    38d6:	a0 93 66 05 	sts	0x0566, r26
    38da:	41 c0       	rjmp	.+130    	; 0x395e <free+0x128>
    38dc:	fa 01       	movw	r30, r20
    38de:	b3 83       	std	Z+3, r27	; 0x03
    38e0:	a2 83       	std	Z+2, r26	; 0x02
    38e2:	c1 91       	ld	r28, Z+
    38e4:	d1 91       	ld	r29, Z+
    38e6:	ec 0f       	add	r30, r28
    38e8:	fd 1f       	adc	r31, r29
    38ea:	ae 17       	cp	r26, r30
    38ec:	bf 07       	cpc	r27, r31
    38ee:	81 f4       	brne	.+32     	; 0x3910 <free+0xda>
    38f0:	f9 01       	movw	r30, r18
    38f2:	92 91       	ld	r25, -Z
    38f4:	82 91       	ld	r24, -Z
    38f6:	8c 0f       	add	r24, r28
    38f8:	9d 1f       	adc	r25, r29
    38fa:	02 96       	adiw	r24, 0x02	; 2
    38fc:	da 01       	movw	r26, r20
    38fe:	11 96       	adiw	r26, 0x01	; 1
    3900:	9c 93       	st	X, r25
    3902:	8e 93       	st	-X, r24
    3904:	82 81       	ldd	r24, Z+2	; 0x02
    3906:	93 81       	ldd	r25, Z+3	; 0x03
    3908:	13 96       	adiw	r26, 0x03	; 3
    390a:	9c 93       	st	X, r25
    390c:	8e 93       	st	-X, r24
    390e:	12 97       	sbiw	r26, 0x02	; 2
    3910:	e0 e0       	ldi	r30, 0x00	; 0
    3912:	f0 e0       	ldi	r31, 0x00	; 0
    3914:	02 c0       	rjmp	.+4      	; 0x391a <free+0xe4>
    3916:	fb 01       	movw	r30, r22
    3918:	bc 01       	movw	r22, r24
    391a:	db 01       	movw	r26, r22
    391c:	12 96       	adiw	r26, 0x02	; 2
    391e:	8d 91       	ld	r24, X+
    3920:	9c 91       	ld	r25, X
    3922:	13 97       	sbiw	r26, 0x03	; 3
    3924:	00 97       	sbiw	r24, 0x00	; 0
    3926:	b9 f7       	brne	.-18     	; 0x3916 <free+0xe0>
    3928:	cb 01       	movw	r24, r22
    392a:	02 96       	adiw	r24, 0x02	; 2
    392c:	2d 91       	ld	r18, X+
    392e:	3c 91       	ld	r19, X
    3930:	11 97       	sbiw	r26, 0x01	; 1
    3932:	82 0f       	add	r24, r18
    3934:	93 1f       	adc	r25, r19
    3936:	20 91 64 05 	lds	r18, 0x0564
    393a:	30 91 65 05 	lds	r19, 0x0565
    393e:	28 17       	cp	r18, r24
    3940:	39 07       	cpc	r19, r25
    3942:	69 f4       	brne	.+26     	; 0x395e <free+0x128>
    3944:	30 97       	sbiw	r30, 0x00	; 0
    3946:	29 f4       	brne	.+10     	; 0x3952 <free+0x11c>
    3948:	10 92 67 05 	sts	0x0567, r1
    394c:	10 92 66 05 	sts	0x0566, r1
    3950:	02 c0       	rjmp	.+4      	; 0x3956 <free+0x120>
    3952:	13 82       	std	Z+3, r1	; 0x03
    3954:	12 82       	std	Z+2, r1	; 0x02
    3956:	70 93 65 05 	sts	0x0565, r23
    395a:	60 93 64 05 	sts	0x0564, r22
    395e:	df 91       	pop	r29
    3960:	cf 91       	pop	r28
    3962:	1f 91       	pop	r17
    3964:	0f 91       	pop	r16
    3966:	08 95       	ret

00003968 <_exit>:
    3968:	f8 94       	cli

0000396a <__stop_program>:
    396a:	ff cf       	rjmp	.-2      	; 0x396a <__stop_program>
