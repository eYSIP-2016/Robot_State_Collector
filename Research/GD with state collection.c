/*
*
* Team Id: GD#4768
* Author List: 	Amanpreet singh,Avilash Mohanty,K V S Sumakar,Harinder singh chouhan
* Filename:     GD#4768_Task_3 
* Theme: gas leakage detetction
* Functions: ADC_Conversion(),adc_init(),all_checked(),angle_rotate(),back(),back_line(),back_mm(),beep()
			converttomm_41sk(),blue_read(),buzzer_off(),buzzer_on(),color_sensor_pin_interrupt_init(),color_sensor_scaling(),
			colour_led(),colour_valve(),converttomm(),detect_wall(),drop(),filter_blue(),filter_clear(),filter_green(),
			filter_red(),forward(),forward_mm(),forward_node_2_node(),forward_the_end(),forward_till_wall(),glow1(),glow2(),glow3(),
			gotovalve(),gotovalve2(),green_read(),init_devices(),left(),left_degrees(),left_position_encoder_interrupt_init (),
			linear_distance_mm(),line_align(),line_align2(),line_follow_from_start(),line_follow_shaft(),line_follow_till_wall(),
			line_till_wall_detect(),motion_set(),node_2_node_rev(),off(),red_read(),rettog(),rev(),rev_the_end(),right(),right_degrees(),
			right_position_encoder_interrupt_init(),sensor_data_interpretation(),servo_1(),soft_left(),soft_left_degrees(),			
			soft_left(),soft_left_degrees(),spi_init(),spi_master_tx_and_rx(),stop(),timer1_init(),turn_no_wall(),uart2_init(),
			velocity()	


* Global Variables:	ShaftCountLeft,ShaftCountRight,Degrees,left_motor_velocity,right_motor_velocity   horz_servo_pos ,
				   vert_servo_pos , SHARP_3, SHARP_5,ADC_flag, ADC_Value,flag ,Left_white_line , Center_white_line ,
				   Right_white_line ,toggle ,ShaftCountLeft2,left_motor_pulse_count , left_motor_pulse_count_locked , 
				    right_motor_pulse_countC, right_motor_pulse_count_locked , pulse,red,blue, green,no_ff,servo_count,
					r,g,b,line_par,node.









*/


/*
*
* Function Name: 
* Input: 		
* Output: 		
* Logic: 		
* Example Call:		
*
*/


#include <avr/io.h>
#include <avr/interrupt.h>
#include <util/delay.h>
#include <math.h>

#include "lcd.c"
int wl=0;
int rnd=0;
int cntr=0;
int ctr=0;
int counter=0;
char abc[3];
unsigned long int ShaftCountLeft = 0; //to keep track of left position encoder 
unsigned long int ShaftCountRight = 0; //to keep track of right position encoder
unsigned int Degrees; //to accept angle in degrees for turning
unsigned char left_motor_velocity = 0x00;//To set the velocity of the left motor to 0
unsigned char right_motor_velocity = 0x00;//To set the velocity of the right motor to 0
unsigned char horz_servo_pos = 0x00;
unsigned char vert_servo_pos = 0x00;
unsigned char  WL_LEFT, WL_CENTER, WL_RIGHT,  SHARP_3,  SHARP_1, SHARP_5,IR3; 
				// SHARP_3:Stores the value read from sharp sensor at location 3
				// SHARP_5:Stores the value read from sharp sensor at location 5
unsigned char ADC_flag;
unsigned char ADC_Conversion(unsigned char);
unsigned char ADC_Value;
int read = 1;
unsigned char flag = 0,flag_2=0,flag_3=0;
				// WL_RIGHT:Stores the value read from right whiteline sensor
			
unsigned char Left_white_line = 0;	// WL_LEFT:Stores the value read from left whiteline sensor
unsigned char Center_white_line = 0;// WL_CENTER:Stores the value read from center whiteline sensor
unsigned char Right_white_line = 0;	// WL_RIGHT:Stores the value read from right whiteline sens
			
unsigned char Left_black_line = 0;	// WL_LEFT:Stores the value read from left whiteline sensor
unsigned char Center_black_line = 0;// WL_CENTER:Stores the value read from center whiteline sensor
unsigned char Right_black_line = 0;	// WL_RIGHT:Stores the value read from right whiteline sens
unsigned char toggle = 0;
unsigned int ShaftCountLeft2=0;//used to control the distance travelled by the robot
unsigned int ShaftCountRight2=0;//used to control the distance travelled by the robot
//Shaft encoder related variables
unsigned int left_motor_pulse_count = 0x00; 		//incremented at each isr
unsigned int left_motor_pulse_count_locked = 0x00;  // locked at serial comm isr

unsigned int right_motor_pulse_count = 0x00;        //incremented at each isr
unsigned int right_motor_pulse_count_locked = 0x00; // locked at serial comm isr


volatile unsigned long int pulse = 0; //to keep the track of the number of pulses generated by the color sensor
volatile unsigned long int red;       // variable to store the pulse count when read_red function is called
volatile unsigned long int blue;      // variable to store the pulse count when read_blue function is called
volatile unsigned long int green;     // variable to store the pulse count when read_green function is called
int count = 0;

int servo_count=180,r=2,g=2,b=2;//servo_count:used to control the location of external servo,initially it is at 180 degrees 
							    //r,b,g:variables to keep track if the colour/leakage has been detected/fixed or not
							    //these variables are initially set to 2 to signify that the leakage has not been detected
							    //if the leakage is detected the value of the corresponding variable is set to 1
							    //after the leakage is fixed the colour of the variable is changed to 0
int line_par=0;//This variable keeps track if in the condition where all the white line sensor variables
				// are of same magnitude what operation has to be performed
int node=0;	//as the bot moves in clockwise direction the value of node increases and resets to 0 when it returns to intial location

			//after the leakages have been detected the 4th valve in clockwise direction is set to zero
int counter_colour=0,colour_flag=0;;
int i_c=0,degree_count=0;
double a,d,c;
//-------------------------------------------------------------------------------
//*******************************************************************************
//-------------------------------------------------------------------------------
void motion_pin_config (void)
{
 DDRA = DDRA | 0x0F;   //set direction of the PORTA 3 to PORTA 0 pins as output
 PORTA = PORTA & 0xF0; // set initial value of the PORTA 3 to PORTA 0 pins to logic 0
 DDRL = DDRL | 0x18;   //Setting PL3 and PL4 pins as output for PWM generation
 PORTL = PORTL | 0x18; //PL3 and PL4 pins are for velocity control using PWM
}
//Configure PORTJ pins: 7,6,5,4 for RGB operation
void rgb_config()
{
	DDRJ= 0xF0;   //set direction of the PORTJ 4 to PORTJ 7 pins as output(Using PORTJ,J3 removed)
	PORTJ= 0xF0;  // set initial value of the PORTJ 4 to PORTJ 7 pins to logic 1
	              //ALL 4 PINS : COM,R,G,B are set as 1 initially
}

void color_sensor_pin_config(void)
{
	DDRD  = DDRD | 0xFE; //set PD0 as input for color sensor output
	PORTD = PORTD | 0x01;//Enable internal pull-up for PORTD 0 pin
}

//Configure PORTB 5 pin for servo motor 1 operation
void servo1_pin_config (void)
{
 DDRB  = DDRB | 0x20;  //making PORTB 5 pin output
 PORTB = PORTB | 0x20; //setting PORTB 5 pin to logic 1
}


void spi_pin_config (void)
{
 DDRB = DDRB | 0x07;
 PORTB = PORTB | 0x07;
}


void lcd_port_config (void)
{
 DDRC = DDRC | 0xF7;    //all the LCD pin's direction set as output
 PORTC = PORTC & 0x80;  // all the LCD pins are set to logic 0 except PORTC 7
}

//Function to initialize Buzzer 
void buzzer_pin_config (void)
{
 DDRC = DDRC | 0x08;		//Setting PORTC 3 as output
 PORTC = PORTC & 0xF7;		//Setting PORTC 3 logic low to turnoff buzzer
}

//Function to configure INT4 (PORTE 4) pin as input for the left position encoder
void left_encoder_pin_config (void)
{
 DDRE  = DDRE & 0xEF;  //Set the direction of the PORTE 4 pin as input
 PORTE = PORTE | 0x10; //Enable internal pull-up for PORTE 4 pin
}

//Function to configure INT5 (PORTE 5) pin as input for the right position encoder
void right_encoder_pin_config (void)
{
 DDRE  = DDRE & 0xDF;  //Set the direction of the PORTE 4 pin as input
 PORTE = PORTE | 0x20; //Enable internal pull-up for PORTE 4 pin
}

//ADC pin configuration
void adc_pin_config (void)
{
 DDRF = 0x00;  //set PORTF direction as input
 PORTF = 0x00; //set PORTF pins floating
 DDRK = 0x00;  //set PORTK direction as input
 PORTK = 0x00; //set PORTK pins floating
}

//Port init for different modules
void port_init(void)
{
 motion_pin_config();
 servo1_pin_config();
 spi_pin_config();
 lcd_port_config();
 buzzer_pin_config();           
 left_encoder_pin_config();
 right_encoder_pin_config();
 adc_pin_config();
 color_sensor_pin_config();//color sensor pin configuration
 rgb_config();	 
}

// Timer 5 initialized in PWM mode for velocity control
// Prescale:256
// PWM 8bit fast, TOP=0x00FF
// Timer Frequency:225.000Hz
void timer5_init()
{
	TCCR5B = 0x00;	//Stop
	TCNT5H = 0xFF;	//Counter higher 8-bit value to which OCR5xH value is compared with
	TCNT5L = 0x01;	//Counter lower 8-bit value to which OCR5xH value is compared with
	OCR5AH = 0x00;	//Output compare register high value for Left Motor
	OCR5AL = 0xFF;	//Output compare register low value for Left Motor
	OCR5BH = 0x00;	//Output compare register high value for Right Motor
	OCR5BL = 0xFF;	//Output compare register low value for Right Motor
	OCR5CH = 0x00;	//Output compare register high value for Motor C1
	OCR5CL = 0xFF;	//Output compare register low value for Motor C1
	TCCR5A = 0xA9;	/*{COM5A1=1, COM5A0=0; COM5B1=1, COM5B0=0; COM5C1=1 COM5C0=0}
 					  For Overriding normal port functionality to OCRnA outputs.
				  	  {WGM51=0, WGM50=1} Along With WGM52 in TCCR5B for Selecting FAST PWM 8-bit Mode*/
	
	TCCR5B = 0x0B;	//WGM12=1; CS12=0, CS11=1, CS10=1 (Prescaler=64)
}

void velocity(unsigned char left_motor,unsigned char right_motor)
{
	OCR5AL=(unsigned char)left_motor;//The Output Compare register is used to generate an Interrupt after the number of clock ticks written to it.
	                                 // It is permanently compared to TCNT5. When both match, the compare match interrupt is triggered.
									
	OCR5BL=(unsigned char)right_motor;//When these values are equal to each other, the Output Compare Interrupt Flag is set and an ISR can be called,
									  //And Hence the duty cycle(Hence the power provided to motors) can be changed according to need.
}

void color_sensor_pin_interrupt_init(void) //Interrupt 0 enable
{
	cli(); //Clears the global interrupt
	EICRA = EICRA | 0x02; // INT0 is set to trigger with falling edge
	EIMSK = EIMSK | 0x01; // Enable Interrupt INT0 for color sensor
	sei(); // Enables the global interrupt
}

ISR(INT0_vect)
{
	pulse++; //increment on receiving pulse from the color sensor
}
//TIMER1 initialize - prescale:256
// WGM: 7) PWM 10bit fast, TOP=0x03FF
// desired value: 40Hz
// actual value: 42.187Hz (5.2%)
void timer1_init(void)
{
 TCCR1B = 0x00; //stop
 TCNT1H = 0xFC; //Counter high value to which OCR1xH value is to be compared with
 TCNT1L = 0x01;	//Counter low value to which OCR1xH value is to be compared with
 OCR1AH = 0x03;	//Output compare Register high value for servo 1
 OCR1AL = 0xFF;	//Output Compare Register low Value For servo 1
 OCR1BH = 0x03;	//Output compare Register high value for servo 2
 OCR1BL = 0xFF;	//Output Compare Register low Value For servo 2
 OCR1CH = 0x03;	//Output compare Register high value for servo 3
 OCR1CL = 0xFF;	//Output Compare Register low Value For servo 3
 ICR1H  = 0x03;	
 ICR1L  = 0xFF;
 TCCR1A = 0xAB; /*{COM1A1=1, COM1A0=0; COM1B1=1, COM1B0=0; COM1C1=1 COM1C0=0}
 					For Overriding normal port functionality to OCRnA outputs.
				  {WGM11=1, WGM10=1} Along With WGM12 in TCCR1B for Selecting FAST PWM Mode*/
 TCCR1C = 0x00;
 TCCR1B = 0x0C; //WGM12=1; CS12=1, CS11=0, CS10=0 (Prescaler=256)
}

//TIMER4 initialize - prescale:1024
// WGM: 0) Normal, TOP=0xFFFF
// desired value: 1Hz
// actual value:  1.000Hz (0.0%)
void timer4_init(void)
{
 TCCR4B = 0x00; //stop
 TCNT4H = 0x1F; //Counter higher 8 bit value
 TCNT4L = 0x01; //Counter lower 8 bit value
 OCR4AH = 0x00; //Output Compair Register (OCR)- Not used
 OCR4AL = 0x00; //Output Compair Register (OCR)- Not used
 OCR4BH = 0x00; //Output Compair Register (OCR)- Not used
 OCR4BL = 0x00; //Output Compair Register (OCR)- Not used
 OCR4CH = 0x00; //Output Compair Register (OCR)- Not used
 OCR4CL = 0x00; //Output Compair Register (OCR)- Not used
 ICR4H  = 0x00; //Input Capture Register (ICR)- Not used
 ICR4L  = 0x00; //Input Capture Register (ICR)- Not used
 TCCR4A = 0x00; 
 TCCR4C = 0x00;
 TCCR4B = 0x04; //start Timer
}


/*
*
* Function Name:converttomm_41sk 
* Input: value of sharp sensor 5 at that instant 
* Output: Converts the sharp sensor readings into mm and returns it.		
* Logic: From the datasheet of the sharp sensor the formula for conversion for the given
		 model of sharp sensor has been obtained.This formula converts the input value into
		 mm.
* Example Call:distance=converttomm_41sk(SHARP_5)		
*
*/


unsigned int converttomm_41sk(unsigned int a)
{
  double b;
  b=a;
  b = b*0.001240875;
  b = b+0.005;
  b = 10/b;
  b = b-24.2;
  b = (int)b; 
  return b;
}

void sensor_data_interpretation(void) //ld, fd, rd, light int
{
 
 WL_LEFT = ADC_Conversion(3);
  
 WL_CENTER = ADC_Conversion(2);
  
 WL_RIGHT = ADC_Conversion(1);
 
 SHARP_3 = ADC_Conversion(11);
 
 SHARP_1 = ADC_Conversion(9);
 
 SHARP_5 = ADC_Conversion(13);
 
 IR3= ADC_Conversion(6);
  
}


void send ( int n)
{ 
  int z = 0;
  int c = n;
  abc[0] = 0;
  abc[1] = 0;
  abc[2] = 0;
  while (c) 
 { // loop till there's nothing left
    abc[z++] = (char)(c % 10); // assign the last digit
    c /= 10; // "right shift" the number
 }
 _delay_ms(10);
 UDR0 = abc[2] + 48;
 UDR0 = abc[1] + 48;
 _delay_ms(10);
 UDR0 = abc[0] + 48;
 UDR0 = 32;
}

ISR(TIMER4_OVF_vect)
{
 lcd_print(1, 1, count, 3);
 TCNT4H = 0x1F; //reload counter high value
 TCNT4L = 0x01; //reload counter low value
 if (read == 1)
 {
  sensor_data_interpretation();
  send(converttomm_41sk(SHARP_1));
  send(WL_LEFT);
  send(WL_CENTER);
  send(WL_RIGHT);
  count++;
 }   
} 


//Function To Initialize UART0
// desired baud rate:9600
// actual baud rate:9600 (error 0.0%)
// char size: 8 bit
// parity: Disabled
void uart0_init(void)
{
 UCSR0B = 0x00; //disable while setting baud rate
 UCSR0A = 0x00;
 UCSR0C = 0x06;
 UBRR0L = 0x5F; //set baud rate lo
 UBRR0H = 0x00; //set baud rate hi
 UCSR0B = 0x98;
}






int rettog ()
{
  return toggle;
}

void buzzer_on(void)
{
 unsigned char portc_restore = 0;
 portc_restore = PORTC; // reading the PORTC original status
 portc_restore |= 0x08; // setting the bit to turn on the buzzer
 PORTC = portc_restore; // executing the command
 lcd_print(2,13,rettog(),1);
}

//-------------------------------------------------------------------------------
//------ Function For Buzzer OFF -------------
//-------------------------------------------------------------------------------
void buzzer_off(void)
{
 unsigned char portc_restore = 0;
 portc_restore = PORTC; // reading the PORTC original status
 portc_restore &= 0xF7; // resetting the bit to turn off the buzzer
 PORTC = portc_restore; // executing the command
}





//SPI initialize
// clock rate: 921600hz
void spi_init(void)
{
 SPCR = 0x53; //setup SPI
 SPSR = 0x00; //setup SPI
 SPDR = 0x00;
}

//ADC initialize
// Conversion time: 56uS
void adc_init(void)
{
	ADCSRA = 0x00;
	ADCSRB = 0x00;		//MUX5 = 0
	ADMUX = 0x20;		//Vref=5V external --- ADLAR=1 --- MUX4:0 = 0000
	ACSR = 0x80;
	ADCSRA = 0x86;		//ADEN=1 --- ADIE=1 --- ADPS2:0 = 1 1 0
}

//-------------------------------------------------------------------------------
void left_position_encoder_interrupt_init (void) //Interrupt 4 enable
{
 cli(); //Clears the global interrupt
 EICRB = EICRB | 0x02; // INT4 is set to trigger with falling edge
 EIMSK = EIMSK | 0x10; // Enable Interrupt INT4 for left position encoder
 sei();   // Enables the global interrupt 
}

void right_position_encoder_interrupt_init (void) //Interrupt 5 enable
{
 cli(); //Clears the global interrupt
 EICRB = EICRB | 0x08; // INT5 is set to trigger with falling edge
 EIMSK = EIMSK | 0x20; // Enable Interrupt INT5 for right position encoder
 sei();   // Enables the global interrupt 
}

//-------------------------------------------------------------------------------
//ISR for right position encoder
//-------------------------------------------------------------------------------

ISR(INT5_vect)  
{
 ShaftCountRight++;//increment Right shaft position count
 ShaftCountLeft2++;// counter variable incremented in ISR(INT5_vect),Triggered when OCR5Al,OCR5BL matches( i.e. Changes in accordance to velocity)
}


//ISR for left position encoder
ISR(INT4_vect)
{
 ShaftCountLeft++;
   //increment left shaft position count
}

//-------------------------------------------------------------------------------
//-- ADC Conversion Function --------------
//-------------------------------------------------------------------------------
unsigned char ADC_Conversion(unsigned char ch)
{
unsigned char a;
 if(ch>7)
	{
		ADCSRB = 0x08;
	}
 ch = ch & 0x07;			  //Store only 3 LSB bits
 ADMUX= 0x20 | ch;			  //Select the ADC channel with left adjust select
 ADC_flag = 0x00; 			  //Clear the user defined flag
 ADCSRA = ADCSRA | 0x40;	  //Set start conversion bit
 while((ADCSRA&0x10)==0);	  //Wait for ADC conversion to complete
 a=ADCH;
 ADCSRA = ADCSRA|0x10;        //clear ADIF (ADC Interrupt Flag) by writing 1 to it
 ADCSRB = 0x00;
 return a;
}

//-------------------------------------------------------------------------------
//-- Function To Transmit/Receive through SPI interface ------
//-------------------------------------------------------------------------------
unsigned char spi_master_tx_and_rx (unsigned char data)
{
 unsigned char rx_data = 0;

 PORTB = PORTB & 0xFE;        // make SS pin low
 SPDR = data;
 while(!(SPSR & (1<<SPIF)));  //wait for data transmission to complete

 _delay_ms(1);                //time for ADC conversion in the slave microcontroller
 
 SPDR = 0x50;                 // send dummy byte to read back data from the slave microcontroller
 while(!(SPSR & (1<<SPIF)));  //wait for data reception to complete
 rx_data = SPDR;
 PORTB = PORTB | 0x01;        // make SS high
 return rx_data;
}

//-------------------------------------------------------------------------------



//-------------------------------------------------------------------------------
//------Function used for setting motor's direction----------
//-------------------------------------------------------------------------------
void motion_set(unsigned char ucDirection)
{
 unsigned char ucPortARestore = 0;

 ucDirection &= 0x0F;            // removing upper nibbel for the protection
 ucPortARestore = PORTA;         // reading the PORTA original status
 ucPortARestore &= 0xF0;         // making lower direction nibbel to 0
 ucPortARestore |= ucDirection;  // adding lower nibbel for forward command and restoring the PORTA status
 PORTA = ucPortARestore;         // executing the command
}

void forward(void) 
{ 
 motion_set(0x06);
}

void back(void)  
{
  motion_set(0x09);  
}

void left(void)  
{
  motion_set(0x05);
}

void right(void)
{
  motion_set(0x0A);
}

void stop(void)
{
  motion_set(0x00);
}


void soft_left (void) //Left wheel stationary, Right wheel forward
{
 motion_set(0x04);
}

void soft_right (void) //Left wheel forward, Right wheel is stationary
{
 motion_set(0x02);
}

void angle_rotate(unsigned int Degrees)
{
 float ReqdShaftCount = 0;
 unsigned long int ReqdShaftCountInt = 0;

 ReqdShaftCount = (float) Degrees/ 4.090; // division by resolution to get shaft count
 ReqdShaftCountInt = (unsigned int) ReqdShaftCount;
 ShaftCountRight = 0; 
 ShaftCountLeft = 0; 

 while (1)
 {
  if((ShaftCountRight >= ReqdShaftCountInt) | (ShaftCountLeft >= ReqdShaftCountInt))
  break;
 }
 stop(); //Stop robot
}

void soft_left_degrees(unsigned int Degrees)
{
 // 176 pulses for 360 degrees rotation 2.045 degrees per count
 soft_left(); //Turn soft left
 Degrees=Degrees*2;
 angle_rotate(Degrees);
}

void soft_right_degrees(unsigned int Degrees)
{
 // 176 pulses for 360 degrees rotation 2.045 degrees per count
 soft_right();  //Turn soft right
 Degrees=Degrees*2;
 angle_rotate(Degrees);
}

//-------------------------------------------------------------------------------
//call this routine to initialize all peripherals
void init_devices(void)
{
 //stop errant interrupts until set up
 cli();              //disable all interrupts
 port_init();
 adc_init();
 timer1_init();
 timer5_init();
 lcd_set_4bit();
 color_sensor_pin_interrupt_init();
 lcd_init();
 spi_init();
 timer4_init();
 uart0_init(); //Initailize UART1 for serial communiaction
 TIMSK4 = 0x01;
 // below for lines are important for Encoder init
 left_position_encoder_interrupt_init();
 right_position_encoder_interrupt_init();
 EICRB  = 0x0A;     //pin change int edge 4:7

 sei();             //re-enable interrupts
 //all peripherals are now initialized
}




void linear_distance_mm(unsigned int DistanceInMM)
{
 float ReqdShaftCount = 0;
 unsigned long int ReqdShaftCountInt = 0;

 ReqdShaftCount = DistanceInMM / 5.338; // division by resolution to get shaft count
 ReqdShaftCountInt = (unsigned long int) ReqdShaftCount;
  
 ShaftCountRight = 0;
 while(1)
 {
  if(ShaftCountRight > ReqdShaftCountInt)
  {
  	break;
  }
 } 
 stop(); //Stop robot
}


void forward_mm(unsigned int DistanceInMM)
{
 forward();
 linear_distance_mm(DistanceInMM);
}

void right_degrees(unsigned int Degrees)
{
// 88 pulses for 360 degrees rotation 4.090 degrees per count
 right(); //Turn right
 angle_rotate(Degrees);
}

void left_degrees(unsigned int Degrees) 
{
// 88 pulses for 360 degrees rotation 4.090 degrees per count
 left(); //Turn left
 angle_rotate(Degrees);
}






/*
*
* Function Name:converttomm 
* Input: value of sharp sensor 3 at that instant 
* Output: Converts the sharp sensor readings into mm and returns it.		
* Logic: From the datasheet of the sharp sensor the formula for conversion for the given
		 model of sharp sensor has been obtained.This formula converts the input value into
		 mm.
* Example Call:distance=converttomm(SHARP_3)		
*
*/
unsigned int converttomm(unsigned int a )
{
  double b;
  b=a;
  b=pow(b,1.1546);
  b=1/b;
  b=b*2799.6;
  b=10*b;
  b=(int) b;
  return b;

}


//Filter Selection
void filter_red(void)    //Used to select red filter
{
	//Filter Select - red filter
	PORTD = PORTD & 0xBF; //set S2 low
	PORTD = PORTD & 0x7F; //set S3 low
}

void filter_green(void)	//Used to select green filter
{
	//Filter Select - green filter
	PORTD = PORTD | 0x40; //set S2 High
	PORTD = PORTD | 0x80; //set S3 High
}

void filter_blue(void)	//Used to select blue filter
{
	//Filter Select - blue filter
	PORTD = PORTD & 0xBF; //set S2 low
	PORTD = PORTD | 0x80; //set S3 High
}

void filter_clear(void)	//select no filter
{
	//Filter Select - no filter
	PORTD = PORTD | 0x40; //set S2 High
	PORTD = PORTD & 0x7F; //set S3 Low
}

//Color Sensing Scaling
void color_sensor_scaling()		//This function is used to select the scaled down version of the original frequency of the output generated by the color sensor, generally 20% scaling is preferable, though you can change the values as per your application by referring datasheet
{
	//Output Scaling 20% from datasheet
	//PORTD = PORTD & 0xEF;
	PORTD = PORTD | 0x10; //set S0 high
	//PORTD = PORTD & 0xDF; //set S1 low
	PORTD = PORTD | 0x20; //set S1 high
}




/*
*
* Function Name:red_read 		
* Output:Counts the number of pulses of red colour in 100ms and stores theem in variable red 		
* Logic: The value of pulse increases from 0 to a certain value (individual for each colour) in a given time period
		this is stored in corresponding variable to be compared		
* Example Call:red_read();		
*
*/

void red_read(void) // function to select red filter and display the count generated by the sensor on LCD. The count will be more if the color is red. The count will be very less if its blue or green.
{
	//Red
	filter_red(); //select red filter
	pulse=0; //reset the count to 0
	_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	red = pulse;  //store the count in variable called red
	
	lcd_cursor(1,1);  //set the cursor on row 1, column 1
	lcd_string("Red Pulses"); // Display "Red Pulses" on LCD
	lcd_print(2,1,red,5);  //Print the count on second row
	lcd_wr_command(0x01); //Clear the LCD*/
}

/*
*
* Function Name:green_read 		
* Output:Counts the number of pulses of green colour in 100ms and stores theem in variable green 		
* Logic: The value of pulse increases from 0 to a certain value (individual for each colour) in a given time period
		this is stored in corresponding variable to be compared		
* Example Call:green_read();		
*
*/
void green_read(void) // function to select green filter and display the count generated by the sensor on LCD. The count will be more if the color is green. The count will be very less if its blue or red.
{
	//Green
	filter_green(); //select green filter
	pulse=0; //reset the count to 0
	_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	green = pulse;  //store the count in variable called green
	
	lcd_cursor(1,1);  //set the cursor on row 1, column 1
	lcd_string("Green Pulses"); // Display "Green Pulses" on LCD
	lcd_print(2,1,green,5);  //Print the count on second row
	lcd_wr_command(0x01); //Clear the LCD*/
}

/*
*
* Function Name:blue_read 		
* Output:Counts the number of pulses of blue colour in 100ms and stores theem in variable blue	
* Logic: The value of pulse increases from 0 to a certain value (individual for each colour) in a given time period
		this is stored in corresponding variable to be compared		
* Example Call:blue_read();		
*
*/
void blue_read(void) // function to select blue filter and display the count generated by the sensor on LCD. The count will be more if the color is blue. The count will be very less if its red or green.
{
	//Blue
	filter_blue(); //select blue filter
	pulse=0; //reset the count to 0
	_delay_ms(100);
	blue = pulse;  //store the count in variable called blue

	lcd_cursor(1,1);  //set the cursor on row 1, column 1
	lcd_string("Blue Pulses"); // Display "Blue Pulses" on LCD
	lcd_print(2,1,blue,5);  //Print the count on second row
	lcd_wr_command(0x01); //Clear the LCD*/
}

/*
* Function Name: glow1()
* Input : none
* Output :Glows RGB LED in red colour
* Logic: Sets Red colour's pin as 0,and COM=G=B=1
* Example Call: glow1(); to glow RGB LED in RED colour
*/ 


void glow1()
{
	
	PORTJ= 0xB0;       //PORTJ 6 set to logic 0,PORTJ 7,5,4 set to logic 1
	lcd_string("red"); //Prints "red" on the LCD screen
	//_delay_ms(2000);
	
}
/*
* Function Name: glow2()
* Input : none
* Output :Glows RGB LED in Blue colour
* Logic: Sets Blue colour's pin as 0,and COM=G=R=1
* Example Call: glow2(); to glow RGB LED in BLUE colour
*/ 
void glow2()
{
	
	PORTJ= 0xD0;       //PORTJ 5 set to logic 0,PORTJ 7,6,4 set to logic 1
	lcd_string("blue");//Prints "blue" on the LCD screen
//	_delay_ms(3000);
	
}
/*
* Function Name: glow3()
* Input : none
* Output :Glows RGB LED in green colour
* Logic: Sets Green colour's pin as 0,and COM=R=B=1
* Example Call: glow3(); to glow RGB LED in GREEN colour
*/ 
void glow3()
{
	
	PORTJ= 0x70;        //PORTJ 7 set to logic 0,PORTJ 6,5,4 set to logic 1
	lcd_string("green");//Prints "green" on the LCD screen
//	_delay_ms(3000);
	
}

/*
* Function Name: off()
* Input : none
* Output :RGB LED is switched off
* Logic: Sets Red colour's pin as 0,and COM=G=B=1
* Example Call: off();To switch off the RGB LED.
*/ 

void off()
{
	
	PORTJ= 0xF0;       // Resets all the PORTJ upper nibble pins to logic 1(OFF STATE)
	lcd_string("off");
	//_delay_ms(3000);

}

//****************************************************************************
//BLACK LINE FOLLOWER
//****************************************************************************




/*
*
* Function Name: line_follow		
* Output:Three whiteline sensors read the values from ground and try to align the bot along a white line 		
*Problem:The width of black line provided to us is less than the distance between the sensors this is tackled by using a flag which is used to remeber
		the last turn the robot took	
* Logic: If the left sensor reads black the bot turns left
		If the right sensor reads black the bot turns right
		if all the sensors show white and the last turn taken was
			left:the bot needs to turn right
			right:the bot needs to turn left	
		if the center sensor reads black and all other sensors are white the bot moves forward	
* Example Call:	line_follow()	
*
*/


void line_follow()
{line_par=0;
ctr=0;

sensor_data_interpretation();
		Left_white_line = ADC_Conversion(3);	//Getting data of Left WL Sensor
		Center_white_line = ADC_Conversion(2);	//Getting data of Center WL Sensor
		Right_white_line = ADC_Conversion(1);	//Getting data of Right WL Sensor

		lcd_print(1,1,Left_white_line ,3);	//Prints value of White Line Sensor1
		lcd_print(1,5,Center_white_line,3);	//Prints Value of White Line Sensor2
		lcd_print(1,9,Right_white_line ,3);	//Prints Value of White Line Sensor3
		lcd_print(2,1,flag ,1);


		if((Left_white_line>10) && (Center_white_line<=10))
		{			
			soft_left_degrees(4);
			flag=1;
			ShaftCountRight2=0;
		}

		if((Right_white_line>25) && (Center_white_line<=10))
		{
			soft_right_degrees(4);
			flag=2;
			ShaftCountRight2=0;
		}

        if((Right_white_line<=25) && (Left_white_line<=10) && (Center_white_line>10) )
		{
		    forward();
			velocity(255,255);
			flag=0;
			ShaftCountRight2=0;
		}
        
		if((Right_white_line<=25) && (Left_white_line<=10) && (Center_white_line<10) &&(flag!=1))
		{
		    soft_right_degrees(3);
			flag=3;
			line_par=1;
			ctr++;
			if(ShaftCountRight2==4)
			{
			  
			  ShaftCountLeft2=ShaftCountLeft2+15;
			  //forward_mm(15);
			}
			
			ShaftCountRight2++;
			//degree_count=degree_count+3;
			//continue;
		}
		
        if((Right_white_line<=25) && (Left_white_line<=10) && (Center_white_line<=10) &&(flag!=2)&&(line_par==0))
		{
		    soft_left_degrees(3);
			flag=3;
				if(ShaftCountRight2==3)
			{
			  ShaftCountLeft2=ShaftCountLeft2+15;
			 // forward_mm(15);
			}
			ShaftCountRight2++;
			//continue;
		}

		 if((Right_white_line >=50) && (Left_white_line<=10) && (Center_white_line>10) )
		{   

		   lcd_init();
		   lcd_cursor(1,5);
		   lcd_string("Changed Cond");
		   forward_mm(20);
		}
        
}
void align()
{sensor_data_interpretation();
Center_white_line = ADC_Conversion(2);
while((Center_white_line<40)||(Left_white_line>0x28))
{
line_follow();
}


}

void read_black_line_read()
{
	
	Left_black_line = ADC_Conversion(3);	//Getting data of Left WL Sensor
	Center_black_line = ADC_Conversion(2);	//Getting data of Center WL Sensor
	Right_black_line = ADC_Conversion(1);	//Getting data of Right WL Sensor

}

void fln_shaft(int dist)
{
    sensor_data_interpretation();
  	forward();
	lcd_init();
	lcd_cursor(1,1);
	lcd_string("FLN SHAFT");
	sensor_data_interpretation();
	ShaftCountLeft2=0;
	read_black_line_read();
	 while(ShaftCountLeft2<dist/5.338)
	{

		Left_black_line = ADC_Conversion(3);	//Getting data of Left WL Sensor
		Center_black_line = ADC_Conversion(2);	//Getting data of Center WL Sensor
		Right_black_line = ADC_Conversion(1);	//Getting data of Right WL Sensor

		flag=0;
		counter=0;
		
		

		if((Center_black_line>0x28)&&(Left_black_line<0x28)&&(Right_black_line<0x28))
		{
			flag=1;
			forward();
			velocity(251,253);
		}

		if((Left_black_line>0x28) && (flag==0))
		{
			counter=1;
			flag=1;
			forward();
			velocity(50,150);
		}

		if((Right_black_line>0x28) && (flag==0))
		{
			counter=2;
			flag=1;
			forward();
			velocity(150,50);
		}

		if(Center_black_line<0x28 && Left_black_line<0x28 && Right_black_line<0x28)
		{
			switch(counter)
			{	case 1:
					forward();
					velocity(130,0);
					if((Center_black_line>0x28)&&(Left_black_line<0x28)&&(Right_black_line<0x28))
					{
						flag=1;
						forward();
						velocity(251,253);
					    break;
					}
					
				case 2:
					forward();
					velocity(0,130);
					if((Center_black_line>0x28)&&(Left_black_line<0x28)&&(Right_black_line<0x28))
					{
						flag=1;
						forward();
						velocity(251,253);
						break;
					}
					
			}			

			if((Left_black_line>0x28) && (flag==0))
			{
				flag=1;
				forward();
				velocity(50,150);
			}

			if((Right_black_line>0x28) && (flag==0))
			{
				flag=1;
				forward();
				velocity(150,50);
			}
		}
		sensor_data_interpretation();
	}
	stop();
}

void fln_wall()
{
	lcd_init();
	lcd_cursor(1,1);
	lcd_string("FLN WALL");
	sensor_data_interpretation();
	forward();
	ShaftCountLeft2=0;
	read_black_line_read();
	 while(converttomm(SHARP_3)>=180)
	{
        lcd_print(2,5,converttomm(SHARP_3),3);
		Left_black_line = ADC_Conversion(3);	//Getting data of Left WL Sensor
		Center_black_line = ADC_Conversion(2);	//Getting data of Center WL Sensor
		Right_black_line = ADC_Conversion(1);	//Getting data of Right WL Sensor

		flag=0;
		counter=0;
		
		

		if((Center_black_line>0x28)&&(Left_black_line<0x28)&&(Right_black_line<0x28))
		{
			flag=1;
			forward();
			velocity(251,253);
		}
		sensor_data_interpretation();
		if(converttomm(SHARP_3)<170)
		 break;
		
		if((Left_black_line>0x28) && (flag==0))
		{
			counter=1;
			flag=1;
			forward();
			velocity(50,150);
		}
		sensor_data_interpretation();
    	if(converttomm(SHARP_3)<170)
		 break;

		if((Right_black_line>0x28) && (flag==0))
		{
			counter=2;
			flag=1;
			forward();
			velocity(150,50);
		}
		sensor_data_interpretation();
		if(converttomm(SHARP_3)<170)
		 break;
		
		if(Center_black_line<0x28 && Left_black_line<0x28 && Right_black_line<0x28)
		{
			switch(counter)
			{	case 1:
					forward();
					velocity(130,0);
					if((Center_black_line>0x28)&&(Left_black_line<0x28)&&(Right_black_line<0x28))
					{
						flag=1;
						forward();
						velocity(251,253);
					    break;
					} 
                    sensor_data_interpretation();
					if(converttomm(SHARP_3)<170)
		                    break;
					
				case 2:
					forward();
					velocity(0,130);
					if((Center_black_line>0x28)&&(Left_black_line<0x28)&&(Right_black_line<0x28))
					{
						flag=1;
						forward();
						velocity(251,253);
						break;
					}
					sensor_data_interpretation();
    		    	if(converttomm(SHARP_3)<170)
	        	     break;	
			}			

			if((Left_black_line>0x28) && (flag==0))
			{
				flag=1;
				forward();
				velocity(50,150);
				sensor_data_interpretation();
				if(converttomm(SHARP_3)<170)
	        	     break;	
			}

			if((Right_black_line>0x28) && (flag==0))
			{
				flag=1;
				forward();
				velocity(150,50);
				sensor_data_interpretation();
				if(converttomm(SHARP_3)<170)
	        	     break;	
			}
		}
		sensor_data_interpretation();
	}
	stop();
}


void line_follow_2()
{line_par=0;

sensor_data_interpretation();
		Left_white_line = ADC_Conversion(3);	//Getting data of Left WL Sensor
		Center_white_line = ADC_Conversion(2);	//Getting data of Center WL Sensor
		Right_white_line = ADC_Conversion(1);	//Getting data of Right WL Sensor

		lcd_print(1,1,Left_white_line ,3);	//Prints value of White Line Sensor1
		lcd_print(1,5,Center_white_line,3);	//Prints Value of White Line Sensor2
		lcd_print(1,9,Right_white_line ,3);	//Prints Value of White Line Sensor3
		lcd_print(2,1,flag ,1);


		if((Left_white_line>10) && (Center_white_line<=10))
		{			
			soft_left_degrees(4);
			flag=1;
			ShaftCountRight2=0;
		}

		if((Right_white_line>40) && (Center_white_line<=10))
		{
			soft_right_degrees(4);
			flag=2;
			ShaftCountRight2=0;
		}

        if((Right_white_line<=40) && (Left_white_line<=10) && (Center_white_line>10) )
		{
		    forward();
			velocity(255,255);
			flag=0;
			ShaftCountRight2=0;
		}
        
		if((Right_white_line<=40) && (Left_white_line<=10) && (Center_white_line<10) &&(flag!=1))
		{
		    soft_right_degrees(3);
			flag=3;
			line_par=1;
			if(ShaftCountRight2==4)
			{
			  ShaftCountLeft2=ShaftCountLeft2+15;
			  //forward_mm(15);
			}
			
			ShaftCountRight2++;
			
			//continue;
		}
		
        if((Right_white_line<=40) && (Left_white_line<=10) && (Center_white_line<=10) &&(flag!=2)&&(line_par==0))
		{
		    soft_left_degrees(3);
			flag=3;
				if(ShaftCountRight2==3)
			{
			  ShaftCountLeft2=ShaftCountLeft2+15;
			 // forward_mm(15);
			}
			ShaftCountRight2++;
			//continue;
		}

		 if((Right_white_line >=50) && (Left_white_line<=10) && (Center_white_line>10) )
		{   

		   lcd_init();
		   lcd_cursor(1,5);
		   lcd_string("Changed Cond");
		   forward_mm(20);
		}
        
}


/*
void line_follow_2()
{line_par=0;

sensor_data_interpretation();
		Left_white_line = ADC_Conversion(3);	//Getting data of Left WL Sensor
		Center_white_line = ADC_Conversion(2);	//Getting data of Center WL Sensor
		Right_white_line = ADC_Conversion(1);	//Getting data of Right WL Sensor

		lcd_print(1,1,Left_white_line ,3);	//Prints value of White Line Sensor1
		lcd_print(1,5,Center_white_line,3);	//Prints Value of White Line Sensor2
		lcd_print(1,9,Right_white_line ,3);	//Prints Value of White Line Sensor3
		lcd_print(2,1,flag ,1);


		if((Left_white_line>10) && (Center_white_line<=10))
		{			
			soft_left_degrees(4);
			flag=1;
			ShaftCountRight2=0;
		}

		if((Right_white_line>15) && (Center_white_line<=10))
		{
			soft_right_degrees(4);
			flag=2;
			ShaftCountRight2=0;
		}

        if((Right_white_line<=15) && (Left_white_line<=10) && (Center_white_line>10) )
		{
		    forward();
			velocity(255,255);
			flag=0;
			ShaftCountRight2=0;
		}
        
		if((Right_white_line<=15) && (Left_white_line<=10) && (Center_white_line<10) &&(flag!=1))
		{
		    soft_left_degrees(3);
			flag=3;
			line_par=1;
				if(ShaftCountRight2==3)
			{
			  ShaftCountLeft2=ShaftCountLeft2+15;
			  //forward_mm(15);
			}
			ShaftCountRight2++;
			//continue;
		}
		
        if((Right_white_line<=15) && (Left_white_line<=10) && (Center_white_line<=10) &&(flag!=2)&&(line_par==0))
		{
		    soft_right_degrees(3);
			flag=3;
				if(ShaftCountRight2==3)
			{
			  ShaftCountLeft2=ShaftCountLeft2+15;
			 // forward_mm(15);
			}
			ShaftCountRight2++;
			//continue;
		}

		 if((Right_white_line >=50) && (Left_white_line<=10) && (Center_white_line>10) )
		{   

		   lcd_init();
		   lcd_cursor(1,5);
		   lcd_string("Changed Cond");
		   forward_mm(20);
		}
        
}
*/
//****************************************************************************
//END BLACK LINE FOLLOWER
//****************************************************************************


 /*
* Function Name: line_follow_shaft()
* Input : dist integer variable 
* Output :follows black line for the given distance
* Logic: as the bot moves the shaft count increases this function is used to follow black line till the distance is covered
* Example Call: line_follow_shaft(100); to follow blackline for 100mm
*/ 

void line_follow_shaft(int dist)
{
	 sensor_data_interpretation();
    ShaftCountLeft2=0;
	lcd_init();
    while(ShaftCountLeft2<dist/5.338)
	{ lcd_cursor(2,1);
	  lcd_string("SCL");
	  lcd_print(2,5,ShaftCountLeft2*5.338,3);	
	  line_follow();
	   
	}
	
}
void line_follow_shaft_2(int dist)
{
	 sensor_data_interpretation();
    ShaftCountLeft2=0;
	lcd_init();
    while(ShaftCountLeft2<dist/5.338)
	{ lcd_cursor(2,1);
	  lcd_string("SCL");
	  lcd_print(2,5,ShaftCountLeft2*5.338,3);	
	  line_follow();
	   
	}
	
}
/*
void line_follow_shaft_2(int dist)
{
	 sensor_data_interpretation();
    ShaftCountLeft2=0;
	lcd_init();
    while(ShaftCountLeft2<dist/5.338)
	{ lcd_cursor(2,1);
	  lcd_string("SCL");
	  lcd_print(2,5,ShaftCountLeft2*5.338,3);	
	  line_follow_2();
	   
	}
	
}
*/
void line_follow2_shaft(int dist)
{
	 sensor_data_interpretation();
    ShaftCountLeft2=0;
  dist= dist;// +15;
	line_follow_shaft(dist);
	lcd_init();

    while(ShaftCountRight2<=3)
	{	
	  line_follow();
	  lcd_cursor(2,5);
	  lcd_string("SCR");
	  lcd_print(2,9,ShaftCountRight2,3);
	   if(ShaftCountRight2==3)
	     { 
		   forward_mm(15);
		   break;
		 }
		if((Left_white_line>10) && (Center_white_line>10))
		{
		  break;
		}
	   
	}

	
}

void line_follow2_shaft_2(int dist)
{
	 sensor_data_interpretation();
    ShaftCountLeft2=0;
  dist= dist;// +15;
	line_follow_shaft(dist);
	lcd_init();

    while(ShaftCountRight2<=3)
	{	
	  line_follow();
	  lcd_cursor(2,5);
	  lcd_string("SCR");
	  lcd_print(2,9,ShaftCountRight2,3);
	   if(ShaftCountRight2==3)
	     { 
		   forward_mm(10);
		   break;
		 }
		if((Left_white_line>10) && (Center_white_line>10))
		{
		  break;
		}
	   
	}

	
}
/*
void line_follow2_shaft_2(int dist)
{
	 sensor_data_interpretation();
    ShaftCountLeft2=0;
  dist= dist ;//+15;
	line_follow_shaft_2(dist);
	lcd_init();

    while(ShaftCountRight2<=3)
	{	
	  line_follow_2();
	  lcd_cursor(2,5);
	  lcd_string("SCR");
	  lcd_print(2,9,ShaftCountRight2,3);
	   if(ShaftCountRight2==3)
	     { 
		   forward_mm(10);
		   break;
		 }
		if((Left_white_line>10) && (Center_white_line>10))
		{
		  break;
		}
	   
	}

	
}
*/

 /*
* Function Name: line_align()
* Output :After the bot exits the leakage zone it moves ahead till it finds a black line
* Logic: the value of white line sensor increases as soon as it encounters black colour
			this condition is used to stop the bot and rotate right to align with line
* Example Call: line_align();
*/ 



void line_align()
{
	while(ShaftCountLeft2<170/5.338)
   {forward();}
   while(1)
	{

		Left_white_line = ADC_Conversion(3);	//Getting data of Left WL Sensor
		Center_white_line = ADC_Conversion(2);	//Getting data of Center WL Sensor
		Right_white_line = ADC_Conversion(1);	//Getting data of Right WL Sensor

		forward();
		lcd_print(2,1,Center_white_line,3);
		if(Center_white_line>0x28)
		{
	
			stop();
			break;
		}
	}
	forward_mm(50);
    right_degrees(90);//14:05 changes initially 100
}

 /*
* Function Name: line_align2()
* Output :while moving in anti clockwise direction after the bot exits the leakage zone 
		  it moves ahead till it finds a black line
* Logic: the value of white line sensor increases as soon as it encounters black colour
			this condition is used to stop the bot and rotate left to align with line
* Example Call: line_align();
*/ 

void line_align2()
{
     while(1)
	{

		Left_white_line = ADC_Conversion(3);	//Getting data of Left WL Sensor
		Center_white_line = ADC_Conversion(2);	//Getting data of Center WL Sensor
		Right_white_line = ADC_Conversion(1);	//Getting data of Right WL Sensor

		forward();
		lcd_print(2,1,Center_white_line,3);



		if(Center_white_line>0x28)
		{
	
			stop();
			break;
		}
	}
	forward_mm(50);
    right_degrees(85);//last changes initially 90
  
} 

 /*
* Function Name: back_mm
* Input : DistanceInMM:the distance to move in backward direction
* Output :Bot travels the input distance
* Logic:By using the linear distance and back() the bot travels the given distance in backward direction
* Example Call: back_mm(100);
*/ 

void back_mm(unsigned int DistanceInMM)
{
 back();
 linear_distance_mm(DistanceInMM);
}



 /*
* Function Name:line_follow_till_wall()
* Output : follows black line until the bot is 160 mm away from wall.
			this function is used to reach the corner containing the valve. 
* Logic: <Description of the function performed and the logic used
* in the function>
* Example Call: <Example of how to call this function>
*/ 



void line_follow_till_wall()
{
    flag=0;
	if(i_c==0)
	align();
	// line_follow_shaft(20);
	fln_shaft(110+i_c);	
	sensor_data_interpretation();
	fln_wall();
	stop();
	velocity(255,255);
	sensor_data_interpretation();
	c=converttomm(SHARP_3);
	if(c>135)
	  forward_mm(c-135);
	else
	  back_mm(135-c);
}
 /*
 * Function Name:line_follow_from_start()
 * Output :Used to reach node from start/stop point
* Logic: the bot moves forward for 20mm and then foolows black line to reach the node
* Example Call: line_follow_from_shaft();
*/ 
void line_follow_from_start()
{	
	
  while(ShaftCountLeft2<20/5.338)
	{
	  forward();
	}
    stop();
	
	line_follow_shaft(70);
	}  


 /*
 * Function Name: gotovalve()
 * Output :when the bot is present at the corner near a valve this functions rotates the bot in direction of valve and 
   moves the bot ahead by 11mm so that the colour of valve can be detected and the magnet be dropped
 * Example Call: gotovalve();
 */ 
void gotovalve()
{  sensor_data_interpretation();
   a=converttomm(SHARP_3);
 	d=converttomm(SHARP_5);
	c=(d/a);
	c=((atan(c))*(90/3.14));
	lcd_init();
	lcd_print(1,1,c,3);
	_delay_ms(100);
  right_degrees(c);

  forward_mm(12);
}
 /*
 * Function Name: gotovalve2()
 * Output :if the bot is moving in anti-clockwise direction and when the bot is present at the corner near a valve this
 	 functions rotates the bot in direction of valve and moves the bot ahead by 11mm so 
	  that the colour of valve can be detected and the magnet be dropped
 * Example Call: gotovalve2();
 */ 

void gotovalve2()
{
   sensor_data_interpretation();
	c=converttomm(SHARP_3);
	if(c>135)
	  forward_mm(c-135);
	else
	  back_mm(135-c); 
 
  sensor_data_interpretation();
   a=converttomm(SHARP_3);
 	d=converttomm(SHARP_5);
	c=(d/a);
	c=((atan(c))*(90/3.14));
	lcd_init();
	lcd_print(1,1,c,3);
	_delay_ms(100);
  left_degrees(c);
  forward_mm(12);
}



 

/*
* Function Name: rev()
* Output :rotates by 90 degree such that it aligns with the black line 
	
* Logic: the bot moves 70mm backward such that its center remains at 
			the corner and it rotates 90 degree to align with another black line
* Example Call:rev();
*/
void rev()
{
   back_mm(70);
   left_degrees(90);
	line_follow2_shaft(520); 

   
}
/*
* Function Name: back_line()
* Output :If the function is callled while the bot faces the valve
		the function reverts back the bot to be on the black line
* Logic: it moves 10mm back such that its center is at the corner 
			it realigns with the black line
			then it rotates 90 degrees to realign with the adjacent black line
* Example Call:back_line();//to align bot to the black line 
*/
void back_line()
{
 back_mm(15);

left_degrees(c);
	Center_white_line = ADC_Conversion(2);
 
/* while(1)
 {if((Right_white_line<=15) && (Left_white_line<=10) && (Center_white_line<10))
 	{velocity(0,100);
	left_degrees(3);
	}

else
{break;}
}
	stop();
 */


 back_mm(40);//35 to 40
 soft_left_degrees(90);
}


void back_line_2()
{
 back_mm(15);

right_degrees(c);
	Center_white_line = ADC_Conversion(2);
 
/* while(1)
 {if((Right_white_line<=15) && (Left_white_line<=10) && (Center_white_line<10))
 	{velocity(0,100);
	left_degrees(3);
	}

else
{break;}
}
	stop();
 */


 back_mm(40);//35 to 40
 right_degrees(180);
}



void line_align3()//new
{
     while(1)
	{

		Left_white_line = ADC_Conversion(3);	//Getting data of Left WL Sensor
		Center_white_line = ADC_Conversion(2);	//Getting data of Center WL Sensor
		Right_white_line = ADC_Conversion(1);	//Getting data of Right WL Sensor

		forward();
		lcd_print(2,1,Center_white_line,3);



		if(Center_white_line>0x28)
		{
	
			stop();
			break;
		}
	}
	forward_mm(50);
    left_degrees(85); 
  
} 

/*
*
* Function Name: node_2_node_rev()		
* Output:goes in anti clockwise direction from one valve to another 		
* Logic:similar as forward_node_2_node 		
* Example Call:node_2_node_rev();		
*
*/

void node_2_node_rev()//calibrate one half wall absent condition rest are fine
{ //back_line();
  //back_mm(70);
  //left_degrees(90);

 //line_follow_shaft_2(20); //180 to 200
 align();
fln_shaft(170);
	velocity(255,255);

 //line_follow2_shaft_2(20);
 left_degrees(90);  //Checking Half Wall presence using SHARP_3    

	  lcd_init();
	  _delay_ms(100);
	  sensor_data_interpretation();
	  //lcd_print(2,5,converttomm(SHARP_3),3);
	   
	    if(converttomm(SHARP_3)<200)
	     { 
		    right_degrees(90);
			
			//line_follow_shaft_2(20); 
			align();
			fln_shaft(230);
			velocity(255,255);

			line_follow2_shaft_2(20);
			left_degrees(90);

		   //line_follow_shaft(20);
			align();
			fln_shaft(285);
			velocity(255,255);
			
			forward_mm(40);
			//line_follow_shaft_2(20);
			align();
			fln_shaft(255);
			velocity(255,255);

			line_follow2_shaft_2(20);
			//forward_mm(30);
			//ShaftCountLeft2=0;
	 		left_degrees(90);
		}
	
	else 
		 {
	    	forward_mm(270);
			sensor_data_interpretation();
		 	_delay_ms(100);
		 	if(converttomm(SHARP_3)>350)
	      	{  
				line_align3();//2 initially
		  	}
		 
		 else 
		 {
		         right_degrees(85);
				 line_align3();
				 
				 //line_follow_shaft_2(20);
				 align();
				 fln_shaft(310);
				 velocity(255,255);	

				 line_follow2_shaft_2(20);
				 //forward_mm(15);
					left_degrees(90);
	           }
}

 line_follow_till_wall();


}




//**********************************************************************************
//ROUND2 Ends
//**********************************************************************************

/*
* Function Name: turn_no_wall()
* Output :While coming out of the leakage zone the 
			descision to get out of the leakage zone is made 
			based upon the presence or absence of the half walls
* Logic: while the bot comes out of leakage zone it follows wall for particular distance(shaftcount)
			then it checks for presence of walls with the help of the right sharp sensor
			if the wall is absent it rotates right else
			if moves forward until a black line in found
		
* Example Call:turn_no_wall();
*/
void turn_no_wall()
{
  lcd_init();
  forward_mm(40);
  velocity(180,180);
  sensor_data_interpretation();
  flag=converttomm_41sk(SHARP_5);
 // flag=flag-(flag%10);
  ShaftCountLeft2=0;
  lcd_init();
  lcd_print(2,1,flag,3);
	while(1)
	{   
	      sensor_data_interpretation();
		  lcd_print(2,9,converttomm_41sk(SHARP_5),3);
		  
		  if (converttomm_41sk(SHARP_5)<=(flag-15))
		    {  motion_set(0x06);
		       left_degrees(10);
			   //velocity(50,150);

			   forward_mm(45);
			   right_degrees(10);
		  
		     }
		    else if (converttomm_41sk(SHARP_5)>=(flag+15))
		   {	motion_set(0x06);
                 right_degrees(10);
          	//	velocity(150,50);
			   forward_mm(45);
			   left_degrees(10);
		   }
		    else 
		   { 	velocity(180,180);
			  motion_set(0x06);
		   }
		   if (converttomm_41sk(SHARP_5)>250)
		    break;
	}
  stop();
  flag=0;
  if ( ShaftCountLeft2>300/5.338)
  { 
    left_degrees(15);
	back_mm(20);
    line_align2();
    //line_follow_shaft_2(20);
	align();
	fln_shaft(200+(ctr*5)-10);
	 line_follow2_shaft(20);
   //back_mm(10);
   right_degrees(80);
   i_c=230;
   	  
align();
  }
  else 
  { velocity(255,255);
    right_degrees(30);
   forward_mm(130);
   right_degrees(60);
  	forward_mm(125);
   line_align();
   i_c=0;
  }
}




//************************************************************************************
//LED DETECTION FUNCTIONS
//************************************************************************************

 /*
 * Function Name: beep
 * Output : sounds buzzer for 1 sec
 * Logic: buzzer is set to on and set to off after 1 sec delay
 * Example Call: beep();
 
 */ 

void beep()
{buzzer_on();
 _delay_ms(1000);		
 buzzer_off(); 

}
 
 
 /*
 * Function Name: colour_led
 * Output : detects red blue or green colour and sounds buzzer and glows corresponding led for 1 sec
 * Logic:when the bot is present under the led array the function first reads and stores the values of number of pulses and stores its values of corresponding colour in variables red
 	,green, blue.
 	then they are compared with threshold values and the if statements glow and sound buzzer when led is detected.
 * Example Call: colour_led();
 */ 
void colour_led()
{
    
       red_read(); //display the pulse count when red filter is selected
	   green_read(); //display the pulse count when green filter is selected
	   blue_read(); //display the pulse count when blue filter is selected
 
	
      if(red>300&&green>300&&blue>300)
      
      {           if((red>green)&&(red>blue)&&(r==2)&&(red>1500))
	              {glow1();
				  beep();
				  off();           r=1;  
				  counter_colour++;      }
                  
                  if((blue>green)&&(blue>red)&&(b==2))
	              {glow2();
				  beep();
				  off();        b=1;      
				  counter_colour++;    }
	              
                  if((green>red)&&(green>blue)&&(g==2))
	              {glow3();
				  beep();
				  off();           g=1; 
				  counter_colour++;      }
                  
                                  
      }
   
 else

{
  lcd_init();
  lcd_string("no led");}   
      // no_filter();//display the pulse count when no filter is selected
	   //_delay_ms(500);
}


//************************************************************************************
//END OF LED DETECTION FUNCTIONS
//************************************************************************************


//************************************************************************************
//Valve colour detection and magnet dropping functions
//************************************************************************************
 

 /*
 * Function Name:servo_1
 * Input : takes the degrees as input at which we want the servo to be positioned
 * Output : the servo moves to corresponding angle
 * Logic: IDK
 * Example Call:servo_1(60)
 */ 


void servo_1(unsigned char degrees)  
{
 float PositionPanServo = 0;
  PositionPanServo = ((float)degrees / 1.86) + 35.0;
 OCR1AH = 0x00;
 OCR1AL = (unsigned char) PositionPanServo;
}

 /*
 * Function Name: drop()
 * Output :the servo rotates by 60 degrees each time rhis function is called
  * Logic:servo_count is avariable which is reduced by 60 degrees at each function call
          and servo_1() takes the rotating part of servo to that angle
 * Example Call: drop()
 */ 


void drop()
{				  servo_count=servo_count-60;
	              servo_1(servo_count);
	              _delay_ms(2000);
}
 /*
 * Function Name:colour_valve()
 * Output :  If the valve is already detected the mechanism drops the magnet into the valve using drop() function. 
 * Logic: The no. of pulses of red,green and blue are read and these are compared at each valve 
 		  to slelect the correct valve and drop the magnet if the leakage has been already detected
		   (values of r,g &b are 1 if leakage is detected )
 * Example Call: colour_valve();
 */ 


void colour_valve()
{

       red_read(); //display the pulse count when red filter is selected
	   green_read(); //display the pulse count when green filter is selected
	   blue_read(); //display the pulse count when blue filter is selected
	 	
	 	 if(red>1700&&green>1700&&blue>1700)
		  {
	    if((red>green)&&(red>blue)&&(r==1))
	              {
				  glow1();  r=0; drop(); off(); 
				  counter_colour--;
				  if(node==2)
				  {cntr=1;}
				                    
				  }
                 
        if((blue>green)&&(blue>red)&&(b==1))
	              {
				  glow2();  b=0;
				  counter_colour--;
				   drop();off();
				  if(node==2)
				  {cntr=2;}
				                    
				  
                 
				  }
	             
         if((green>red)&&(green>blue)&&(g==1))
	              {
				  glow3();    g=0; 
				  counter_colour--;		  
				  drop();off();

				   if(node==2)
				  {cntr=3;}
				                    
				  
                   
				  }
    	 
		lcd_init();
	    if((red>green)&&(red>blue))
	              { 
				  if(node==2)
				  {lcd_string("RFH");
				  _delay_ms(1000);
				  cntr=1;}
				                    
				  }
                 
        if((blue>green)&&(blue>red))
	              {
				  if(node==2)
				  {lcd_string("BFH");
				  _delay_ms(1000);
				  
				  
				  cntr=2;}
				                    
				  
                 
				  }
	             
         if((green>red)&&(green>blue))
	              {

				   if(node==2)
				  {lcd_string("GFH");
				  _delay_ms(1000);
				  
				  
				  cntr=3;}
				                    
				  
                   
				  }
    	 		 
	  }
     
	else
 	{  
  	lcd_string("no colour");
 
	 }

}







/*
*
* Function Name: line_till_wall_detect()	
* Output: follows black line for 130mm		
* Logic:Original code was written roughly but to match the code  documentation criteria we made a function 		
* Example Call:	line_till_wall_detect();	
*
*/


void line_till_wall_detect()
{
    //line_follow_shaft(20);
	align();
	fln_shaft(130);
	velocity(255,255);
}


/*
*
* Function Name: detect_wall()
* Output: 		checks if wall at rhs ,if not it goes forward 1cm and again checkes for the wall 
when the wall is absent it goes forward and turns right and is ready for insertion into the node
* Logic: 		
* Example Call:		
*
*/


void detect_wall()
{
  while(1)
  {
   if(converttomm_41sk(SHARP_5)>200)
   {velocity(255,255);
     forward_mm(50);
     right_degrees(90);//102 converted to 90 16:35
	 break;
   }
   else
   {
    fln_shaft(10);
    if (rnd==0)
	 wl=1;
   }
  }
}

void detect_wall2()
{
  while(1)
  {
   if(converttomm_41sk(SHARP_5)>200)
   {
     //forward_mm(50);
     //right_degrees(90);//102 converted to 90 16:35
	 break;
   }
   else
   {
     line_follow();
     
   }
  }
}


/*
*
* Function Name: rev_the_end
* Output:Takes the robot from location,node 0(4th valve clockwise) from start and sounds buzzer 		
* Logic: Uses shaftcounters to acuurately guide back the bot to start		
* Example Call:rev_the_end();		
*
*/
void rev_the_end()//call rev() before using this
{	//rev();
	//back_mm(70);
   //left_degrees(90);
	 
	 //line_follow_shaft(20);//11:17
	 align();
	 fln_shaft(400);
	 velocity(255,255);
	


     line_follow2_shaft(30);//11:17
	left_degrees(90);

//	line_follow_shaft_2(20);
	align();
	fln_shaft(270);
	velocity(255,255);
	

    soft_right_degrees(90);
   	buzzer_on();
   	_delay_ms(5000);
   	buzzer_off();
	stop();
}




/*
*
* Function Name: forward_the_end
* Output:Takes the robot from location l4 ro start and sounds buzzer 		
* Logic: Uses shaftcounters to acuurately guide back the bot to start		
* Example Call:forward_the_end();		
*
*/
void forward_the_end()
{  
align();
  ShaftCountLeft2=0;
  lcd_init();
  lcd_print(2,9,ShaftCountLeft2,3);
 //back_mm(20);
 // line_follow_shaft(200);  //
  align();
  fln_shaft(350);
	velocity(255,255);

  line_follow2_shaft(20);//changed
  //  forward_mm(30);
  right_degrees(85);

  // line_follow_shaft_2(20);
  align();
   fln_shaft(305);
	velocity(255,255);
		 	
   
      soft_left_degrees(90);
   buzzer_on();
   _delay_ms(5000);
   buzzer_off();
   
}

/*
*
* Function Name:forward_node_2_node	
* Output:takes bot from one leakage zone to another in clockwise direction 		
* Logic: line follow if a half wall is present and follow black line to reach another leakage zone
		 if half wall is absent it turns right and goes forward checks for wall
		 if wall is present it turns left and catches black line and follows it
		 if wall is absent it goes ahaead and catches black line to reach another valve			
* Example Call:forward_node_2_node		
*
*/
/*
void forward_node_2_node()
{      
        
        line_till_wall_detect();
	    ShaftCountLeft2=0;
		detect_wall2();
		stop();
 	   	   	  
		
        if(ShaftCountLeft2>25)
		{ 
		 flag_3 =1;
		 i_c=230; 
		}

     else
	  {
	     flag_3= 0;
	  }
	lcd_init();
			lcd_print(1,3,ShaftCountLeft2,3);
			_delay_ms(500);
		if(flag_3 ==0)
		{   
		    line_follow_shaft(30);
			right_degrees(90);
			forward_mm(300);
			stop();
		//	stop();
		 init_devices();
    	 sensor_data_interpretation();
		 lcd_init();
		 lcd_print(2,1,converttomm(SHARP_3),3);
		 if(converttomm(SHARP_3)<400)
		 {
		  i_c=230;
		  left_degrees(90);
          forward_mm(10);
		  line_align2();
		  
		  forward_mm(30);
	      line_follow2_shaft(330);// changed
		  
          //forward_mm(50);
          right_degrees(85);
	     }
		 else
		 { 
          i_c=0;
  		  forward_mm(250);
          line_align2();
	      	  
		 }
		}
		if(flag_3==1)
		{
		 back_mm(25);
		 line_follow2_shaft(40);
		 back_mm(10);
		 right_degrees(90);
		 line_follow_shaft(290);
		 forward_mm(50);
		 line_follow_shaft(200);
         line_follow2_shaft(50);
		 //forward_mm(10);
		 right_degrees(85);
		}
		line_follow_till_wall();
		
}

*/
void forward_node_2_node()
{	  
	lcd_init();
	sensor_data_interpretation();
	lcd_string("50");
	
	align();
	//line_follow_shaft(20);
	fln_shaft(120);//140
	velocity(255,255);
	
	ShaftCountLeft2=0;
	ShaftCountRight2=0;
	sensor_data_interpretation();
	stop();
	sensor_data_interpretation();
	_delay_ms(250);
	if(converttomm_41sk(SHARP_5)>400)
	{	
	 lcd_init();
		lcd_string("NFW1");
		//forward_mm(20);
		right_degrees(85);
		forward_mm(300);
		stop();
		sensor_data_interpretation();
		_delay_ms(250);	
		if(converttomm(SHARP_3)<400)

		{lcd_init();
		lcd_string("FW 2");
		
		left_degrees(90);
		line_align2();
		forward_mm(20);//remove this if not work make below 250
		 
		// line_follow_shaft(20);
		 align();
		 fln_shaft(190);//210
	     velocity(255,255);

		 line_follow2_shaft(20);

		 right_degrees(85);
		 	
		}
	
		else
		{lcd_init();
		lcd_string("NFW2");
		forward_mm(250);
		line_align2();
		align();
		}

	}

	else
	{
	
	lcd_init();
		lcd_string("FW1");
		
	//line_follow_shaft(20);
	align();
	fln_shaft(125);//140
	velocity(255,255);

	line_follow2_shaft(20);
	right_degrees(85);
	
	align();
	//line_follow_shaft(20);
	fln_shaft(260);//280
	velocity(255,255);

	forward_mm(20);
	
	align();
	//line_follow_shaft(20);
	fln_shaft(290);//290
	velocity(255,255);

	line_follow2_shaft(20);
	right_degrees(90);
	}
	sensor_data_interpretation();
		line_follow_till_wall();
		
	
}

/*
void forward_node_2_node()
{      
        line_till_wall_detect();
	   
		detect_wall2();
		stop();
 	   	   	  
			lcd_init();
			lcd_print(1,3,flag_3,3);
			_delay_ms(1000);
 	  

		if(flag_3 ==0)
		{   
		    
			right_degrees(90);
			forward_mm(300);
			stop();
		//	stop();
		 init_devices();
    	 sensor_data_interpretation();
		 lcd_init();
		 lcd_print(2,1,converttomm(SHARP_3),3);
		 if(converttomm(SHARP_3)<400)
		 {
		  left_degrees(90);
          forward_mm(8);
		  line_align2();
		  
		  forward_mm(30);
	      line_follow2_shaft(330);// changed
		  
          //forward_mm(50);
          right_degrees(85);
	     }
		 else
		 { 
		  forward_mm(150);
          line_align2();
	      	  
		 }
		}
		if(flag_3==1)
		{
		 line_follow2_shaft(0);
		 forward_mm(10);
		 right_degrees(85);
		 line_follow_shaft(300);
		 forward_mm(40);
         line_follow2_shaft(100);
		 forward_mm(10);
		 right_degrees(85);
		}
		line_follow_till_wall();
		
}

*/


/*
*
* Function Name: all_checked()
* Output:when all the leakage zones have been checked,the bot only needs to fix the valves
		 this function first checks if any of the leakages have been detected and not fixed
		 if they are not fixed they are fixed travelling using node_2_node forward and reverse functions
		 
		 after the leakages are fixed based upon the node position the bot travels back to start. 		
* Logic:counting in clockwise direction the 4th valve location is fixed as node 0
		checking the values of r,g,b the function travels to that node to drop the magnet.
		
		If the magnets have been dropped the bot travels back to start 		
* Example Call:all_checked();		
*
*/

void all_checked()
{
 while(r==1 || g==1 || b==1)//checks if any of the leakages have been detected and not fixed
{
		if((((cntr==1)&&(r==1))||((cntr==3)&&(g==1))||((cntr==2)&&(b==1)))&&(colour_flag==0) )
		{lcd_init();
		lcd_print(1,1,node,2);
		_delay_ms(1000);
		back_mm(70);//40 to 50
		 left_degrees(90);
		node_2_node_rev();
		gotovalve2();
		colour_valve();
		back_line_2();
		node=3;
		cntr=0;
		
		
		}
   	else
	{   if(node==0)//clockwise 4th valve
		{
		  forward_node_2_node();
		}
	if(node==1)//clockwise 1st valve
		{
		 forward_node_2_node();
		 
		}
		if(node==2)//clockwise 2nd valve
		{
		  forward_node_2_node();
		 		
		}
		if(node==3)//clockwise 3rd valve
		{
		  forward_node_2_node();	node=-1;	
		}
	
		gotovalve();
		
		colour_valve();
		back_line();
		node++;
		lcd_init();
		lcd_print(1,1,node,2);
		_delay_ms(1000);

}
}

while(r==0 || g==0 || b==0||r==2 || g==2 || b==2)
{
   	   if(node==0)
		{back_mm(10);
			forward_the_end();
	break;
		}
		
		if(node==1)
		{back_mm(40);
		left_degrees(90);
		rev_the_end();
		break;}
		
		if(node==2)
		{/*
		forward_node_2_node();
		forward_mm(30);
		left_degrees(90);
		forward_node_2_node();
		forward_mm(30);
		left_degrees(90);
		forward_the_cend();*/
		back_mm(65);//remove 60 made to 65
		left_degrees(90);
		node_2_node_rev();
		forward_mm(15);
		right_degrees(90);
		rev_the_end();
		break;

		}
		
		if(node==3)
		{forward_node_2_node();
		forward_mm(10);
		left_degrees(90);
		forward_the_end();
		break;
		}
}




}/*
*
* Function Name: forward_till_wall()
* output:This function takes the bot from the start leakage area to the the leakage zone  this function is called only the first time after start
		in all other cases goto_led is used		
* Logic:if a wall is detected the bot follows wall until it reaches the leakage area else it relies on shaft count to reach 
		the leakage zone.
		The stopping condition is obtained by the sharp 3 sensor which facilates it to stop below the led array* Example Call:		
*example:forward_till_wall()
*/


void forward_till_wall()
{
	  lcd_init();
     forward();
     velocity(255,255);
	 sensor_data_interpretation();
	 ShaftCountLeft2=0;
	 while(converttomm_41sk(SHARP_5)>250 || ShaftCountLeft2<200/5.338 ) 
	{  
	   lcd_init();
       sensor_data_interpretation();
	   lcd_print(2,1,converttomm(SHARP_3),3); 
	   forward();
	   
	}
	velocity(255,255);
	stop();

}
/*
*
* Function Name:goto_led()
	
* Output:This function takes the bot from the start leakage area to the the leakage zone  		
* Logic:if a wall is detected the bot follows wall until it reaches the leakage area else it relies on shaft count to reach 
		the leakage zone.
		The stopping condition is obtained by the sharp 3 sensor which facilates it to stop below the led array 		
* Example Call:	goto_led()	
*
*/


void goto_led()
{forward_mm(90);//70 to 90



    velocity(180,180); 
	lcd_init();
	ShaftCountLeft2=0;
	flag_2=0;
	while(1)
	{
	      sensor_data_interpretation();
		  if( converttomm(SHARP_3)<=165)
		    break;
		 if((converttomm_41sk(SHARP_5)<=80)&&(flag_2<5))//15:34 added//11:05 edited
		{flag_2++;
		forward_mm(5);
		}

		  lcd_print(2,9,SHARP_5,3);
		  lcd_print(2,1,converttomm_41sk(SHARP_5),3);
		  if (converttomm_41sk(SHARP_5)<=75)//75
		    {  motion_set(0x06);
		       left_degrees(10);
			   _delay_ms(100);
			   forward_mm(20);
			   _delay_ms(100);
			   right_degrees(10);

		     }
		    else if (converttomm_41sk(SHARP_5)>=100)//100
		   {	motion_set(0x06);
                 right_degrees(10);
				   _delay_ms(100);
				 forward_mm(45);
				 _delay_ms(100);
				 left_degrees(10);
          
		   }
		    else 
		   { 	
			  motion_set(0x06);
		   }
		   
	}
	stop();
	lcd_init();
	
}

int main()
{	
	color_sensor_scaling();
    init_devices();
	lcd_set_4bit();
	lcd_init();
	
    servo_1(185);
	sensor_data_interpretation();
	
    line_follow_from_start();
  
   right_degrees(15);//18
   forward_mm(70);
   left_degrees(10);	
   
   forward_till_wall();
   
   
   	while(1)
   { 
	flag=0; 	
	goto_led();
	
	colour_led();
	if((((cntr==1)&&(r==1)&&(g!=1)&&(b!=1))||((cntr==3)&&(g==1)&&(r!=1)&&(b!=1))||((cntr==2)&&(b==1)&&(g!=1)&&(r!=1)))&&(colour_flag==0) )//to fix valve just b4 led;
		{
		lcd_init();
		lcd_cursor(1,1);
		lcd_string("NEW");
		right_degrees(185);
		velocity(180,180);
        sensor_data_interpretation();
        flag=converttomm_41sk(SHARP_5);
        // flag=flag-(flag%10);
          ShaftCountLeft2=0;
		  	while(1)
	{   
	      sensor_data_interpretation();
		  lcd_print(2,9,converttomm_41sk(SHARP_5),3);
		  
		  if (converttomm_41sk(SHARP_5)<=(flag-15))
		    {  motion_set(0x06);
		       left_degrees(10);
			   //velocity(50,150);

			   forward_mm(45);
			   right_degrees(10);
		  
		     }
		    else if (converttomm_41sk(SHARP_5)>=(flag+15))
		   {	motion_set(0x06);
                 right_degrees(10);
          	//	velocity(150,50);
			   forward_mm(45);
			   left_degrees(10);
		   }
		    else 
		   { 	velocity(180,180);
			  motion_set(0x06);
		   }
		   if ((converttomm_41sk(SHARP_5)>250)&&(wl==1))
		    {
			  right_degrees(10);
              line_align3();
              align();
			  fln_shaft(200+(ctr*5));
			  line_follow2_shaft(20);
			  left_degrees(100);
			  align();
			  fln_wall();
			  velocity(255,255);
			  gotovalve2();
			  colour_valve();
			  back_line_2();
			  node=3;
			  forward_node_2_node();
			  left_degrees(90);
			  forward_the_end();

			}
			else if(wl==0)
			{ 
			  if (ShaftCountLeft2>400/5.338)
			  {
			    left_degrees(90);
				line_align3();
                align();
				fln_wall();
				velocity(255,255);
			  gotovalve2();
			  colour_valve();
			  back_line_2();
			  node=3;
			 forward_node_2_node();
			  left_degrees(90);
			  forward_the_end();

			  }
			}

	}

		}

	right_degrees(185);
	forward_mm(20);
	turn_no_wall();
    line_follow_till_wall();
	
	if(((r+g+b)>5)&&(node!=2))// to not check valve without detecting led
	{forward_mm(18);
	left_degrees(90);
	line_follow_shaft(50);}


	else
	{
	gotovalve();
	colour_valve();
	init_devices();
	sensor_data_interpretation();
	back_line();
	}
	

	if(node>=3)
	 {
	  break;
	 }
flag_2=0;
if((node==2)&&(r!=2)&&(b!=2)&&(g!=2))
	{forward_node_2_node();
	gotovalve();
	colour_valve();
	back_line();
	node++;
	break;
	}

	 init_devices();
	sensor_data_interpretation();
	line_till_wall_detect();
	detect_wall();
    velocity(255,255);
	forward_mm(285);//was 290
	right_degrees(95);
	forward_mm(110);
	node++;

 }
 rnd=1;
 if(node>=3)
  node=0;
  if(counter_colour>1)
  {colour_flag=1;}
 all_checked();

    stop();
	read = 0;
	TIMSK4 = 0x00;
	TCCR4A = 0x00; 
	TCCR4C = 0x00;
 	TCCR4B = 0x00;


}

